<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Spring - Java/J2EE Application Framework</title><link rel="stylesheet" href="../styles/html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.70.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>Spring - Java/J2EE Application Framework</h1></div><div><h2 class="subtitle">
          Reference Documentation
        </h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Rod</span> <span class="surname">Johnson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Juergen</span> <span class="surname">Hoeller</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Alef</span> <span class="surname">Arendsen</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Colin</span> <span class="surname">Sampaleanu</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Rob</span> <span class="surname">Harrop</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Thomas</span> <span class="surname">Risberg</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Darren</span> <span class="surname">Davison</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Dmitriy</span> <span class="surname">Kopylenko</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Pollack</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Thierry</span> <span class="surname">Templier</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Erwin</span> <span class="surname">Vervaet</span></h3></div></div></div><div><p class="releaseinfo">Version 1.2.9</p></div><div><div class="legalnotice"><a name="d0e68"></a>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</div></div><div><p class="pubdate">(Work in progress)</p></div></div><hr></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#introduction-overview">1.1. Overview</a></span></dt><dt><span class="sect1"><a href="#overview-usagescenarios">1.2. Usage scenarios</a></span></dt></dl></dd><dt><span class="chapter"><a href="#background">2. Background information</a></span></dt><dd><dl><dt><span class="sect1"><a href="#background-ioc">2.1. Inversion of Control / Dependency Injection</a></span></dt></dl></dd><dt><span class="chapter"><a href="#beans">3. Beans, BeanFactory and the ApplicationContext</a></span></dt><dd><dl><dt><span class="sect1"><a href="#beans-introduction">3.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#beans-basics">3.2. BeanFactory and BeanDefinitions - the basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="#beans-factory">3.2.1. The BeanFactory</a></span></dt><dt><span class="sect2"><a href="#beans-definition">3.2.2. The BeanDefinition</a></span></dt><dt><span class="sect2"><a href="#beans-factory-class">3.2.3. The bean class</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e479">3.2.3.1. Bean creation via constructor</a></span></dt><dt><span class="sect3"><a href="#d0e495">3.2.3.2. Bean creation via static factory method</a></span></dt><dt><span class="sect3"><a href="#beans-instance-factory-method">3.2.3.3. Bean creation via instance factory method</a></span></dt></dl></dd><dt><span class="sect2"><a href="#beans-beanname">3.2.4. The bean identifiers (<code class="literal">id</code> and
      <code class="literal">name</code>)</a></span></dt><dt><span class="sect2"><a href="#beans-factory-modes">3.2.5. To singleton or not to singleton</a></span></dt></dl></dd><dt><span class="sect1"><a href="#beans-dependencies">3.3. Properties, collaborators, autowiring and dependency
    checking</a></span></dt><dd><dl><dt><span class="sect2"><a href="#beans-factory-collaborators">3.3.1. Setting bean properties and collaborators</a></span></dt><dt><span class="sect2"><a href="#d0e746">3.3.2. Constructor Argument Resolution</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e756">3.3.2.1. Constructor Argument Type Matching</a></span></dt><dt><span class="sect3"><a href="#d0e769">3.3.2.2. Constructor Argument Index</a></span></dt></dl></dd><dt><span class="sect2"><a href="#beans-factory-properties-detailed">3.3.3. Bean properties and constructor arguments detailed</a></span></dt><dd><dl><dt><span class="sect3"><a href="#beans-value-element">3.3.3.1. The <code class="literal">value</code> element</a></span></dt><dt><span class="sect3"><a href="#beans-null-element">3.3.3.2. The <code class="literal">null</code> element</a></span></dt><dt><span class="sect3"><a href="#beans-collection-elements">3.3.3.3. The collection elements</a></span></dt><dt><span class="sect3"><a href="#beans-inner-beans">3.3.3.4. Inner bean definitions via nested bean elements</a></span></dt><dt><span class="sect3"><a href="#beans-idref-element">3.3.3.5. The <code class="literal">idref</code> element</a></span></dt><dt><span class="sect3"><a href="#beans-ref-element">3.3.3.6. The <code class="literal">ref</code> element</a></span></dt><dt><span class="sect3"><a href="#d0e1000">3.3.3.7. Value and Ref shortcut
        forms</a></span></dt><dt><span class="sect3"><a href="#d0e1106">3.3.3.8. Compound property names</a></span></dt></dl></dd><dt><span class="sect2"><a href="#beans-factory-method-injection">3.3.4. Method Injection</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e1161">3.3.4.1. Lookup method Injection</a></span></dt><dt><span class="sect3"><a href="#d0e1197">3.3.4.2. Arbitrary method replacement</a></span></dt></dl></dd><dt><span class="sect2"><a href="#beans-factory-dependson">3.3.5. Using <code class="literal">depends-on</code></a></span></dt><dt><span class="sect2"><a href="#beans-factory-autowire">3.3.6. Autowiring collaborators</a></span></dt><dt><span class="sect2"><a href="#beans-factory-dependencies">3.3.7. Checking for dependencies</a></span></dt></dl></dd><dt><span class="sect1"><a href="#beans-factory-nature">3.4. Customizing the nature of a bean</a></span></dt><dd><dl><dt><span class="sect2"><a href="#beans-factory-lifecycle">3.4.1. Lifecycle interfaces</a></span></dt><dd><dl><dt><span class="sect3"><a href="#beans-factory-lifecycle-initializingbean">3.4.1.1. InitializingBean / <code class="literal">init-method</code></a></span></dt><dt><span class="sect3"><a href="#beans-factory-lifecycle-disposablebean">3.4.1.2. DisposableBean / <code class="literal">destroy-method</code></a></span></dt></dl></dd><dt><span class="sect2"><a href="#beans-factory-aware">3.4.2. Knowing who you are</a></span></dt><dd><dl><dt><span class="sect3"><a href="#beans-factory-aware-beanfactoryaware">3.4.2.1. BeanFactoryAware</a></span></dt><dt><span class="sect3"><a href="#beans-factory-aware-beannameaware">3.4.2.2. BeanNameAware</a></span></dt></dl></dd><dt><span class="sect2"><a href="#beans-factory-lifecycle-factorybean">3.4.3. FactoryBean</a></span></dt></dl></dd><dt><span class="sect1"><a href="#beans-child-bean-definitions">3.5. Abstract and child bean definitions</a></span></dt><dt><span class="sect1"><a href="#beans-factory-client">3.6. Interacting with the BeanFactory</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e1704">3.6.1. Obtaining a FactoryBean, not its product</a></span></dt></dl></dd><dt><span class="sect1"><a href="#beans-factory-customizing">3.7. Customizing beans with BeanPostProcessors</a></span></dt><dt><span class="sect1"><a href="#beans-factory-customizing-factory-postprocessors">3.8. Customizing bean factories with BeanFactoryPostProcessors</a></span></dt><dd><dl><dt><span class="sect2"><a href="#beans-factory-placeholderconfigurer">3.8.1. The <code class="literal">PropertyPlaceholderConfigurer</code></a></span></dt><dt><span class="sect2"><a href="#beans-factory-overrideconfigurer">3.8.2. The <code class="literal">PropertyOverrideConfigurer</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#beans-beanfactory-customeditors">3.9. Registering additional custom PropertyEditors</a></span></dt><dt><span class="sect1"><a href="#beans-beanfactory-alias">3.10. Using the alias element to add aliases for existing beans</a></span></dt><dt><span class="sect1"><a href="#context-introduction">3.11. Introduction to the <code class="literal">ApplicationContext</code></a></span></dt><dt><span class="sect1"><a href="#context-functionality">3.12. Added functionality of the
    <code class="literal">ApplicationContext</code></a></span></dt><dd><dl><dt><span class="sect2"><a href="#context-functionality-messagesource">3.12.1. Using the <code class="literal">MessageSource</code></a></span></dt><dt><span class="sect2"><a href="#context-functionality-events">3.12.2. Propagating events</a></span></dt><dt><span class="sect2"><a href="#context-functionality-resources">3.12.3. Low-level resources and the application context</a></span></dt></dl></dd><dt><span class="sect1"><a href="#beans-context-customization">3.13. Customized behavior in the ApplicationContext</a></span></dt><dd><dl><dt><span class="sect2"><a href="#beans-context-applicationcontextaware">3.13.1. <code class="literal">ApplicationContextAware</code> marker
      interface</a></span></dt><dt><span class="sect2"><a href="#beans-context-beanpostprocessor">3.13.2. The <code class="literal">BeanPostProcessor</code></a></span></dt><dt><span class="sect2"><a href="#beans-context-beanfactorypostprocessor">3.13.3. The <code class="literal">BeanFactoryPostProcessor</code></a></span></dt><dt><span class="sect2"><a href="#beans-context-placeholderconfigurer">3.13.4. The <code class="literal">PropertyPlaceholderConfigurer</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#beans-applicationcontext-customeditors">3.14. Registering additional custom PropertyEditors</a></span></dt><dt><span class="sect1"><a href="#d0e2303">3.15. Setting a bean property or constructor arg from a property
    expression</a></span></dt><dt><span class="sect1"><a href="#d0e2331">3.16. Setting a bean property or constructor arg from a field
    value</a></span></dt><dt><span class="sect1"><a href="#d0e2351">3.17. Invoking another method and optionally using the return
    value.</a></span></dt><dt><span class="sect1"><a href="#context-import">3.18. Importing Bean Definitions from One File Into Another</a></span></dt><dt><span class="sect1"><a href="#context-create">3.19. Creating an ApplicationContext from a web application</a></span></dt><dt><span class="sect1"><a href="#d0e2507">3.20. Glue code and the evil singleton</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2525">3.20.1. Using SingletonBeanFactoryLocator and
      ContextSingletonBeanFactoryLocator</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#resources">4. Abstracting Access to Low-Level Resources</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e2552">4.1. Overview</a></span></dt><dt><span class="sect1"><a href="#d0e2572">4.2. The <code class="literal">Resource</code> interface</a></span></dt><dt><span class="sect1"><a href="#d0e2660">4.3. Built-in Resource implementations</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2665">4.3.1. <code class="literal">UrlResource</code></a></span></dt><dt><span class="sect2"><a href="#d0e2703">4.3.2. <code class="literal">ClassPathResource</code></a></span></dt><dt><span class="sect2"><a href="#d0e2740">4.3.3. <code class="literal">FileSystemResource</code></a></span></dt><dt><span class="sect2"><a href="#d0e2758">4.3.4. <code class="literal">ServletContextResource</code></a></span></dt><dt><span class="sect2"><a href="#d0e2772">4.3.5. <code class="literal">InputStreamResource</code></a></span></dt><dt><span class="sect2"><a href="#d0e2789">4.3.6. <code class="literal">ByteArrayResource</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e2803">4.4. The <code class="literal">ResourceLoader</code> Interface</a></span></dt><dt><span class="sect1"><a href="#d0e2858">4.5. The <code class="literal">ResourceLoaderAware</code> interface</a></span></dt><dt><span class="sect1"><a href="#d0e2887">4.6. Setting <code class="literal">Resource</code>s as properties</a></span></dt><dt><span class="sect1"><a href="#d0e2938">4.7. Application contexts and <code class="literal">Resource</code> paths</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2944">4.7.1. Constructing application contexts</a></span></dt><dt><span class="sect2"><a href="#d0e2977">4.7.2. The <code class="literal">classpath*:</code> prefix</a></span></dt><dt><span class="sect2"><a href="#d0e3008">4.7.3. Unexpected application context handling of FileSystemResource
      absolute paths</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#validation">5. PropertyEditors, data binding, validation and the BeanWrapper</a></span></dt><dd><dl><dt><span class="sect1"><a href="#validation-introduction">5.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#validation-databinding">5.2. Binding data using the <code class="literal">DataBinder</code></a></span></dt><dt><span class="sect1"><a href="#beans-beans">5.3. Bean manipulation and the <code class="literal">BeanWrapper</code></a></span></dt><dd><dl><dt><span class="sect2"><a href="#beans-beans-conventions">5.3.1. Setting and getting basic and nested properties</a></span></dt><dt><span class="sect2"><a href="#beans-beans-conversion">5.3.2. Built-in <code class="literal">PropertyEditors</code>, converting
      types</a></span></dt><dt><span class="sect2"><a href="#beans-beans-other">5.3.3. Other features worth mentioning</a></span></dt></dl></dd><dt><span class="sect1"><a href="#validator">5.4. Validation using Spring's Validator interface</a></span></dt><dt><span class="sect1"><a href="#validation-errors">5.5. The Errors interface</a></span></dt><dt><span class="sect1"><a href="#validation-conversion">5.6. Resolving codes to error messages</a></span></dt></dl></dd><dt><span class="chapter"><a href="#aop">6. Spring AOP: Aspect Oriented Programming with Spring</a></span></dt><dd><dl><dt><span class="sect1"><a href="#aop-introduction">6.1. Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#aop-introduction-defn">6.1.1. AOP concepts</a></span></dt><dt><span class="sect2"><a href="#aop-introduction-spring-defn">6.1.2. Spring AOP capabilities and goals</a></span></dt><dt><span class="sect2"><a href="#aop-introduction-proxies">6.1.3. AOP Proxies in Spring</a></span></dt></dl></dd><dt><span class="sect1"><a href="#aop-introduction-pointcuts">6.2. Pointcuts in Spring</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3772">6.2.1. Concepts</a></span></dt><dt><span class="sect2"><a href="#d0e3821">6.2.2. Operations on pointcuts</a></span></dt><dt><span class="sect2"><a href="#d0e3846">6.2.3. Convenience pointcut implementations</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e3851">6.2.3.1. Static pointcuts</a></span></dt><dt><span class="sect3"><a href="#d0e3917">6.2.3.2. Dynamic pointcuts</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e3950">6.2.4. Pointcut superclasses</a></span></dt><dt><span class="sect2"><a href="#d0e3963">6.2.5. Custom pointcuts</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e3970">6.3. Advice types in Spring</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e3975">6.3.1. Advice lifecycles</a></span></dt><dt><span class="sect2"><a href="#aop-introduction-advice-types">6.3.2. Advice types in Spring</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e3997">6.3.2.1. Interception around advice</a></span></dt><dt><span class="sect3"><a href="#d0e4034">6.3.2.2. Before advice</a></span></dt><dt><span class="sect3"><a href="#d0e4068">6.3.2.3. Throws advice</a></span></dt><dt><span class="sect3"><a href="#d0e4108">6.3.2.4. After Returning advice</a></span></dt><dt><span class="sect3"><a href="#d0e4128">6.3.2.5. Introduction advice</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#d0e4291">6.4. Advisors in Spring</a></span></dt><dt><span class="sect1"><a href="#aop-pfb">6.5. Using the ProxyFactoryBean to create AOP proxies</a></span></dt><dd><dl><dt><span class="sect2"><a href="#aop-pfb-1">6.5.1. Basics</a></span></dt><dt><span class="sect2"><a href="#aop-pfb-2">6.5.2. JavaBean properties</a></span></dt><dt><span class="sect2"><a href="#d0e4440">6.5.3. Proxying interfaces</a></span></dt><dt><span class="sect2"><a href="#d0e4507">6.5.4. Proxying classes</a></span></dt><dt><span class="sect2"><a href="#d0e4543">6.5.5. Using 'global' advisors</a></span></dt></dl></dd><dt><span class="sect1"><a href="#aop-tfb">6.6. Convenient proxy creation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e4561">6.6.1. TransactionProxyFactoryBean</a></span></dt><dt><span class="sect2"><a href="#d0e4642">6.6.2. EJB proxies</a></span></dt></dl></dd><dt><span class="sect1"><a href="#aop-concise-proxy">6.7. Concise proxy definitions</a></span></dt><dt><span class="sect1"><a href="#aop-prog">6.8. Creating AOP proxies programmatically with the ProxyFactory</a></span></dt><dt><span class="sect1"><a href="#d0e4708">6.9. Manipulating advised objects</a></span></dt><dt><span class="sect1"><a href="#aop-autoproxy">6.10. Using the "autoproxy" facility</a></span></dt><dd><dl><dt><span class="sect2"><a href="#aop-autoproxy-choices">6.10.1. Autoproxy bean definitions</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e4798">6.10.1.1. BeanNameAutoProxyCreator</a></span></dt><dt><span class="sect3"><a href="#d0e4821">6.10.1.2. DefaultAdvisorAutoProxyCreator</a></span></dt><dt><span class="sect3"><a href="#d0e4869">6.10.1.3. AbstractAdvisorAutoProxyCreator</a></span></dt></dl></dd><dt><span class="sect2"><a href="#aop-autoproxy-metadata">6.10.2. Using metadata-driven auto-proxying</a></span></dt></dl></dd><dt><span class="sect1"><a href="#aop-targetsource">6.11. Using TargetSources</a></span></dt><dd><dl><dt><span class="sect2"><a href="#aop-ts-swap">6.11.1. Hot swappable target sources</a></span></dt><dt><span class="sect2"><a href="#aop-ts-pool">6.11.2. Pooling target sources</a></span></dt><dt><span class="sect2"><a href="#aop-ts-prototype">6.11.3. Prototype target sources</a></span></dt><dt><span class="sect2"><a href="#aop-ts-threadlocal">6.11.4. ThreadLocal target sources</a></span></dt></dl></dd><dt><span class="sect1"><a href="#aop-extensibility">6.12. Defining new Advice types</a></span></dt><dt><span class="sect1"><a href="#d0e5144">6.13. Further reading and resources</a></span></dt></dl></dd><dt><span class="chapter"><a href="#aspectj">7. AspectJ Integration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e5169">7.1. Overview</a></span></dt><dt><span class="sect1"><a href="#d0e5176">7.2. Configuring AspectJ aspects using Spring IoC</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5198">7.2.1. "Singleton" aspects</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e5208">7.2.1.1. Example</a></span></dt><dt><span class="sect3"><a href="#d0e5246">7.2.1.2. Ordering issues</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e5251">7.2.2. Non-singleton aspects</a></span></dt><dt><span class="sect2"><a href="#d0e5256">7.2.3. Gotchas</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e5263">7.3. Using AspectJ pointcuts to target Spring advice</a></span></dt><dt><span class="sect1"><a href="#d0e5270">7.4. Spring aspects for AspectJ</a></span></dt></dl></dd><dt><span class="chapter"><a href="#transaction">8. Transaction management</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e5280">8.1. The Spring transaction abstraction</a></span></dt><dt><span class="sect1"><a href="#d0e5337">8.2. Transaction strategies</a></span></dt><dt><span class="sect1"><a href="#d0e5480">8.3. Resource synchronization with transactions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5500">8.3.1. High-level approach</a></span></dt><dt><span class="sect2"><a href="#d0e5517">8.3.2. Low-level approach</a></span></dt><dt><span class="sect2"><a href="#d0e5564">8.3.3. TransactionAwareDataSourceProxy</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e5591">8.4. Programmatic transaction management</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5615">8.4.1. Using the <code class="literal">TransactionTemplate</code></a></span></dt><dt><span class="sect2"><a href="#d0e5671">8.4.2. Using the <code class="literal">PlatformTransactionManager</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e5690">8.5. Declarative transaction management</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e5910">8.5.1. Source Annotations for Transaction Demarcation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e5917">8.5.1.1. The <code class="literal">Transactional</code> Annotation</a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e6107">8.5.2. BeanNameAutoProxyCreator,
      another declarative approach</a></span></dt><dt><span class="sect2"><a href="#d0e6201">8.5.3. AOP and Transactions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e6206">8.6. Choosing between programmatic and declarative transaction
    management</a></span></dt><dt><span class="sect1"><a href="#d0e6213">8.7. Do you need an application server for transaction
    management?</a></span></dt><dt><span class="sect1"><a href="#d0e6230">8.8. AppServer-specific integration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e6250">8.8.1. BEA WebLogic</a></span></dt><dt><span class="sect2"><a href="#d0e6266">8.8.2. IBM WebSphere</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e6290">8.9. Common problems</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e6293">8.9.1. Use of the wrong transaction manager for a specific
      DataSource</a></span></dt><dt><span class="sect2"><a href="#d0e6312">8.9.2. Spurious AppServer warnings about the transaction or DataSource
      no longer being active</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#metadata">9. Source Level Metadata Support</a></span></dt><dd><dl><dt><span class="sect1"><a href="#metadata-concepts">9.1. Source-level metadata</a></span></dt><dt><span class="sect1"><a href="#metadata-spring">9.2. Spring's metadata support</a></span></dt><dt><span class="sect1"><a href="#metadata-commons">9.3. Integration with Jakarta Commons Attributes</a></span></dt><dt><span class="sect1"><a href="#metadata-uses">9.4. Metadata and Spring AOP autoproxying</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e6526">9.4.1. Fundamentals</a></span></dt><dt><span class="sect2"><a href="#metadata-tx">9.4.2. Declarative transaction management</a></span></dt><dt><span class="sect2"><a href="#metadata-pool">9.4.3. Pooling</a></span></dt><dt><span class="sect2"><a href="#metadata-arbitrary">9.4.4. Custom metadata</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e6619">9.5. Using attributes to minimize MVC web tier configuration</a></span></dt><dt><span class="sect1"><a href="#d0e6729">9.6. Other uses of metadata attributes</a></span></dt><dt><span class="sect1"><a href="#d0e6734">9.7. Adding support for additional metadata APIs</a></span></dt></dl></dd><dt><span class="chapter"><a href="#dao">10. DAO support</a></span></dt><dd><dl><dt><span class="sect1"><a href="#dao-introduction">10.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#dao-exceptions">10.2. Consistent Exception Hierarchy</a></span></dt><dt><span class="sect1"><a href="#d0e6784">10.3. Consistent Abstract Classes for DAO Support</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jdbc">11. Data Access using JDBC</a></span></dt><dd><dl><dt><span class="sect1"><a href="#jdbc-introduction">11.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#jdbc-core">11.2. Using the JDBC Core classes to control basic JDBC processing and
    error handling</a></span></dt><dd><dl><dt><span class="sect2"><a href="#jdbc-JdbcTemplate">11.2.1. JdbcTemplate</a></span></dt><dt><span class="sect2"><a href="#d0e6886">11.2.2. DataSource</a></span></dt><dt><span class="sect2"><a href="#jdbc-SQLExceptionTranslator">11.2.3. SQLExceptionTranslator</a></span></dt><dt><span class="sect2"><a href="#d0e6977">11.2.4. Executing Statements</a></span></dt><dt><span class="sect2"><a href="#d0e6993">11.2.5. Running Queries</a></span></dt><dt><span class="sect2"><a href="#d0e7035">11.2.6. Updating the database</a></span></dt></dl></dd><dt><span class="sect1"><a href="#jdbc-datasource">11.3. Controlling how we connect to the database</a></span></dt><dd><dl><dt><span class="sect2"><a href="#jdbc-DataSourceUtils">11.3.1. DataSourceUtils</a></span></dt><dt><span class="sect2"><a href="#jdbc-SmartDataSource">11.3.2. SmartDataSource</a></span></dt><dt><span class="sect2"><a href="#jdbc-AbstractDataSource">11.3.3. AbstractDataSource</a></span></dt><dt><span class="sect2"><a href="#jdbc-SingleConnectionDataSource">11.3.4. SingleConnectionDataSource</a></span></dt><dt><span class="sect2"><a href="#jdbc-DriverManagerDataSource">11.3.5. DriverManagerDataSource</a></span></dt><dt><span class="sect2"><a href="#jdbc-TransactionAwareDataSourceProxy">11.3.6. TransactionAwareDataSourceProxy</a></span></dt><dt><span class="sect2"><a href="#jdbc-DataSourceTransactionManager">11.3.7. DataSourceTransactionManager</a></span></dt></dl></dd><dt><span class="sect1"><a href="#jdbc-object">11.4. Modeling JDBC operations as Java objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#jdbc-SqlQuery">11.4.1. SqlQuery</a></span></dt><dt><span class="sect2"><a href="#jdbc-MappingSqlQuery">11.4.2. MappingSqlQuery</a></span></dt><dt><span class="sect2"><a href="#jdbc-SqlUpdate">11.4.3. SqlUpdate</a></span></dt><dt><span class="sect2"><a href="#jdbc-StoredProcedure">11.4.4. StoredProcedure</a></span></dt><dt><span class="sect2"><a href="#jdbc-SqlFunction">11.4.5. SqlFunction</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#orm">12. Data Access using O/R Mappers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#orm-introduction">12.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#orm-hibernate">12.2. Hibernate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7437">12.2.1. Resource management</a></span></dt><dt><span class="sect2"><a href="#d0e7468">12.2.2. SessionFactory setup in a Spring application context</a></span></dt><dt><span class="sect2"><a href="#d0e7496">12.2.3. Inversion of Control: HibernateTemplate and
      HibernateCallback</a></span></dt><dt><span class="sect2"><a href="#d0e7542">12.2.4. Implementing Spring-based DAOs without callbacks</a></span></dt><dt><span class="sect2"><a href="#d0e7576">12.2.5. Implementing DAOs based on plain Hibernate3 API</a></span></dt><dt><span class="sect2"><a href="#d0e7641">12.2.6. Programmatic transaction demarcation</a></span></dt><dt><span class="sect2"><a href="#d0e7662">12.2.7. Declarative transaction demarcation</a></span></dt><dt><span class="sect2"><a href="#d0e7696">12.2.8. Transaction management strategies</a></span></dt><dt><span class="sect2"><a href="#d0e7751">12.2.9. Container resources versus local resources</a></span></dt><dt><span class="sect2"><a href="#orm-hibernate-invalid-jdbc-access-error">12.2.10. Spurious AppServer warnings about the transaction or DataSource
      no longer being active</a></span></dt></dl></dd><dt><span class="sect1"><a href="#orm-jdo">12.3. JDO</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e7895">12.3.1. PersistenceManagerFactory setup</a></span></dt><dt><span class="sect2"><a href="#d0e7942">12.3.2. JdoTemplate and JdoDaoSupport</a></span></dt><dt><span class="sect2"><a href="#d0e8015">12.3.3. Implementing DAOs based on plain JDO API</a></span></dt><dt><span class="sect2"><a href="#d0e8100">12.3.4. Transaction management</a></span></dt><dt><span class="sect2"><a href="#d0e8138">12.3.5. JdoDialect</a></span></dt></dl></dd><dt><span class="sect1"><a href="#orm-toplink">12.4. Oracle TopLink</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e8216">12.4.1. SessionFactory abstraction</a></span></dt><dt><span class="sect2"><a href="#d0e8272">12.4.2. TopLinkTemplate and TopLinkDaoSupport</a></span></dt><dt><span class="sect2"><a href="#d0e8350">12.4.3. Implementing DAOs based on plain TopLink API</a></span></dt><dt><span class="sect2"><a href="#d0e8453">12.4.4. Transaction management</a></span></dt></dl></dd><dt><span class="sect1"><a href="#orm-ojb">12.5. Apache OJB</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e8518">12.5.1. OJB setup in a Spring environment</a></span></dt><dt><span class="sect2"><a href="#d0e8542">12.5.2. PersistenceBrokerTemplate and PersistenceBrokerDaoSupport</a></span></dt><dt><span class="sect2"><a href="#d0e8606">12.5.3. Transaction management</a></span></dt></dl></dd><dt><span class="sect1"><a href="#orm-ibatis">12.6. iBATIS SQL Maps</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e8653">12.6.1. Overview and differences between iBATIS 1.x and 2.x</a></span></dt><dt><span class="sect2"><a href="#d0e8712">12.6.2. iBATIS SQL Maps 1.x</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e8715">12.6.2.1. Setting up the SqlMap</a></span></dt><dt><span class="sect3"><a href="#d0e8755">12.6.2.2. Using <code class="literal">SqlMapTemplate</code> and
        <code class="literal">SqlMapDaoSupport</code></a></span></dt></dl></dd><dt><span class="sect2"><a href="#d0e8811">12.6.3. iBATIS SQL Maps 2.x</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e8814">12.6.3.1. Setting up the SqlMapClient</a></span></dt><dt><span class="sect3"><a href="#d0e8847">12.6.3.2. Using <code class="literal">SqlMapClientTemplate</code> and
        <code class="literal">SqlMapClientDaoSupport</code></a></span></dt><dt><span class="sect3"><a href="#d0e8914">12.6.3.3. Implementing DAOs based on plain iBATIS API</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="chapter"><a href="#mvc">13. Web MVC framework</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mvc-introduction">13.1. Introduction to the web MVC framework</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mvc-introduction-pluggability">13.1.1. Pluggability of other MVC implementations</a></span></dt><dt><span class="sect2"><a href="#mvc-features">13.1.2. Features of Spring MVC</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mvc-servlet">13.2. The <code class="literal">DispatcherServlet</code></a></span></dt><dt><span class="sect1"><a href="#mvc-controller">13.3. Controllers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mvc-controller-abstractcontroller">13.3.1. AbstractController and WebContentGenerator</a></span></dt><dt><span class="sect2"><a href="#mvc-controller-othersimplecontrollers">13.3.2. Other simple controllers</a></span></dt><dt><span class="sect2"><a href="#mvc-controller-multiaction">13.3.3. The <code class="literal">MultiActionController</code></a></span></dt><dt><span class="sect2"><a href="#mvc-controller-command">13.3.4. CommandControllers</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mvc-handlermapping">13.4. Handler mappings</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mvc-handlermapping-beanname">13.4.1. <code class="literal">BeanNameUrlHandlerMapping</code></a></span></dt><dt><span class="sect2"><a href="#mvc-handlermapping-urlhandlermapping">13.4.2. <code class="literal">SimpleUrlHandlerMapping</code></a></span></dt><dt><span class="sect2"><a href="#mvc-handlermapping-interceptor">13.4.3. Adding <code class="literal">HandlerInterceptors</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#mvc-viewresolver">13.5. Views and resolving them</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mvc-viewresolver-resolver">13.5.1. ViewResolvers</a></span></dt><dt><span class="sect2"><a href="#mvc-viewresolver-chaining">13.5.2. Chaining ViewResolvers</a></span></dt><dt><span class="sect2"><a href="#d0e9984">13.5.3. Redirecting to views</a></span></dt><dd><dl><dt><span class="sect3"><a href="#d0e10003">13.5.3.1. <code class="literal">RedirectView</code></a></span></dt><dt><span class="sect3"><a href="#d0e10025">13.5.3.2. The <code class="literal">redirect:</code> prefix</a></span></dt><dt><span class="sect3"><a href="#d0e10055">13.5.3.3. The <code class="literal">forward:</code> prefix</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#mvc-localeresolver">13.6. Using locales</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mvc-localeresolver-acceptheader">13.6.1. <code class="literal">AcceptHeaderLocaleResolver</code></a></span></dt><dt><span class="sect2"><a href="#mvc-localeresolver-cookie">13.6.2. <code class="literal">CookieLocaleResolver</code></a></span></dt><dt><span class="sect2"><a href="#mvc-localeresolver-session">13.6.3. <code class="literal">SessionLocaleResolver</code></a></span></dt><dt><span class="sect2"><a href="#mvc-localeresolver-interceptor">13.6.4. <code class="literal">LocaleChangeInterceptor</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#mvc-themeresolver">13.7. Using themes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mvc-themeresolver-introduction">13.7.1. Introduction</a></span></dt><dt><span class="sect2"><a href="#mvc-themeresolver-defining">13.7.2. Defining themes</a></span></dt><dt><span class="sect2"><a href="#mvc-themeresolver-resolving">13.7.3. Theme resolvers</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mvc-multipart">13.8. Spring's multipart (fileupload) support</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mvc-multipart-introduction">13.8.1. Introduction</a></span></dt><dt><span class="sect2"><a href="#mvc-multipart-resolver">13.8.2. Using the <code class="literal">MultipartResolver</code></a></span></dt><dt><span class="sect2"><a href="#mvc-multipart-forms">13.8.3. Handling a fileupload in a form</a></span></dt></dl></dd><dt><span class="sect1"><a href="#mvc-exceptionhandlers">13.9. Handling exceptions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#view">14. Integrating view technologies</a></span></dt><dd><dl><dt><span class="sect1"><a href="#view-introduction">14.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#view-jsp">14.2. JSP &amp; JSTL</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-jsp-resolver">14.2.1. View resolvers</a></span></dt><dt><span class="sect2"><a href="#view-jsp-jstl">14.2.2. 'Plain-old' JSPs versus JSTL</a></span></dt><dt><span class="sect2"><a href="#view-jsp-tags">14.2.3. Additional tags facilitating development</a></span></dt></dl></dd><dt><span class="sect1"><a href="#view-tiles">14.3. Tiles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-tiles-dependencies">14.3.1. Dependencies</a></span></dt><dt><span class="sect2"><a href="#view-tiles-integrate">14.3.2. How to integrate Tiles</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-tiles-internal">14.3.2.1. <code class="literal">InternalResourceViewResolver</code></a></span></dt><dt><span class="sect3"><a href="#view-tiles-resource">14.3.2.2. <code class="literal">ResourceBundleViewResolver</code></a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#view-velocity">14.4. Velocity &amp; FreeMarker</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-velocity-dependencies">14.4.1. Dependencies</a></span></dt><dt><span class="sect2"><a href="#view-velocity-contextconfig">14.4.2. Context configuration</a></span></dt><dt><span class="sect2"><a href="#view-velocity-createtemplates">14.4.3. Creating templates</a></span></dt><dt><span class="sect2"><a href="#view-velocity-advancedconfig">14.4.4. Advanced configuration</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-velocity-example-velocityproperties">14.4.4.1. velocity.properties</a></span></dt><dt><span class="sect3"><a href="#d0e10678">14.4.4.2. FreeMarker</a></span></dt></dl></dd><dt><span class="sect2"><a href="#view-velocity-forms">14.4.5. Bind support and form handling</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-velocity-validation">14.4.5.1. the bind macros</a></span></dt><dt><span class="sect3"><a href="#view-velocity-validationmessages">14.4.5.2. simple binding</a></span></dt><dt><span class="sect3"><a href="#d0e10793">14.4.5.3. form input generation macros</a></span></dt><dt><span class="sect3"><a href="#d0e11051">14.4.5.4. Overriding HTML escaping and making tags XHTML
        compliant</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#view-xslt">14.5. XSLT</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-xslt-firstwords">14.5.1. My First Words</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-xslt-beandefs">14.5.1.1. Bean definitions</a></span></dt><dt><span class="sect3"><a href="#view-xslt-controllercode">14.5.1.2. Standard MVC controller code</a></span></dt><dt><span class="sect3"><a href="#view-xslt-subclassing">14.5.1.3. Convert the model data to XML</a></span></dt><dt><span class="sect3"><a href="#view-xslt-viewdefinitions">14.5.1.4. Defining the view properties</a></span></dt><dt><span class="sect3"><a href="#view-xslt-transforming">14.5.1.5. Document transformation</a></span></dt></dl></dd><dt><span class="sect2"><a href="#view-xslt-summary">14.5.2. Summary</a></span></dt></dl></dd><dt><span class="sect1"><a href="#view-document">14.6. Document views (PDF/Excel)</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-document-intro">14.6.1. Introduction</a></span></dt><dt><span class="sect2"><a href="#view-document-config">14.6.2. Configuration and setup</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-document-configviews">14.6.2.1. Document view definitions</a></span></dt><dt><span class="sect3"><a href="#view-document-configcontroller">14.6.2.2. Controller code</a></span></dt><dt><span class="sect3"><a href="#view-document-configsubclasses">14.6.2.3. Subclassing for Excel views</a></span></dt><dt><span class="sect3"><a href="#view-document-configsubclasspdf">14.6.2.4. Subclassing for PDF views</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#view-jasper-reports">14.7. JasperReports</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-jasper-reports-dependencies">14.7.1. Dependencies</a></span></dt><dt><span class="sect2"><a href="#view-jasper-reports-configuration">14.7.2. Configuration</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-jasper-reports-configuration-resolver">14.7.2.1. Configuring the <code class="literal">ViewResolver</code></a></span></dt><dt><span class="sect3"><a href="#view-jasper-reports-configuration-views">14.7.2.2. Configuring the <code class="literal">View</code>s</a></span></dt><dt><span class="sect3"><a href="#view-jasper-reports-configuration-report-files">14.7.2.3. About Report Files</a></span></dt><dt><span class="sect3"><a href="#view-jasper-reports-configuration-multiformat-view">14.7.2.4. Using <code class="literal">JasperReportsMultiFormatView</code></a></span></dt></dl></dd><dt><span class="sect2"><a href="#view-jasper-reports-model">14.7.3. Populating the <code class="literal">ModelAndView</code></a></span></dt><dt><span class="sect2"><a href="#view-jasper-reports-subreports">14.7.4. Working with Sub-Reports</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-jasper-reports-subreports-config-reports">14.7.4.1. Configuring Sub-Report Files</a></span></dt><dt><span class="sect3"><a href="#view-jasper-reports-subreports-config-datasources">14.7.4.2. Configuring Sub-Report Data Sources</a></span></dt></dl></dd><dt><span class="sect2"><a href="#view-jasper-reports-exporter-parameters">14.7.5. Configuring Exporter Parameters</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#webintegration">15. Integrating with other web frameworks</a></span></dt><dd><dl><dt><span class="sect1"><a href="#intro">15.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#jsf">15.2. JavaServer Faces</a></span></dt><dd><dl><dt><span class="sect2"><a href="#jsf-delegatingvariableresolver">15.2.1. DelegatingVariableResolver</a></span></dt><dt><span class="sect2"><a href="#jsf-facescontextutils">15.2.2. FacesContextUtils</a></span></dt></dl></dd><dt><span class="sect1"><a href="#struts">15.3. Struts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#struts-contextloaderplugin">15.3.1. ContextLoaderPlugin</a></span></dt><dd><dl><dt><span class="sect3"><a href="#struts-delegatingrequestprocessor">15.3.1.1. DelegatingRequestProcessor</a></span></dt><dt><span class="sect3"><a href="#struts-delegatingactionproxy">15.3.1.2. DelegatingActionProxy</a></span></dt></dl></dd><dt><span class="sect2"><a href="#struts-actionsupport">15.3.2. ActionSupport Classes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#view-tapestry">15.4. Tapestry</a></span></dt><dd><dl><dt><span class="sect2"><a href="#view-tapestry-architecture">15.4.1. Architecture</a></span></dt><dt><span class="sect2"><a href="#view-tapestry-implementation">15.4.2. Implementation</a></span></dt><dd><dl><dt><span class="sect3"><a href="#view-tapestry-context">15.4.2.1. Sample application context</a></span></dt><dt><span class="sect3"><a href="#view-tapestry-appctx">15.4.2.2. Obtaining beans in Tapestry pages</a></span></dt><dt><span class="sect3"><a href="#view-tapestry-exposeappctx">15.4.2.3. Exposing the application context to Tapestry</a></span></dt><dt><span class="sect3"><a href="#view-tapestry-componentdefs">15.4.2.4. Component definition files</a></span></dt><dt><span class="sect3"><a href="#view-tapestry-getters">15.4.2.5. Adding abstract accessors</a></span></dt></dl></dd><dt><span class="sect2"><a href="#view-tapestry-summary">15.4.3. Summary</a></span></dt></dl></dd><dt><span class="sect1"><a href="#webwork">15.5. WebWork</a></span></dt></dl></dd><dt><span class="chapter"><a href="#remoting">16. Remoting and web services using Spring</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e12311">16.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#d0e12394">16.2. Exposing services using RMI</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e12399">16.2.1. Exporting the service using the <code class="literal">RmiServiceExporter</code></a></span></dt><dt><span class="sect2"><a href="#d0e12439">16.2.2. Linking in the service at the client</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e12452">16.3. Using Hessian or Burlap to remotely call services via HTTP</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e12459">16.3.1. Wiring up the DispatcherServlet for Hessian</a></span></dt><dt><span class="sect2"><a href="#d0e12478">16.3.2. Exposing your beans by using the HessianServiceExporter</a></span></dt><dt><span class="sect2"><a href="#d0e12492">16.3.3. Linking in the service on the client</a></span></dt><dt><span class="sect2"><a href="#d0e12503">16.3.4. Using Burlap</a></span></dt><dt><span class="sect2"><a href="#d0e12514">16.3.5. Applying HTTP basic authentication to a service exposed through Hessian or Burlap</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e12536">16.4. Exposing services using HTTP invokers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e12546">16.4.1. Exposing the service object</a></span></dt><dt><span class="sect2"><a href="#d0e12563">16.4.2. Linking in the service at the client</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e12579">16.5. Web Services</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e12595">16.5.1. Exposing services using JAX-RPC</a></span></dt><dt><span class="sect2"><a href="#d0e12606">16.5.2. Accessing Web Services</a></span></dt><dt><span class="sect2"><a href="#d0e12666">16.5.3. Register Bean Mappings</a></span></dt><dt><span class="sect2"><a href="#d0e12678">16.5.4. Registering our own Handler</a></span></dt><dt><span class="sect2"><a href="#d0e12707">16.5.5. Exposing web services using XFire</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e12738">16.6. Auto-detection is not implemented for remote interfaces</a></span></dt><dt><span class="sect1"><a href="#d0e12750">16.7. Considerations when choosing a technology</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ejb">17. Accessing and implementing EJBs</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ejb-access">17.1. Accessing EJBs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ejb-access-concepts">17.1.1. Concepts</a></span></dt><dt><span class="sect2"><a href="#ejb-access-local">17.1.2. Accessing local SLSBs</a></span></dt><dt><span class="sect2"><a href="#ejb-access-remote">17.1.3. Accessing remote SLSBs</a></span></dt></dl></dd><dt><span class="sect1"><a href="#ejb-implementation">17.2. Using Spring convenience EJB implementation classes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#jms">18. JMS</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e12980">18.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#d0e13014">18.2. Domain unification</a></span></dt><dt><span class="sect1"><a href="#d0e13024">18.3. JmsTemplate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13058">18.3.1. ConnectionFactory</a></span></dt><dt><span class="sect2"><a href="#d0e13085">18.3.2. Transaction Management</a></span></dt><dt><span class="sect2"><a href="#d0e13128">18.3.3. Destination Management</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e13184">18.4. Using the JmsTemplate</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e13195">18.4.1. Sending a message</a></span></dt><dt><span class="sect2"><a href="#d0e13240">18.4.2. Synchronous Receiving</a></span></dt><dt><span class="sect2"><a href="#d0e13251">18.4.3. Using Message Converters</a></span></dt><dt><span class="sect2"><a href="#d0e13311">18.4.4. SessionCallback and ProducerCallback</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#jmx">19. JMX Support</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx-introduction">19.1. Introduction</a></span></dt><dt><span class="section"><a href="#jmx-exporting">19.2. Exporting your Beans to JMX</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx-exporting-mbeanserver">19.2.1. Creating an MBeanServer</a></span></dt><dt><span class="section"><a href="#jmx-exporting-lazy">19.2.2. Lazy-Initialized MBeans</a></span></dt><dt><span class="section"><a href="#jmx-exporting-auto">19.2.3. Automatic Registration of MBeans</a></span></dt></dl></dd><dt><span class="section"><a href="#jmx-interface">19.3. Controlling the Management Interface of Your Beans</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx-interface-assembler">19.3.1. The <code class="literal">MBeanInfoAssembler</code> Interface</a></span></dt><dt><span class="section"><a href="#jmx-interface-metadata">19.3.2. Using Source-Level Metadata</a></span></dt><dt><span class="section"><a href="#jmx-interface-annotations">19.3.3. Using JDK 5.0 Annotations</a></span></dt><dt><span class="section"><a href="#jmx-interface-metadata-types">19.3.4. Source-Level Metadata Types</a></span></dt><dt><span class="section"><a href="#jmx-interface-autodetect">19.3.5. The <code class="literal">AutodetectCapableMBeanInfoAssembler</code>
      Interface</a></span></dt><dt><span class="section"><a href="#jmx-interface-java">19.3.6. Defining Management Interfaces using Java Interfaces</a></span></dt><dt><span class="section"><a href="#jmx-interface-methodnames">19.3.7. Using
      <code class="literal">MethodNameBasedMBeanInfoAssembler</code>
			</a></span></dt></dl></dd><dt><span class="section"><a href="#jmx-naming">19.4. Controlling the <code class="literal">ObjectName</code>s for your
    Beans</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx-naming-properties">19.4.1. Reading <code class="literal">ObjectName</code>s from
      <code class="literal">Properties</code>
			</a></span></dt><dt><span class="section"><a href="#jmx-naiming-metadata">19.4.2. Using the <code class="literal">MetadataNamingStrategy</code>
			</a></span></dt></dl></dd><dt><span class="section"><a href="#jmx-jsr160">19.5. Exporting your Beans with JSR-160 Connectors</a></span></dt><dd><dl><dt><span class="section"><a href="#jmx-jsr160-server">19.5.1. Server-side Connectors</a></span></dt><dt><span class="section"><a href="#jmx-jsr160-client">19.5.2. Client-side Connectors</a></span></dt><dt><span class="section"><a href="#jmx-jsr160-protocols">19.5.3. JMX over Burlap/Hessian/SOAP</a></span></dt></dl></dd><dt><span class="section"><a href="#jmx-proxy">19.6. Accessing MBeans via Proxies</a></span></dt></dl></dd><dt><span class="chapter"><a href="#cci">20. JCA CCI</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e14464">20.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#d0e14482">20.2. Configuring CCI</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e14485">20.2.1. Connector configuration</a></span></dt><dt><span class="sect2"><a href="#d0e14524">20.2.2. ConnectionFactory configuration in Spring</a></span></dt><dt><span class="sect2"><a href="#d0e14559">20.2.3. Configuring CCI connections</a></span></dt><dt><span class="sect2"><a href="#d0e14608">20.2.4. Using a single CCI connection</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e14643">20.3. Using Spring's CCI access support</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e14646">20.3.1. Record conversion</a></span></dt><dt><span class="sect2"><a href="#d0e14700">20.3.2. CciTemplate</a></span></dt><dt><span class="sect2"><a href="#d0e14807">20.3.3. DAO support</a></span></dt><dt><span class="sect2"><a href="#automatic-output-generation">20.3.4. Automatic output record generation</a></span></dt><dt><span class="sect2"><a href="#template-summary">20.3.5. Summary</a></span></dt><dt><span class="sect2"><a href="#d0e14973">20.3.6. Using a CCI Connection and Interaction directly</a></span></dt><dt><span class="sect2"><a href="#d0e15025">20.3.7. Example for CciTemplate usage</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e15082">20.4. Modeling CCI access as operation objects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e15103">20.4.1. MappingRecordOperation</a></span></dt><dt><span class="sect2"><a href="#d0e15155">20.4.2. MappingCommAreaOperation</a></span></dt><dt><span class="sect2"><a href="#d0e15171">20.4.3. Automatic output record generation</a></span></dt><dt><span class="sect2"><a href="#d0e15188">20.4.4. Summary</a></span></dt><dt><span class="sect2"><a href="#d0e15223">20.4.5. Example for MappingRecordOperation usage</a></span></dt><dt><span class="sect2"><a href="#d0e15257">20.4.6. Example for MappingCommAreaOperation usage</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e15290">20.5. Transactions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mail">21. Sending Email with Spring mail abstraction layer</a></span></dt><dd><dl><dt><span class="sect1"><a href="#mail-introduction">21.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#mail-structure">21.2. Spring mail abstraction structure</a></span></dt><dt><span class="sect1"><a href="#mail-usage">21.3. Using Spring mail abstraction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e15449">21.3.1. Pluggable MailSender implementations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e15460">21.4. Using the JavaMail MimeMessageHelper</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e15471">21.4.1. Creating a simple MimeMessage and sending it</a></span></dt><dt><span class="sect2"><a href="#d0e15479">21.4.2. Sending attachments and inline resources</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#scheduling">22. Scheduling jobs using Quartz or Timer</a></span></dt><dd><dl><dt><span class="sect1"><a href="#d0e15496">22.1. Introduction</a></span></dt><dt><span class="sect1"><a href="#d0e15506">22.2. Using the OpenSymphony Quartz Scheduler</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e15522">22.2.1. Using the JobDetailBean</a></span></dt><dt><span class="sect2"><a href="#d0e15559">22.2.2. Using the MethodInvokingJobDetailFactoryBean</a></span></dt><dt><span class="sect2"><a href="#d0e15596">22.2.3. Wiring up jobs using triggers and the SchedulerFactoryBean</a></span></dt></dl></dd><dt><span class="sect1"><a href="#d0e15622">22.3. Using JDK Timer support</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e15629">22.3.1. Creating custom timers</a></span></dt><dt><span class="sect2"><a href="#d0e15651">22.3.2. Using the MethodInvokingTimerTaskFactoryBean</a></span></dt><dt><span class="sect2"><a href="#d0e15671">22.3.3. Wrapping up: setting up the tasks using the TimerFactoryBean</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#testing">23. Testing</a></span></dt><dd><dl><dt><span class="sect1"><a href="#unit-testing">23.1. Unit testing</a></span></dt><dt><span class="sect1"><a href="#integration-testing">23.2. Integration testing</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e15738">23.2.1. Context management and caching</a></span></dt><dt><span class="sect2"><a href="#d0e15766">23.2.2. Dependency Injection of test class instances</a></span></dt><dt><span class="sect2"><a href="#d0e15799">23.2.3. Transaction management</a></span></dt><dt><span class="sect2"><a href="#d0e15851">23.2.4. Convenience variables</a></span></dt><dt><span class="sect2"><a href="#d0e15881">23.2.5. Example</a></span></dt><dt><span class="sect2"><a href="#d0e15960">23.2.6. Running integration tests</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#springbeansdtd">A. <code class="literal">spring-beans.dtd</code></a></span></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div></div><p>
        Developing software applications is hard enough even with good tools and 
        technologies. Implementing applications using platforms which promise 
        everything but turn out to be heavy-weight,
        hard to control and not very efficient during the development cycle makes
        it even harder. Spring provides a light-weight solution for 
        building enterprise-ready applications, while still supporting the
		possibility of using declarative transaction management, remote access to
		your logic using RMI or webservices, mailing facilities and various options
		in persisting your data to a database. Spring provides an MVC framework,
        transparent ways of integrating AOP into your software and a 
        well-structured exception hierarchy including automatic mapping from 
		proprietary exception hierarchies.
    </p><p>
        Spring could potentially be a one-stop-shop for all your enterprise
        applications, however, Spring is modular, allowing you to use
        parts of it, without having to bring in the rest. You can use
        the bean container, with Struts on top, but you could also choose to just
        use the Hibernate integration or the JDBC abstraction layer.
        Spring is non-intrusive, meaning dependencies on the framework are 
		generally none or absolutely minimal, depending on the area of use..
    </p><p>
        This document provides a reference guide to Spring's features.
        Since this document is still a work-in-progress, if you have any
        requests or comments, please post them on the user mailing list or
		on the forum at the SourceForge project page:
        <a href="http://www.sf.net/projects/springframework" target="_top">http://www.sf.net/projects/springframework</a> 
    </p><p>
        Before we go on, a few words of gratitude: Chris Bauer (of the
        Hibernate team) prepared and adapted the DocBook-XSL software in
		order  to be able to create Hibernate's reference guide, also allowing
        us to create this one. Also thanks to Russell Healy for doing an extensive
        and valuable review of some of the material.
    </p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction-overview"></a>1.1.&nbsp;Overview</h2></div></div></div><p>
			Spring contains a lot of functionality and features, which are
			well-organized in seven modules shown in the diagram below.
			This section discusses each the of modules in turn.
		</p><p>
			</p><div class="mediaobject" align="center"><img src="images/spring-overview.gif" align="middle"><div class="caption"><p>Overview of the the Spring Framework
					</p></div></div><p>
		</p><p>
			The <span class="emphasis"><em>Core</em></span> package is the most fundamental part of the framework and
			provides the Dependency Injection features allowing you to manage
			bean container functionality. The basic concept here is the 
			BeanFactory, which provides a factory pattern removing the need for
			programmatic singletons and allowing you to decouple the configuration
			and specification of dependencies from your actual program logic.  
		</p><p>
			On top of the <span class="emphasis"><em>Core</em></span> package sits the 
			<span class="emphasis"><em>Context</em></span> package,
			providing a way to access beans in a framework-style manner,
			somewhat resembling a JNDI-registry. The context package inherits
			its features from the beans package and adds support for text
			messaging using e.g. resource bundles, 
			event-propagation, resource-loading and transparent
			creation of contexts by, for example, a servlet container.
		</p><p>
			The <span class="emphasis"><em>DAO</em></span> package provides a JDBC-abstraction
			layer that removes the need to do tedious JDBC coding and parsing
			of database-vendor specific error codes.
			Also, the JDBC package provides a way to do 
			programmatic as well as declarative transaction
			management, not only for classes implementing special interfaces,
			but for <span class="emphasis"><em>all your POJOs (plain old java objects)</em></span>.
		</p><p>
			The <span class="emphasis"><em>ORM</em></span> package provides integration layers
			for popular object-relational mapping APIs, including JDO, Hibernate
			and iBatis. Using the ORM package you can use all those O/R-mappers
			in combination with all the other features Spring offers, like
			simple declarative transaction management mentioned before.
		</p><p>
			Spring's <span class="emphasis"><em>AOP</em></span> package provides an 
			<span class="emphasis"><em>AOP Alliance</em></span> compliant aspect-oriented
			programming implementation allowing you to define, for example,
			method-interceptors and pointcuts to cleanly decouple code
			implementing functionality that should logically speaking be separated.
			Using source-level metadata functionality you can 
			incorporate all kinds of behavioral information into your code,
			a little like .NET attributes.
		</p><p>
			Spring's <span class="emphasis"><em>Web</em></span> package provides basic 
			web-oriented integration features, such as multipart functionality,
			initialization of contexts using servlet listeners and 
			a web-oriented application context. When using
			Spring together with WebWork or Struts, this is the package to 
			integrate with.
		</p><p>
			Spring's <span class="emphasis"><em>Web MVC</em></span> package provides a 
			Model-View-Controller implementation for web-applications. 
			Spring's MVC implementation is not just any implementation,
			it provides a clean separation between domain model code and
			web forms and allows you to use all the other features of the Spring
			Framework like validation.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-usagescenarios"></a>1.2.&nbsp;Usage scenarios</h2></div></div></div><p>
			With the building blocks described above you can use Spring in all sorts
			of scenarios, from applets up to fully-fledged enterprise applications
			using Spring's transaction management functionality and Web framework.
		</p><p>			
			</p><div class="mediaobject" align="center"><img src="images/full.gif" align="middle"><div class="caption"><p>Typical full-fledged Spring web application
					</p></div></div><p>
		</p><p>
			A typical web application using most of Spring's features. Using
			<code class="literal">TransactionProxyFactoryBeans</code> the web application is fully transactional,
			just as it would be when using container managed transaction as provided by Enterprise
			JavaBeans. All your custom business logic can be implemented using simple POJOs, managed
			by Spring's Dependency Injection container. Additional services such as sending email and
			validation, independent of the web layer enable you to choose where to execute
			validation rules. Spring's ORM support is integrated with Hibernate, JDO and iBatis.  Using
			for example <code class="literal">HibernateDaoSupport</code>, you can re-use your existing Hibernate
			mappings. Form controllers seamlessly integrate the web-layer with the domain model, removing
			the need for <code class="literal">ActionForms</code> or other classes that transform
			HTTP parameters to values for your domain model.
		</p><p>
			</p><div class="mediaobject" align="center"><img src="images/thirdparty-web.gif" align="middle"><div class="caption"><p>Spring middle-tier using a third-party web framework
					</p></div></div><p>
		</p><p>
			Sometimes the current circumstances do not allow you to
			completely switch to a different framework. Spring does 
			<span class="emphasis"><em>not</em></span> force
			you to use everything within it; it's not an <span class="emphasis"><em>all-or-nothing</em></span>
			solution. Existing frontends using WebWork, Struts, Tapestry,
			or other UI frameworks can be integrated perfectly well with
			a Spring-based middle-tier,
			allowing you to use the transaction features that Spring
			offers. The only thing you need to do is wire up your business
			logic using an <code class="literal">ApplicationContext</code> and
			integrate your Web UI layer using a
			<code class="literal">WebApplicationContext</code>.
		
		</p><p>
			</p><div class="mediaobject" align="center"><img src="images/remoting.gif" align="middle"><div class="caption"><p>Remoting usage scenario
					</p></div></div><p>
		</p><p>			
			When you need to access existing code via webservices, you can use
			Spring's <code class="literal">Hessian-</code>,
			<code class="literal">Burlap-</code>, <code class="literal">Rmi-</code> or <code class="literal">JaxRpcProxyFactory</code> classes. Enabling remote access to existing application is all of a sudden not that hard anymore.
		</p><p>
			</p><div class="mediaobject" align="center"><img src="images/ejb.gif" align="middle"><div class="caption"><p>EJBs - Wrapping existing POJOs
					</p></div></div><p>
		</p><p>
			Spring also provides an access layer and abstraction layer for Enterprise JavaBeans,
			enabling you to reuse your existing POJOs and wrap them in Stateless Session Beans,
			for use in scalable failsafe web applications, that might need declarative security.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="background"></a>Chapter&nbsp;2.&nbsp;Background information</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="background-ioc"></a>2.1.&nbsp;Inversion of Control / Dependency Injection</h2></div></div></div><p>
    		In early 2004, Martin Fowler asked the readers of his site: when talking about Inversion 
    		of Control: <span class="emphasis"><em>"the question, is what aspect of control are they inverting?"</em></span>.
    		After talking about the term Inversion of Control Martin suggests renaming the 
    		pattern, or at least giving it a more self-explanatory name, and starts to use the
    		term <span class="emphasis"><em>Dependency Injection</em></span>. His article continues to explain some of 
    		the ideas behind Inversion of Control or Dependency Injection. If you need a decent
    		insight: <a href="http://martinfowler.com/articles/injection.html" target="_top">http://martinfowler.com/articles/injection.html</a>.
			</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="beans"></a>Chapter&nbsp;3.&nbsp;Beans, BeanFactory and the ApplicationContext</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-introduction"></a>3.1.&nbsp;Introduction</h2></div></div></div><p>Two of the most fundamental and important packages in Spring are the
    <code class="literal">org.springframework.beans</code> and
    <code class="literal">org.springframework.context</code> packages. Code in these
    packages provides the basis for Spring's <span class="emphasis"><em>Inversion of
    Control</em></span> (alternately called <span class="emphasis"><em>Dependency
    Injection</em></span>) features. The <code class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html" target="_top">BeanFactory</a></code>
    provides an advanced configuration mechanism capable of managing beans
    (objects) of any nature, using potentially any kind of storage facility.
    The <a href="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html" target="_top">ApplicationContext</a>
    builds on top of the BeanFactory (it's a subclass) and adds other
    functionality such as easier integration with Springs AOP features,
    message resource handling (for use in internationalization), event
    propagation, declarative mechanisms to create the ApplicationContext and
    optional parent contexts, and application-layer specific contexts such as
    the <code class="literal">WebApplicationContext</code>, among other
    enhancements.</p><p>In short, the <code class="literal">BeanFactory</code> provides the
    configuration framework and basic functionality, while the
    <code class="literal">ApplicationContext</code> adds enhanced capabilities to it,
    some of them perhaps more J2EE and enterprise-centric. In general, an
    ApplicationContext is a complete superset of a BeanFactory, and any
    description of BeanFactory capabilities and behavior should be considered
    to apply to ApplicationContexts as well.</p><p>Users are sometimes unsure whether a BeanFactory or an
    ApplicationContext are best suited for use in a particular situation.
    Normally when building most applications in a J2EE-environment,
    <span class="emphasis"><em>the best option is to use the ApplicationContext</em></span>,
    since it offers all the features of the BeanFactory and adds on to it in
    terms of features, while also allowing a more declarative approach to use
    of some functionality, which is generally desirable. The main usage
    scenario when you might prefer to use the BeanFactory is when memory usage
    is the greatest concern (such as in an applet where every last kilobyte
    counts), and you don't need all the features of the
    ApplicationContext.</p><p>This chapter covers material related to both the BeanFactory and the
    ApplicationContext. When mention is made only of the BeanFactory, you may
    always assume the text also applies to the ApplicationContext. When
    functionality is only available in the ApplicationContext, explicit
    mention is made of this.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-basics"></a>3.2.&nbsp;BeanFactory and BeanDefinitions - the basics</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory"></a>3.2.1.&nbsp;The BeanFactory</h3></div></div></div><p>The <code class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/BeanFactory.html" target="_top">BeanFactory</a></code>
      is the actual <span class="emphasis"><em>container</em></span> which instantiates,
      configures, and manages a number of beans. These beans typically
      collaborate with one another, and thus have dependencies between
      themselves. These dependencies are reflected in the configuration data
      used by the BeanFactory (although some dependencies may not be visible
      as configuration data, but rather be a function of programmatic
      interactions between beans at runtime).</p><p>A BeanFactory is represented by the interface
      <code class="literal">org.springframework.beans.factory.BeanFactory</code>, for
      which there are multiple implementations. The most commonly used simple
      BeanFactory implementation is
      <code class="literal">org.springframework.beans.factory.xml.XmlBeanFactory</code>.
      (This should be qualified with the reminder that ApplicationContexts are
      a subclass of BeanFactory, and most users end up using XML variants of
      ApplicationContext).</p><p>Although for most scenarios, almost all user code managed by the
      BeanFactory does not have to be aware of the BeanFactory, the
      BeanFactory does have to be instantiated somehow. This can happen via
      explicit user code such as:</p><pre class="programlisting">Resource res = new FileSystemResource("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(res);</pre><p>or</p><pre class="programlisting">ClassPathResource res = new ClassPathResource("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(res);</pre><p>or</p><pre class="programlisting">ClassPathXmlApplicationContext appContext = new ClassPathXmlApplicationContext(
        new String[] {"applicationContext.xml", "applicationContext-part2.xml"});
// of course, an ApplicationContext is just a BeanFactory
BeanFactory factory = (BeanFactory) appContext;</pre><p>Note: once you have learned the basics about bean factories and
      applicaiton contexts, from this chapter, it will also be useful to learn
      about Spring's <code class="literal">Resource</code> abstraction, as described in
      <a href="#resources" title="Chapter&nbsp;4.&nbsp;Abstracting Access to Low-Level Resources">Chapter&nbsp;4, <i>Abstracting Access to Low-Level Resources</i></a>. The location path or paths supplied to an
      ApplicationContext constructor are actually resource strings, and in
      simple form are treated appropriately to the specific context
      implementation (i.e. ClassPathXmlApplicationContext treats a simple
      location path as a classpath location), but may also be used with
      special prefixes to force loading of definitions from the classpath or a
      URL, regardless of the actual context type. Another special prefix,
      <code class="literal">classpath*:</code>, allows all context definiton files of
      the same name on the classpath to be found and combined to build a
      context. Please see the chapter referenced above for much more
      information on the topic of <code class="literal">Resource</code>s.</p><p>For many usage scenarios, user code will not have to instantiate
      the BeanFactory or ApplicationContext, since Spring Framework code will
      do it. For example, the web layer provides support code to load a Spring
      ApplicationContext automatically as part of the normal startup process
      of a J2EE web-app. This declarative process is described <a href="#context-create" title="3.19.&nbsp;Creating an ApplicationContext from a web application">here</a>:</p><p>While programmatic manipulation of BeanFactories will be described
      later, the following sections will concentrate on describing the
      configuration of BeanFactories.</p><p>A BeanFactory configuration consists of, at its most basic level,
      definitions of one or more beans that the BeanFactory must manage. In an
      XmlBeanFactory, these are configured as one or more
      <code class="literal">bean</code> elements inside a top-level
      <code class="literal">beans</code> element.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd"&gt;

&lt;beans&gt;
  
  &lt;bean id="..." class="..."&gt;
    ...
  &lt;/bean&gt;
  &lt;bean id="..." class="..."&gt;
    ...
  &lt;/bean&gt;

  ...

&lt;/beans&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-definition"></a>3.2.2.&nbsp;The BeanDefinition</h3></div></div></div><p>Bean definitions inside a DefaultListableBeanFactory variant (like
      XmlBeanFactory) are represented as BeanDefinition objects, which contain
      (among other information) the following details: </p><div class="itemizedlist"><ul type="disc" compact><li><p>a class name: this is normally the actual implementation
            class of the bean being described in the bean definition. However,
            if the bean is to be constructed by calling a static
            <span class="emphasis"><em>factory</em></span> method instead of using a normal
            constructor, this will actually be the class name of the factory
            class.</p></li><li><p>bean behavioral configuration elements, which state how the
            bean should behave in the container (i.e. prototype or singleton,
            autowiring mode, dependency checking mode, initialization and
            destruction methods)</p></li><li><p>constructor arguments and property values to set in the
            newly created bean. An example would be the number of connections
            to use in a bean that manages a connection pool (either specified
            as a property or as a constructor argument), or the pool size
            limit.</p></li><li><p>other beans a bean needs to do its work, i.e.
            <span class="emphasis"><em>collaborators</em></span> (also specified as properties
            or as constructor arguments). These can also be called
            dependencies.</p></li></ul></div><p>The concepts listed above directly translate to a set of elements
      the bean definition consists of. Some of these element groups are listed
      below, along with a link to further documentation about each of them.
      </p><div class="table"><a name="d0e390"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;Bean definition explanation</b></p><div class="table-contents"><table summary="Bean definition explanation" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>More info</th></tr></thead><tbody><tr><td>class</td><td><a href="#beans-factory-class" title="3.2.3.&nbsp;The bean class">Section&nbsp;3.2.3, &#8220;The bean class&#8221;</a></td></tr><tr><td>id and name</td><td><a href="#beans-beanname" title="3.2.4.&nbsp;The bean identifiers (id and&#xA;      name)">Section&nbsp;3.2.4, &#8220;The bean identifiers (<code class="literal">id</code> and
      <code class="literal">name</code>)&#8221;</a></td></tr><tr><td>singleton or prototype</td><td><a href="#beans-factory-modes" title="3.2.5.&nbsp;To singleton or not to singleton">Section&nbsp;3.2.5, &#8220;To singleton or not to singleton&#8221;</a></td></tr><tr><td>constructor arguments</td><td><a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Setting bean properties and collaborators">Section&nbsp;3.3.1, &#8220;Setting bean properties and collaborators&#8221;</a></td></tr><tr><td>bean properties</td><td><a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Setting bean properties and collaborators">Section&nbsp;3.3.1, &#8220;Setting bean properties and collaborators&#8221;</a></td></tr><tr><td>autowiring mode</td><td><a href="#beans-factory-autowire" title="3.3.6.&nbsp;Autowiring collaborators">Section&nbsp;3.3.6, &#8220;Autowiring collaborators&#8221;</a></td></tr><tr><td>dependency checking mode</td><td><a href="#beans-factory-dependencies" title="3.3.7.&nbsp;Checking for dependencies">Section&nbsp;3.3.7, &#8220;Checking for dependencies&#8221;</a></td></tr><tr><td>initialization method</td><td><a href="#beans-factory-lifecycle" title="3.4.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.4.1, &#8220;Lifecycle interfaces&#8221;</a></td></tr><tr><td>destruction method</td><td><a href="#beans-factory-lifecycle" title="3.4.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.4.1, &#8220;Lifecycle interfaces&#8221;</a></td></tr></tbody></table></div></div><p><br class="table-break"></p><p>Note that a bean definition is represented by the real interface
      <code class="literal">org.springframework.beans.factory.config.BeanDefinition</code>,
      and its various implementations (Root/ChildBeanDefinition). However, it
      is rare that user code works directly with BeanDefinition objects:
      Usually, bean definitions will be expressed in a metadata format (such
      as XML), which will be loaded on startup. The internal representation of
      such bean definitions are BeanDefinition objects in the factory.</p><p>Besides bean definitions which contain information on how to
      create a specific bean, a BeanFactory can also allow to register
      existing bean objects that have been created outside the factory (by
      custom code). DefaultListableBeanFactory supports this through the
      <code class="literal">registerSingleton</code> method, as defined by the
      <code class="literal">org.springframework.beans.factory.config.ConfigurableBeanFactory</code>
      interface. Typical applications solely work with beans defined through
      metadata bean definitions, though.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-class"></a>3.2.3.&nbsp;The bean class</h3></div></div></div><p>The <code class="literal">class</code> attribute is normally mandatory (see
      <a href="#beans-instance-factory-method" title="3.2.3.3.&nbsp;Bean creation via instance factory method">Section&nbsp;3.2.3.3, &#8220;Bean creation via instance factory method&#8221;</a> and <a href="#beans-child-bean-definitions" title="3.5.&nbsp;Abstract and child bean definitions">Section&nbsp;3.5, &#8220;Abstract and child bean definitions&#8221;</a> for the two exception) and is
      used for one of two purposes. In the much more common case where the
      BeanFactory itself directly creates the bean by calling its constructor
      (equivalent to Java code calling <span class="emphasis"><em>new</em></span>), the class
      attribute specifies the class of the bean to be constructed. In the less
      common case where the BeanFactory calls a static, so-called
      <span class="emphasis"><em>factory</em></span> method on a class to create the bean, the
      class attribute specifies the actual class containing the static factory
      method. (the type of the returned bean from the static factory method
      may be the same class or another class entirely, it doesn't
      matter).</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e479"></a>3.2.3.1.&nbsp;Bean creation via constructor</h4></div></div></div><p>When creating a bean using the constructor approach, all normal
        classes are usable by Spring and compatible with Spring. That is, the
        class being created does not need to implement any specific interfaces
        or be coded in a specific fashion. Just specifying the bean class
        should be enough. However, depending on what type of IoC you are going
        to use for that specific bean, you may need a default (empty)
        constructor.</p><p>Additionally, the BeanFactory isn't limited to just managing
        true JavaBeans, it is also able to manage virtually
        <span class="emphasis"><em>any</em></span> class you want it to manage. Most people
        using Spring prefer to have actual JavaBeans (having just a default
        (no-argument) constructor and appropriate setters and getters modeled
        after the properties) in the BeanFactory, but it it's also possible to
        have more exotic non-bean-style classes in your BeanFactory. If, for
        example, you need to use a legacy connection pool that absolutely does
        not adhere to the JavaBean specification, no worries, Spring can
        manage it as well.</p><p>Using the XmlBeanFactory you can specify your bean class as
        follows: </p><pre class="programlisting">&lt;bean id="exampleBean"
      class="examples.ExampleBean"/&gt;
&lt;bean name="anotherExample"
      class="examples.ExampleBeanTwo"/&gt; </pre><p>The mechanism for supplying (optional) arguments to the
        constructor, or setting properties of the object instance after it has
        been constructed, will be described shortly.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e495"></a>3.2.3.2.&nbsp;Bean creation via static factory method</h4></div></div></div><p>When defining a bean which is to be created using a static
        factory method, along with the <code class="literal">class</code> attribute
        which specifies the class containing the static factory method,
        another attribute named <code class="literal">factory-method</code> is needed to
        specify the name of the factory method itself. Spring expects to be
        able to call this method (with an optional list of arguments as
        described later) and get back a live object, which from that point on
        is treated as if it had been created normally via a constructor. One
        use for such a bean definition is to call static factories in legacy
        code.</p><p>Following is an example of a bean definition which specifies
        that the bean is to be created by calling a factory-method. Note that
        the definition does not specify the type (class) of the returned
        object, only the class containing the factory method. In this example,
        <code class="literal">createInstance</code> must be a
        <span class="emphasis"><em>static</em></span> method.</p><pre class="programlisting">&lt;bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/&gt;</pre><p>The mechanism for supplying (optional) arguments to the factory
        method, or setting properties of the object instance after it has been
        returned from the factory, will be described shortly.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-instance-factory-method"></a>3.2.3.3.&nbsp;Bean creation via instance factory method</h4></div></div></div><p>Quite similar to using a static factory method to create a bean,
        is the use of an instance (non-static) factory method, where a factory
        method of an existing bean from the factory is called to create the
        new bean.</p><p>To use this mechanism, the <code class="literal">class</code> attribute
        must be left empty, and the <code class="literal">factory-bean</code> attribute
        must specify the name of a bean in the current or an ancestor bean
        factory which contains the factory method. The factory method itself
        should still be set via the <code class="literal">factory-method</code>
        attribute.</p><p>Following is an example:</p><pre class="programlisting">&lt;!-- The factory bean, which contains a method called
     createInstance --&gt;
&lt;bean id="myFactoryBean"
      class="..."&gt;
  ...
&lt;/bean&gt;
&lt;!-- The bean to be created via the factory bean --&gt;
&lt;bean id="exampleBean"
      factory-bean="myFactoryBean"
      factory-method="createInstance"/&gt;</pre><p>Although the mechanisms for setting bean properties are still to
        be discussed, one implication of this approach is that the factory
        bean itself can be managed and configured via Dependency Injection, by
        the container.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beanname"></a>3.2.4.&nbsp;The bean identifiers (<code class="literal">id</code> and
      <code class="literal">name</code>)</h3></div></div></div><p>Every bean has one or more ids (also called identifiers, or names;
      these terms refer to the same thing). These ids must be unique within
      the BeanFactory or ApplicationContext the bean is hosted in. A bean will
      almost always have only one id, but if a bean has more than one id, the
      extra ones can essentially be considered aliases.</p><p>In an XmlBeanFactory (including ApplicationContext variants), you
      use the <code class="literal">id</code> or <code class="literal">name</code> attributes to
      specify the bean id(s), and at least one id must be specified in one or
      both of these attributes. The <code class="literal">id</code> attribute allows you
      to specify one id, and as it is marked in the XML DTD (definition
      document) as a real XML element ID attribute, the parser is able to do
      some extra validation when other elements point back to this one. As
      such, it is the preferred way to specify a bean id. However, the XML
      spec does limit the characters which are legal in XML IDs. This is
      usually not really a constraint, but if you have a need to use one of
      these characters, or want to introduce other aliases to the bean, you
      may also or instead specify one or more bean ids (separated by a comma
      (<code class="literal">,</code>) or semicolon (<code class="literal">;</code>) via the
      <code class="literal">name</code> attribute.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-modes"></a>3.2.5.&nbsp;To singleton or not to singleton</h3></div></div></div><p>Beans are defined to be deployed in one of two modes: singleton or
      non-singleton. (The latter is also called a prototype, although the term
      is used loosely as it doesn't quite fit). When a bean is a singleton,
      only one <span class="emphasis"><em>shared</em></span> instance of the bean will be
      managed and all requests for beans with an id or ids matching that bean
      definition will result in that one specific bean instance being
      returned.</p><p>The non-singleton, prototype mode of a bean deployment results in
      the <span class="emphasis"><em>creation of a new bean instance</em></span> every time a
      request for that specific bean is done. This is ideal for situations
      where for example each user needs an independent user object or
      something similar.</p><p>Beans are deployed in singleton mode by default, unless you
      specify otherwise. Keep in mind that by changing the type to
      non-singleton (prototype), each request for a bean will result in a
      newly created bean and this might not be what you actually want. So only
      change the mode to prototype when absolutely necessary.</p><p>In the example below, two beans are declared of which one is
      defined as a singleton, and the other one is a non-singleton
      (prototype). <code class="literal">exampleBean</code> is created each and every
      time a client asks the BeanFactory for this bean, while
      <code class="literal">yetAnotherExample</code> is only created once; a reference
      to the exact same instance is returned on each request for this
      bean.</p><pre class="programlisting">&lt;bean id="exampleBean"
      class="examples.ExampleBean" singleton="false"/&gt;
&lt;bean name="yetAnotherExample"
      class="examples.ExampleBeanTwo" singleton="true"/&gt;</pre><p>Note: when deploying a bean in the prototype mode, the lifecycle
      of the bean changes slightly. By definition, Spring cannot manage the
      complete lifecycle of a non-singleton/prototype bean, since after it is
      created, it is given to the client and the container does not keep track
      of it at all any longer. You can think of Spring's role when talking
      about a non-singleton/prototype bean as a replacement for the 'new'
      operator. Any lifecycle aspects past that point have to be handled by
      the client. The lifecycle of a bean in the BeanFactory is further
      described in <a href="#beans-factory-lifecycle" title="3.4.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.4.1, &#8220;Lifecycle interfaces&#8221;</a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-dependencies"></a>3.3.&nbsp;Properties, collaborators, autowiring and dependency
    checking</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-collaborators"></a>3.3.1.&nbsp;Setting bean properties and collaborators</h3></div></div></div><p>Inversion of Control has already been referred to as
      <span class="emphasis"><em>Dependency Injection</em></span>. The basic principle is that
      beans define their dependencies (i.e. the other objects they work with)
      only through constructor arguments, arguments to a factory method, or
      properties which are set on the object instance after it has been
      constructed or returned from a factory method. Then, it is the job of
      the container to actually <span class="emphasis"><em>inject</em></span> those dependencies
      when it creates the bean. This is fundamentally the inverse (hence the
      name Inversion of Control) of the bean instantiating or locating its
      dependencies on its own using direct construction of classes, or
      something like the <span class="emphasis"><em>Service Locator</em></span> pattern. While
      we will not elaborate too much on the advantages of Dependency
      Injection, it becomes evident upon usage that code gets much cleaner and
      reaching a higher grade of decoupling is much easier when beans do not
      look up their dependencies, but are provided with them, and additionally
      do not even know where the dependencies are located and of what actual
      type they are.</p><p>As touched on in the previous paragraph, Inversion of
      Control/Dependency Injection exists in two major variants:</p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>setter-based</em></span> dependency injection is
            realized by calling setters on your beans after invoking a
            no-argument constructor or no-argument static factory method to
            instantiate your bean. Beans defined in the BeanFactory that use
            setter-based dependency injection are <span class="emphasis"><em>true
            JavaBeans</em></span>. Spring generally advocates usage of
            setter-based dependency injection, since a large number of
            constructor arguments can get unwieldy, especially when some
            properties are optional.</p></li><li><p><span class="emphasis"><em>constructor-based</em></span> dependency injection
            is realized by invoking a constructor with a number of arguments,
            each representing a collaborator or property. Additionally,
            calling a static factory method with specific arguments, to
            construct the bean, can be considered almost equivalent, and the
            rest of this text will consider arguments to a constructor and
            arguments to a static factory method similarly. Although Spring
            generally advocates usage of setter-based dependency injection for
            most situations, it does fully support the constructor-based
            approach as well, since you may wish to use it with pre-existing
            beans which provide only multi-argument constructors, and no
            setters. Additionally, for simpler beans, some people prefer the
            constructor approach as a means of ensuring beans cannot be
            constructed in an invalid state.</p></li></ul></div><p>The <code class="classname">BeanFactory</code> supports both of these
      variants for injecting dependencies into beans it manages. (It in fact
      also supports injecting setter-based dependencies after some
      dependencies have already been supplied via the constructor approach.)
      The configuration for the dependencies comes in the form of a
      <code class="literal">BeanDefinition</code>, which is used together with JavaBeans
      <code class="literal">PropertyEditors</code> to know how to convert properties
      from one format to another. The actual values being passed around are
      done in the form of <code class="literal">PropertyValue</code> objects. However,
      most users of Spring will not be dealing with these classes directly
      (i.e. programmatically), but rather with an XML definition file which
      will be converted internally into instances of these classes, and used
      to load an entire BeanFactory or ApplicationContext.</p><p>Bean dependency resolution generally happens as
      follows:</p><div class="orderedlist"><ol type="1" compact><li><p>The BeanFactory is created and initialized with a
            configuration which describes all the beans. Most Spring users use
            a BeanFactory or ApplicationContext variant which supports XML
            format configuration files.</p></li><li><p>Each bean has dependencies expressed in the form of
            properties, constructor arguments, or arguments to the
            static-factory method when that is used instead of a normal
            constructor. These dependencies will be provided to the bean,
            <span class="emphasis"><em>when the bean is actually created</em></span>.</p></li><li><p>Each property or constructor-arg is either an actual
            definition of the value to set, or a reference to another bean in
            the BeanFactory. In the case of the ApplicationContext, the
            reference can be to a bean in a parent ApplicationContext.</p></li><li><p><a name="beans-factory-collaborators-propertyeditor"></a>Each property or
            constructor argument which is a value must be able to be converted
            from whatever format it was specified in, to the actual type of
            that property or constructor argument. By default Spring can
            convert a value supplied in string format to all built-in types,
            such as <code class="literal">int</code>, <code class="literal">long</code>,
            <code class="literal">String</code>, <code class="literal">boolean</code>, etc.
            Additionally, when talking about the XML based BeanFactory
            variants (including the ApplicationContext variants), these have
            built-in support for defining Lists, Maps, Sets, and Properties
            collection types. Additionally, Spring uses JavaBeans
            <code class="classname">PropertyEditor</code> definitions to be able to
            convert string values to other, arbitrary types. (You can provide
            the BeanFactory with your own <code class="literal">PropertyEditor</code>
            definitions to be able to convert your own custom types; more
            information about PropertyEditors and how to manually add custom
            ones, can be found in <a href="#beans-beanfactory-customeditors" title="3.9.&nbsp;Registering additional custom PropertyEditors">Section&nbsp;3.9, &#8220;Registering additional custom PropertyEditors&#8221;</a>). When a bean
            property is a Java Class type, Spring allows you to specify the
            value for that property as a string value which is the name of the
            class, and the <code class="literal">ClassEditor</code> PropertyEditor,
            which is built-in, will take care of converting that class name to
            an actual Class instance.</p></li><li><p>It is important to realize that Spring validates the
            configuration of each bean in the BeanFactory when the BeanFactory
            is created, including the validation that properties which are
            bean references are actually referring to valid beans (i.e. the
            beans being referred to are also defined in the BeanFactory, or in
            the case of ApplicationContext, a parent context). However, the
            bean properties themselves are not set until the bean <span class="emphasis"><em>is
            actually created</em></span>. For beans which are singleton and set
            to be pre-instantiated (such as singleton beans in an
            ApplicationContext), creation happens at the time that the
            BeanFactory is created, but otherwise this is only when the bean
            is requested. When a bean actually has to be created, this will
            potentially cause a graph of other beans to be created, as its
            dependencies and its dependencies' dependencies (and so on) are
            created and assigned.</p></li><li><p>You can generally trust Spring to do the right thing. It
            will pick up configuration issues, including references to
            non-existent beans and circular dependencies, at BeanFactory
            load-time. It will actually set properties and resolve
            dependencies (i.e. create those dependencies if needed) as late as
            possible, which is when the bean is actually created. This does
            mean that a BeanFactory which has loaded correctly, can later
            generate an exception when you request a bean, if there is a
            problem creating that bean or one of its dependencies. This could
            happen if the bean throws an exception as a result of a missing or
            invalid property, for example. This potentially delayed visibility
            of some configuration issues is why ApplicationContext by default
            pre-instantiates singleton beans. At the cost of some upfront time
            and memory to create these beans before they are actually needed,
            you find out about configuration issues when the
            ApplicationContext is created, not later. If you wish, you can
            still override this default behavior and set any of these
            singleton beans to lazy-load (not be pre-instantiated).</p></li></ol></div><p>Some examples:</p><p>First, an example of using the BeanFactory for setter-based
      dependency injection. Below is a small part of an
      <code class="literal">XmlBeanFactory</code> configuration file specifying some
      bean definitions. Following is the code for the actual main bean itself,
      showing the appropriate setters declared. </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;property name="beanOne"&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/property&gt;
  &lt;property name="beanTwo"&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/property&gt;
  &lt;property name="integerProperty"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><p>
      </p><pre class="programlisting">public class ExampleBean {
    
    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }
    
    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }
    
    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}</pre><p>As you can see, setters have been declared to match against
      the properties specified in the XML file. (The properties from the XML
      file, directly relate to the <code class="literal">PropertyValues</code> object
      from the <code class="literal">RootBeanDefinition</code>)</p><p>Now, an example of using the BeanFactory for IoC type 3
      (constructor-based dependency injection). Below is a snippet from an XML
      configuration that specifies constructor arguments and the actual bean
      code, showing the constructor: </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;
  &lt;constructor-arg&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/constructor-arg&gt;
  &lt;constructor-arg type="int"&gt;&lt;value&gt;1&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><p>
      </p><pre class="programlisting">public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}</pre><p>As you can see, the constructor arguments specified in the
      bean definition will be used to pass in as arguments to the constructor
      of the <code class="literal">ExampleBean</code>.</p><p>Now consider a variant of this where instead of using a
      constructor, Spring is told to call a static factory method to return an
      instance of the object.: </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance"&gt;
  &lt;constructor-arg&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/constructor-arg&gt;
  &lt;constructor-arg&gt;&lt;ref bean="yetAnotherBean"/&gt;&lt;/constructor-arg&gt;
  &lt;constructor-arg&gt;&lt;value&gt;1&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><p>
      </p><pre class="programlisting">public class ExampleBean {

    ...

    // a private constructor
    private ExampleBean(...) {
      ...
    }
    
    // a static factory method
    // the arguments to this method can be considered the dependencies of the bean that
    // is returned, regardless of how those arguments are actually used.
    public static ExampleBean createInstance(
            AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        ExampleBean eb = new ExampleBean(...);
        // some other operations
        ...
        return eb;
    }
}</pre><p>Note that arguments to the static factory method are supplied via
      <code class="literal">constructor-arg</code> elements, exactly the same as if a
      constructor had actually been used. These arguments are optional. Also,
      it is important to realize that the type of the class being returned by
      the factory method does not have to be of the same type as the class
      which contains the static factory method, although in this example it
      is. An instance (non-static) factory method, mentioned previously, would
      be used in an essentially identical fashion (aside from the use of the
      <code class="literal">factory-bean</code> attribute instead of the
      <code class="literal">class</code> attribute), so will not be detailed
      here.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e746"></a>3.3.2.&nbsp;Constructor Argument Resolution</h3></div></div></div><p>Constructor argument resolution matching occurs using the
      argument's type. When another bean is referenced, the type is known, and
      matching can occur. When a simple type is used, such as
      <code class="literal">&lt;value&gt;true&lt;value&gt;</code>, Spring cannot
      determine the type of the value, and so cannot match by type without
      help. Consider the following class, which is used for the following two
      sections: </p><pre class="programlisting">package examples;

public class ExampleBean {

    private int years;             //No. of years to the calculate the Ultimate Answer
    private String ultimateAnswer; //The Answer to Life, the Universe, and Everything

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e756"></a>3.3.2.1.&nbsp;Constructor Argument Type Matching</h4></div></div></div><p>The above scenario <span class="emphasis"><em>can</em></span> use type matching
        with simple types by explicitly specifying the type of the constructor
        argument using the <code class="literal">type</code> attribute. For example:
        </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg type="int"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/constructor-arg&gt;
  &lt;constructor-arg type="java.lang.String"&gt;&lt;value&gt;42&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt; </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e769"></a>3.3.2.2.&nbsp;Constructor Argument Index</h4></div></div></div><p>Constructor arguments can have their index specified explicitly
        by use of the <code class="literal">index</code> attribute. For example:
        </p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg index="0"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/constructor-arg&gt;
  &lt;constructor-arg index="1"&gt;&lt;value&gt;42&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt; </pre><p> As well as solving the ambiguity problem of
        multiple simple values, specifying an index also solves the problem of
        ambiguity where a constructor may have two arguments of the same type.
        Note that the <span class="emphasis"><em>index is 0 based</em></span>.</p><p>Specifying a constructor argument index is the preferred way of
        performing constructor IoC.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-properties-detailed"></a>3.3.3.&nbsp;Bean properties and constructor arguments detailed</h3></div></div></div><p>As mentioned in the previous section, bean properties and
      constructor arguments can be defined as either references to other
      managed beans (collaborators), or values defined inline. The
      <code class="literal">XmlBeanFactory</code> supports a number of sub-element types
      within its <code class="literal">property</code> and
      <code class="literal">constructor-arg</code> elements for this purpose.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-value-element"></a>3.3.3.1.&nbsp;The <code class="literal">value</code> element</h4></div></div></div><p>The <code class="literal">value</code> element specifies a property or
        constructor argument as a human-readable string representation. As
        mentioned in detail <a href="#beans-factory-collaborators-propertyeditor">previously</a>,
        JavaBeans PropertyEditors are used to convert these string values from
        a <code class="literal">java.lang.String</code> to the actual property or
        argument type.</p><pre class="programlisting">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  &lt;!-- results in a setDriverClassName(String) call --&gt;
  &lt;property name="driverClassName"&gt;
    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="url"&gt;
    &lt;value&gt;jdbc:mysql://localhost:3306/mydb&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="username"&gt;
    &lt;value&gt;root&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-null-element"></a>3.3.3.2.&nbsp;The <code class="literal">null</code> element</h4></div></div></div><p>The <code class="literal">null</code> element is used to handle null
        values. Spring treats empty arguments for properties and the like as
        empty Strings. The following XmlBeanFactory configuration:
        </p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;value&gt;&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;        </pre><p>results in the email property being set
        to "", equivalent to the java code:
        <code class="literal">exampleBean.setEmail("")</code>. The special
        <code class="literal">&lt;null&gt;</code> element may be used to indicate a null
        value, so that: </p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;
&lt;/bean&gt;        </pre><p>is equivalent to the java code:
        <code class="literal">exampleBean.setEmail(null)</code>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-collection-elements"></a>3.3.3.3.&nbsp;The collection elements</h4></div></div></div><p>The <code class="literal">list</code>, <code class="literal">set</code>,
        <code class="literal">map</code>, and <code class="literal">props</code> elements allow
        properties and arguments of Java type <code class="literal">List</code>,
        <code class="literal">Set</code>, <code class="literal">Map</code>, and
        <code class="literal">Properties</code>, respectively, to be defined and
        set.</p><pre class="programlisting">&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
  &lt;!-- results in a setPeople(java.util.Properties) call --&gt;
  &lt;property name="people"&gt;
    &lt;props&gt;
      &lt;prop key="HarryPotter"&gt;The magic property&lt;/prop&gt;
      &lt;prop key="JerrySeinfeld"&gt;The funny property&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
  &lt;!-- results in a setSomeList(java.util.List) call --&gt;
  &lt;property name="someList"&gt;
    &lt;list&gt;
      &lt;value&gt;a list element followed by a reference&lt;/value&gt;
      &lt;ref bean="myDataSource"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
  &lt;property name="someMap"&gt;
    &lt;map&gt;
      &lt;entry&gt;
        &lt;key&gt;&lt;value&gt;yup an entry&lt;/value&gt;&lt;/key&gt;
        &lt;value&gt;just some string&lt;/value&gt;
      &lt;/entry&gt;
      &lt;entry&gt;
        &lt;key&gt;&lt;value&gt;yup a ref&lt;/value&gt;&lt;/key&gt;
        &lt;ref bean="myDataSource"/&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
  &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
  &lt;property name="someSet"&gt;
    &lt;set&gt;
      &lt;value&gt;just some string&lt;/value&gt;
      &lt;ref bean="myDataSource"/&gt;
    &lt;/set&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>Note that the value of a map key or value, or a set
        value, can also again be any of the
        elements:</em></span></p><pre class="programlisting">(bean | ref | idref | list | set | map | props | value | null)</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-inner-beans"></a>3.3.3.4.&nbsp;Inner bean definitions via nested bean elements</h4></div></div></div><p>A <code class="literal">bean</code> element inside the
        <code class="literal">property</code> element is used to define a bean value
        inline, instead of referring to a bean defined elsewhere in the
        BeanFactory. The inline bean definition does not need to have any id
        defined. </p><pre class="programlisting">&lt;bean id="outer" class="..."&gt;
  &lt;!-- Instead of using a reference to target, just use an inner bean --&gt;
  &lt;property name="target"&gt;
    &lt;bean class="com.mycompany.PersonImpl"&gt;
      &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
      &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the <code class="literal">singleton</code> flag and any
        <code class="literal">id</code> attribute are effectively ignored. Inner beans
        are anonymous prototypes.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-idref-element"></a>3.3.3.5.&nbsp;The <code class="literal">idref</code> element</h4></div></div></div><p>An idref element is simply a shorthand and error-proof way to
        set a property to the String <span class="emphasis"><em>id</em></span> or
        <span class="emphasis"><em>name</em></span> of another bean in the
        container.</p><pre class="programlisting">&lt;bean id="theTargetBean" class="..."/&gt;

&lt;bean id="theClientBean" class="..."&gt;
  &lt;property name="targetName"&gt;
    &lt;idref bean="theTargetBean"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>This is exactly equivalent at runtime to the
        following fragment:</p><pre class="programlisting">&lt;bean id="theTargetBean" class="..."&gt;
&lt;/bean&gt;

&lt;bean id="theClientBean" class="..."&gt;
  &lt;property name="targetName"&gt;
    &lt;value&gt;theTargetBean&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The main reason the first form is preferable to
        the second is that using the <code class="literal">idref</code> tag will allow
        Spring to validate at deployment time that the other bean actually
        exists. In the second variation, the class who's
        <span class="emphasis"><em>targetName</em></span> property is forced to do its own
        validation, and that will only happen when that class is actually
        instantiated by Spring, possibly long after the container is actually
        deployed.</p><p>Additionally, if the bean being referred to is in the same
        actual XML file, and the bean name is the bean
        <span class="emphasis"><em>id</em></span>, the <code class="literal">local</code> attribute may be
        used, which will allow the XML parser itself to validate the bean name
        even earlier, at XML document parse time.</p><pre class="programlisting">  &lt;property name="targetName"&gt;
    &lt;idref local="theTargetBean"/&gt;
  &lt;/property&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-ref-element"></a>3.3.3.6.&nbsp;The <code class="literal">ref</code> element</h4></div></div></div><p>The <code class="literal">ref</code> element is the final element allowed
        inside a <code class="literal">property</code> definition element. It is used to
        set the value of the specified property to be a reference to another
        bean managed by the container, a collaborator, so to speak. As
        mentioned in a previous section, the referred-to bean is considered to
        be a dependency of the bean who's property is being set, and will be
        initialized on demand as needed (if it is a singleton bean it may have
        already been initialized by the container) before the property is set.
        All references are ultimately just a reference to another object, but
        there are 3 variations on how the id/name of the other object may be
        specified, which determines how scoping and validation is
        handled.</p><p>Specifying the target bean by using the <code class="literal">bean</code>
        attribute of the <code class="literal">ref</code> tag is the most general form,
        and will allow creating a reference to any bean in the same
        BeanFactory/ApplicationContext (whether or not in the same XML file),
        or parent BeanFactory/ApplicationContext. The value of the
        <code class="literal">bean</code> attribute may be the same as either the
        <code class="literal">id</code> attribute of the target bean, or one of the
        values in the <code class="literal">name</code> attribute of the target
        bean.</p><pre class="programlisting">  &lt;ref bean="someBean"/&gt;</pre><p>Specifying the target bean by using the <code class="literal">local</code>
        attribute leverages the ability of the XML parser to validate XML id
        references within the same file. The value of the
        <code class="literal">local</code> attribute must be the same as the
        <code class="literal">id</code> attribute of the target bean. The XML parser
        will issue an error if no matching element is found in the same file.
        As such, using the local variant is the best choice (in order to know
        about errors are early as possible) if the target bean is in the same
        XML file.</p><pre class="programlisting">  &lt;ref local="someBean"/&gt;</pre><p>Specifying the target bean by using the
        <code class="literal">parent</code> attribute allows a reference to be created
        to a bean which is in a parent BeanFactory (or ApplicationContext) of
        the current BeanFactory (or ApplicationContext). The value of the
        <code class="literal">parent</code> attribute may be the same as either the
        <code class="literal">id</code> attribute of the target bean, or one of the
        values in the <code class="literal">name</code> attribute of the target bean,
        and the target bean must be in a parent BeanFactory or
        ApplicationContext to the current one. The main use of this bean
        reference variant is when there is a need to wrap an existing bean in
        a parent context with some sort of proxy (which may have the same name
        as the parent), and needs the original object so it may wrap
        it.</p><pre class="programlisting">  &lt;ref parent="someBean"/&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1000"></a>3.3.3.7.&nbsp;Value and Ref shortcut
        forms</h4></div></div></div><p>It is so common to need to configure a value or a bean
        reference, that there exist some shortcut forms which are less verbose
        than using the full <code class="literal">value</code> and
        <code class="literal">ref</code> elements. The <code class="literal">property</code>,
        <code class="literal">constructor-arg</code>, and <code class="literal">entry</code>
        elements all support a <code class="literal">value</code> attribute which may be
        used instead of embedding a full <code class="literal">value</code> element.
        Therefore, the following:</p><pre class="programlisting">&lt;property name="myProperty"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/property</pre><pre class="programlisting">&lt;constructor-arg&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/constructor-arg&gt;</pre><pre class="programlisting">&lt;entry key="myKey"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/entry&gt;</pre><p>are equivalent to:</p><pre class="programlisting">&lt;property name="myProperty" value="hello"/&gt;</pre><pre class="programlisting">&lt;constructor-arg value="hello"/&gt;</pre><pre class="programlisting">&lt;entry key="myKey" value="hello"/&gt;</pre><p>In
        general, when typing definitions by hand, you will probably prefer to
        use the less verbose shortcut form.</p><p>The <code class="literal">property</code> and
        <code class="literal">constructor-arg</code> elements support a similar shortcut
        <code class="literal">ref</code> attribute which may be used instead of a full
        nested <code class="literal">ref</code> element. Therefore, the
        following:</p><pre class="programlisting">&lt;property name="myProperty"&gt;
  &lt;ref bean="myBean"&gt;
&lt;/property</pre><pre class="programlisting">&lt;constructor-arg&gt;
  &lt;ref bean="myBean"&gt;
&lt;/constructor-arg&gt;</pre><p>are equivalent to:</p><pre class="programlisting">&lt;property name="myProperty" ref="myBean"/&gt;</pre><pre class="programlisting">&lt;constructor-arg ref="myBean"/&gt;</pre><p>Note however that the shortcut form is equivalent to a
        <code class="literal">&lt;ref bean="xxx"&gt;</code> element, there is no
        shortcut for <code class="literal">&lt;ref local="xxx"</code>&gt;. To enforce a
        strict local ref, you must use the long form.</p><p>Finally, the entry element allows a shortcut form to specify the
        key and/or value of the map, in the form of the <code class="literal">key</code>
        / <code class="literal">key-ref</code> and <code class="literal">value</code> /
        <code class="literal">value-ref</code> attributes. Therefore, the
        following:</p><pre class="programlisting">&lt;entry&gt;
  &lt;key&gt;&lt;ref bean="myKeyBean"/&gt;&lt;/key&gt;
  &lt;ref bean="myValueBean"/&gt;
&lt;/entry&gt;
</pre><p>is equivalent to:</p><pre class="programlisting">&lt;entry key-ref="myKeyBean" value-ref="myValueBean"/&gt;
</pre><p>Again, the shortcut form is equivalent to a <code class="literal">&lt;ref
        bean="xxx"&gt;</code> element; there is no shortcut for
        <code class="literal">&lt;ref local="xxx"</code>&gt;.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1106"></a>3.3.3.8.&nbsp;Compound property names</h4></div></div></div><p>Note that compound or nested property names are perfectly legal
        when setting bean properties, as long as all components of the path
        except the final property name are non-null. For example, in this bean
        definition:</p><pre class="programlisting">&lt;bean id="foo" class="foo.Bar"&gt;
  &lt;property name="fred.bob.sammy" value="123"/&gt;
&lt;/bean&gt;</pre><p>the foo bean has a <code class="literal">fred</code> property which has a
        <code class="literal">bob</code> property, which has a <code class="literal">sammy</code>
        property, and that final <code class="literal">sammy</code> property is being
        set to a scalar value of 123. In order for this to work, the
        <code class="literal">fred</code> property of <code class="literal">foo</code>, and the
        <code class="literal">bob</code> property of <code class="literal">fred</code> must both
        be non-null after the bean is constructed, or a null-pointer exception
        will be thrown.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-method-injection"></a>3.3.4.&nbsp;Method Injection</h3></div></div></div><p>For most users, the majority of the beans in the container will be
      singletons. When a singleton bean needs to collaborate with (use)
      another singleton bean, or a non-singleton bean needs to collaborate
      with another non-singleton bean, the typical and common approach of
      handling this dependency by defining one bean to be a property of the
      other, is quite adequate. There is however a problem when the bean
      lifecycles are different. Consider a singleton bean A which needs to use
      a non-singleton (prototype) bean B, perhaps on each method invocation on
      A. The container will only create the singleton bean A once, and thus
      only get the opportunity to set its properties once. There is no
      opportunity for the container to provide bean A with a new instance of
      bean B every time one is needed.</p><p>One solution to this problem is to forgo some inversion of
      control. Bean A can be aware of the container (as described <a href="#beans-factory-aware-beanfactoryaware" title="3.4.2.1.&nbsp;BeanFactoryAware">here</a>) by
      implementing<code class="literal"> BeanFactoryAware</code>, and use programmatic
      means (as described <a href="#beans-factory-client" title="3.6.&nbsp;Interacting with the BeanFactory">here</a>) to
      ask the container via a <code class="literal">getBean("B")</code> call for (a new)
      bean B every time it needs it. This is generally not a desirable
      solution since the bean code is then aware of and coupled to
      Spring.</p><p>Method Injection, an advanced feature of the BeanFactory, allows
      this use case to be handled in a clean fashion, along with some other
      scenarios.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1161"></a>3.3.4.1.&nbsp;Lookup method Injection</h4></div></div></div><p>Lookup method injection refers to the ability of the container
        to override abstract or concrete methods on managed beans in the
        container, to return the result of looking up another named bean in
        the container. The lookup will typically be of a non-singleton bean as
        per the scenario described above (although it can also be a
        singleton). Spring implements this through a dynamically generated
        subclass overriding the method, using bytecode generation via the
        CGLIB library.</p><p>In the client class containing the method to be injected, the
        method definition must be an abstract (or concrete) definition in this
        form:</p><pre class="programlisting">protected abstract SingleShotHelper createSingleShotHelper();</pre><p>If the method is not abstract, Spring will simply override the
        existing implementation. In the XmlBeanFactory case, you instruct
        Spring to inject/override this method to return a particular bean from
        the container, by using the <code class="literal">lookup-method</code> element
        inside the bean definition. For example:</p><pre class="programlisting">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id="singleShotHelper class="..." singleton="false"&gt;
&lt;/bean&gt;

&lt;!-- myBean uses singleShotHelper --&gt;
&lt;bean id="myBean" class="..."&gt;
  &lt;lookup-method name="createSingleShotHelper" bean="singleShotHelper"/&gt;
  &lt;property&gt;
    ...
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The bean identified as <span class="emphasis"><em>myBean</em></span> will call its
        own method <code class="literal">createSingleShotHelper</code> whenever it needs
        a new instance of the <span class="emphasis"><em>singleShotHelper</em></span> bean. It
        is important to note that the person deploying the beans must be
        careful to deploy <span class="emphasis"><em>singleShotHelper</em></span> as a
        non-singleton (if that is actually what is needed). If it is deployed
        as a singleton (either explicitly, or relying on the default
        <span class="emphasis"><em>true</em></span> setting for this flag), the same instance of
        singleShotHelper will be returned each time!</p><p>Note that lookup method injection can be combined with
        Constructor Injection (supplying optional constructor arguments to the
        bean being constructed), and also with Setter Injection (settings
        properties on the bean being constructed).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1197"></a>3.3.4.2.&nbsp;Arbitrary method replacement</h4></div></div></div><p>A less commonly useful form of method injection than Lookup
        Method Injection is the ability to replace arbitrary methods in a
        managed bean with another method implementation. Users may safely skip
        the rest of this section (which describes this somewhat advanced
        feature), until this functionality is actually needed.</p><p>In an XmlBeanFactory, the <code class="literal">replaced-method</code>
        element may be used to replace an existing method implementation with
        another, for a deployed bean. Consider the following class, with a
        method computeValue, which we want to override:</p><pre class="programlisting">...
public class MyValueCalculator {
  public String computeValue(String input) {
    ... some real code
  }

  ... some other methods
}</pre><p>A class implementing the
        <code class="literal">org.springframework.beans.factory.support.MethodReplacer</code>
        interface is needed to provide the new method
        definition.</p><pre class="programlisting">/** meant to be used to override the existing computeValue
    implementation in MyValueCalculator */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ... 
        return ...;
}</pre><p>The BeanFactory deployment definition to deploy the original
        class and specify the method override would look like:</p><pre class="programlisting">&lt;bean id="myValueCalculator class="x.y.z.MyValueCalculator"&gt;
  &lt;!-- arbitrary method replacement --&gt;
  &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
    &lt;arg-type&gt;String&lt;/arg-type&gt;
  &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplaceMentComputeValue"/&gt;
</pre><p>One or more contained <code class="literal">arg-type</code> elements
        within the <code class="literal">replaced-method</code> element may be used to
        indicate the method signature of the method being overridden. Note
        that the signature for the arguments is actually only needed in the
        case that the method is actually overloaded and there are multiple
        variants within the class. For convenience, the type string for an
        argument may be a substring of the fully qualified type name. For
        example, all the following would match
        <span class="emphasis"><em>java.lang.String</em></span>.</p><pre class="programlisting">    java.lang.String
    String
    Str</pre><p>Since the number of arguments is often enough to
        distinguish between each possible choice, this shortcut can save a lot
        of typing, by just using the shortest string which will match an
        argument.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependson"></a>3.3.5.&nbsp;Using <code class="literal">depends-on</code></h3></div></div></div><p>For most situations, the fact that a bean is a dependency of
      another is expressed simply by the fact that one bean is set as a
      property of another. This is typically done with the
      <code class="literal">ref</code> element in the XmlBeanFactory. In a variation of
      this, sometimes a bean which is aware of the container is simply given
      the id of its dependency (using a string value or alternately the
      <code class="literal">idref</code> element, which evaluates the same as a string
      value). The first bean then programmatically asks the container for its
      dependency. In either case, the dependency is properly initialized
      before the dependent bean.</p><p>For the relatively infrequent situations where dependencies
      between beans are less direct (for example, when a static initializer in
      a class needs to be triggered, such as database driver registration),
      the <code class="literal">depends-on</code> element may be used to explicitly
      force one or more beans to be initialized before the bean using this
      element is initialized.</p><p>Following is an example configuration:</p><pre class="programlisting">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"&gt;
  &lt;property name="manager"&gt;&lt;ref local="manager"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean"/&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-autowire"></a>3.3.6.&nbsp;Autowiring collaborators</h3></div></div></div><p>A BeanFactory is able to <span class="emphasis"><em>autowire</em></span>
      relationships between collaborating beans. This means it's possible to
      automatically let Spring resolve collaborators (other beans) for your
      bean by inspecting the contents of the BeanFactory. The autowiring
      functionality has five modes. Autowiring is specified
      <span class="emphasis"><em>per</em></span> bean and can thus be enabled for some beans,
      while other beans won't be autowired. Using autowiring, it is possible
      to reduce or eliminate the need to specify properties or constructor
      arguments, saving a significant amount of typing.<sup>[<a name="d0e1266" href="#ftn.d0e1266">1</a>]</sup>In an XmlBeanFactory, the autowire mode for a bean
      definition is specified by using the <code class="literal">autowire</code>
      attribute of the bean element. The following values are allowed.</p><div class="table"><a name="d0e1274"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Autowiring modes</b></p><div class="table-contents"><table summary="Autowiring modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>no</td><td>No autowiring at all. Bean references must be defined
                via a <code class="literal">ref</code> element. This is the default, and
                changing this is discouraged for larger deployments, since
                explicitly specifying collaborators gives greater control and
                clarity. To some extent, it is a form of documentation about
                the structure of a system.</td></tr><tr><td>byName</td><td>Autowiring by property name. This option will inspect
                the BeanFactory and look for a bean named exactly the same as
                the property which needs to be autowired. For example, if you
                have a bean definition which is set to autowire by name, and
                it contains a <span class="emphasis"><em>master</em></span> property (that is,
                it has a <span class="emphasis"><em>setMaster</em></span>(...) method), Spring
                will look for a bean definition named master, and use it to
                set the property.</td></tr><tr><td>byType</td><td>Allows a property to be autowired if there is exactly
                one bean of the property type in the BeanFactory. If there is
                more than one, a fatal exception is thrown, and this indicates
                that you may not use <span class="emphasis"><em>byType</em></span> autowiring
                for that bean. If there are no matching beans, nothing
                happens; the property is not set. If this is not desirable,
                setting the <code class="literal">dependency-check="objects"</code>
                attribute value specifies that an error should be thrown in
                this case.</td></tr><tr><td>constructor</td><td>This is analogous to <span class="emphasis"><em>byType</em></span>, but
                applies to constructor arguments. If there isn't exactly one
                bean of the constructor argument type in the bean factory, a
                fatal error is raised.</td></tr><tr><td>autodetect</td><td>Chooses <span class="emphasis"><em>constructor</em></span> or
                <span class="emphasis"><em>byType</em></span> through introspection of the bean
                class. If a default constructor is found, byType gets
                applied.</td></tr></tbody></table></div></div><p><br class="table-break"></p><p>Note that explicit dependencies in <code class="literal">property</code> and
      <code class="literal">constructor-arg</code> elements always override autowiring.
      Autowire behavior can be combined with dependency checking, which will
      be performed after all autowiring has been
      completed.<span class="emphasis"><em></em></span></p><p>It's important to understand the pros and cons around autowiring.
      Some advantages of autowiring:</p><div class="itemizedlist"><ul type="disc"><li><p>It can significantly reduce the volume of configuration
          required. (However, mechanisms such as the use of a configuration
          "template," discussed elsewhere in this chapter, are also valuable
          here.)</p></li><li><p>It can cause configuration to keep itself up to date as your
          objects evolve. For example, if you need to add an additional
          dependency to a class, that dependency can be satisfied
          automatically without the need to modify configuration. Thus there
          may be a strong case for autowiring during development, without
          ruling out the option of switching to explicit wiring when the code
          base becomes more stable.</p></li></ul></div><p>Some disadvantages of autowiring:</p><div class="itemizedlist"><ul type="disc"><li><p>It's more magical than explicit wiring. Although, as noted in
          the above table, Spring is careful to avoid guessing in case of
          ambiguity which might have unexpected results, the relationships
          between your Spring-managed objects is no longer explicitly
          documented.</p></li><li><p>Wiring information may not be available to tools that may
          generate documentation from a Spring application context.</p></li><li><p>Autowiring by type will only work when there is a single bean
          definition of the type specified by the setter method or constructor
          argument. You need to use explicit wiring if there is any potential
          ambiguity.</p></li></ul></div><p>There is no "wrong" or "right" answer in all cases. We recommend a
      degree of consistency across a project. For example, if autowiring is
      not used in general, it might be confusing to developers to use it just
      to one or two bean definitions.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependencies"></a>3.3.7.&nbsp;Checking for dependencies</h3></div></div></div><p>Spring has the ability to try to check for the existence of
      unresolved dependencies of a bean deployed into the BeanFactory. These
      are JavaBeans properties of the bean, which do not have actual values
      set for them in the bean definition, or alternately provided
      automatically by the autowiring feature.</p><p>This feature is sometimes useful when you want to ensure that all
      properties (or all properties of a certain type) are set on a bean. Of
      course, in many cases a bean class will have default values for many
      properties, or some properties do not apply to all usage scenarios, so
      this feature is of limited use. Dependency checking can also be enabled
      and disabled per bean, just as with the autowiring functionality. The
      default is to <span class="emphasis"><em>not</em></span> check dependencies. Dependency
      checking can be handled in several different modes. In an
      XmlBeanFactory, this is specified via the
      <code class="literal">dependency-check</code> attribute in a bean definition,
      which may have the following values.</p><div class="table"><a name="d0e1381"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Dependency checking modes</b></p><div class="table-contents"><table summary="Dependency checking modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>none</td><td>No dependency checking. Properties of the bean which
                have no value specified for them are simply not set.</td></tr><tr><td>simple</td><td>Dependency checking is performed for primitive types
                and collections (everything except collaborators, i.e. other
                beans)</td></tr><tr><td>object</td><td>Dependency checking is performed for
                collaborators</td></tr><tr><td>all</td><td>Dependency checking is done for collaborators,
                primitive types and collections</td></tr></tbody></table></div></div><p><br class="table-break"></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-nature"></a>3.4.&nbsp;Customizing the nature of a bean</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lifecycle"></a>3.4.1.&nbsp;Lifecycle interfaces</h3></div></div></div><p>Spring provides several marker interfaces to change the behavior
      of your bean in the BeanFactory. They include
      <code class="literal">InitializingBean</code> and
      <code class="literal">DisposableBean</code>. Implementing these interfaces will
      result in the BeanFactory calling
      <code class="literal">afterPropertiesSet()</code> for the former and
      <code class="literal">destroy()</code> for the latter to allow the bean to perform
      certain actions upon initialization and destruction.</p><p>Internally, Spring uses <code class="literal">BeanPostProcessors</code> to
      process any marker interfaces it can find and call the appropriate
      methods. If you need custom features or other lifecycle behavior Spring
      doesn't offer out-of-the-box, you can implement a
      <code class="literal">BeanPostProcessor</code> yourself. More information about
      this can be found in <a href="#beans-factory-customizing" title="3.7.&nbsp;Customizing beans with BeanPostProcessors">Section&nbsp;3.7, &#8220;Customizing beans with BeanPostProcessors&#8221;</a>.</p><p>All the different lifecycle marker interfaces are described below.
      In one of the appendices, you can find diagram that show how Spring
      manages beans and how those lifecycle features change the nature of your
      beans and how they are managed.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-initializingbean"></a>3.4.1.1.&nbsp;InitializingBean / <code class="literal">init-method</code></h4></div></div></div><p>Implementing the
        <code class="literal">org.springframework.beans.factory.InitializingBean</code>
        allows a bean to perform initialization work after all necessary
        properties on the bean are set by the BeanFactory. The
        InitializingBean interface specifies exactly one
        method:</p><pre class="programlisting">    * Invoked by a BeanFactory after it has set all bean properties supplied
    * (and satisfied BeanFactoryAware and ApplicationContextAware).
    * &lt;p&gt;This method allows the bean instance to perform initialization only
    * possible when all bean properties have been set and to throw an
    * exception in the event of misconfiguration.
    * @throws Exception in the event of misconfiguration (such
    * as failure to set an essential property) or if initialization fails.
    */
    void afterPropertiesSet() throws Exception;</pre><p><span class="emphasis"><em>Note: generally, the use of the
        <code class="literal">InitializingBean</code> marker interface can be avoided
        (and is discouraged since it unnecessarily couples the code to
        Spring). A bean definition provides support for a generic
        initialization method to be specified. In the case of the
        XmlBeanFactory, this is done via the <code class="literal">init-method</code>
        attribute. For example, the following definition:</em></span></p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;

public class ExampleBean {
    public void init() {
        // do some initialization work
    }
}</pre><p>Is exactly the same as: </p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;

public class AnotherExampleBean implements InitializingBean {
    public void afterPropertiesSet() {
        // do some initialization work
    }
}</pre><p>but does not couple the code to Spring.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-disposablebean"></a>3.4.1.2.&nbsp;DisposableBean / <code class="literal">destroy-method</code></h4></div></div></div><p>Implementing the
        <code class="literal">org.springframework.beans.factory.DisposableBean</code>
        interface allows a bean to get a callback when the BeanFactory
        containing it is destroyed. The DisposableBean interface specifies one
        method: </p><pre class="programlisting">    /**
    * Invoked by a BeanFactory on destruction of a singleton.
    * @throws Exception in case of shutdown errors.
    * Exceptions will get logged but not re-thrown to allow
    * other beans to release their resources too.
    */
    void destroy() throws Exception;
</pre><p><span class="emphasis"><em>Note: generally, the use of the
        <code class="literal">DisposableBean</code> marker interface can be avoided (and
        is discouraged since it unnecessarily couples the code to Spring). A
        bean definition provides support for a generic destroy method to be
        specified. In the case of the XmlBeanFactory, this is done via the
        <code class="literal">destroy-method</code> attribute. For example, the
        following definition: </em></span></p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;

public class ExampleBean {
    public void cleanup() {
        // do some destruction work (like closing connection)
    }
}</pre><p> Is exactly the same as: </p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;

public class AnotherExampleBean implements DisposableBean {
    public void destroy() {
        // do some destruction work
    }
}</pre><p>but does not couple the code to Spring.</p><p><span class="emphasis"><em>Important note: when deploying a bean in the prototype
        mode, the lifecycle of the bean changes slightly. By definition,
        Spring cannot manage the complete lifecycle of a
        non-singleton/prototype bean, since after it is created, it is given
        to the client and the container does not keep track of it at all any
        longer. You can think of Spring's role when talking about a
        non-singleton/prototype bean as a replacement for the 'new' operator.
        Any lifecycle aspects past that point have to be handled by the
        client. The lifecycle of a bean in the BeanFactory is further
        described in <a href="#beans-factory-lifecycle" title="3.4.1.&nbsp;Lifecycle interfaces">Section&nbsp;3.4.1, &#8220;Lifecycle interfaces&#8221;</a></em></span>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-aware"></a>3.4.2.&nbsp;Knowing who you are</h3></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beanfactoryaware"></a>3.4.2.1.&nbsp;BeanFactoryAware</h4></div></div></div><p>A class which implements the
        <code class="literal">org.springframework.beans.factory.BeanFactoryAware</code>
        interface is provided with a reference to the BeanFactory that created
        it, when it is created by that BeanFactory.</p><pre class="programlisting">public interface BeanFactoryAware {
   /**
    * Callback that supplies the owning factory to a bean instance.
    * &lt;p&gt;Invoked after population of normal bean properties but before an init
    * callback like InitializingBean's afterPropertiesSet or a custom init-method.
    * @param beanFactory owning BeanFactory (may not be null).
    * The bean can immediately call methods on the factory.
    * @throws BeansException in case of initialization errors
    * @see BeanInitializationException
    */
    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}</pre><p>This allows beans to manipulate the BeanFactory that created
        them programmatically, through the
        <code class="literal">org.springframework.beans.factory.BeanFactory</code>
        interface, or by casting the reference to a known subclass of this
        which exposes additional functionality. Primarily this would consist
        of programmatic retrieval of other beans. While there are cases when
        this capability is useful, it should generally be avoided, since it
        couples the code to Spring, and does not follow the Inversion of
        Control style, where collaborators are provided to beans as
        properties.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beannameaware"></a>3.4.2.2.&nbsp;BeanNameAware</h4></div></div></div><p>If a bean implements the
        <code class="literal">org.springframework.beans.factory.BeanNameAware</code>
        interface and is deployed in a BeanFactory, the BeanFactory will call
        the bean through this interface to inform the bean of the
        <span class="emphasis"><em>id</em></span> it was deployed under. The callback will be
        Invoked after population of normal bean properties but before an init
        callback like <code class="literal">InitializingBean</code>'s
        <span class="emphasis"><em>afterPropertiesSet</em></span> or a custom
        init-method.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lifecycle-factorybean"></a>3.4.3.&nbsp;FactoryBean</h3></div></div></div><p>The
      <code class="literal">org.springframework.beans.factory.FactoryBean</code>
      interface is to be implemented by objects that <span class="emphasis"><em>are themselves
      factories</em></span>. The FactoryBean interface provides three methods:
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><code class="literal">Object getObject()</code>: has to return an
            instance of the object this factory creates. The instance can
            possibly be shared (depending on whether this factory returns
            singletons or prototypes).</p></li><li><p><code class="literal">boolean isSingleton()</code>: has to return
            <span class="emphasis"><em>true</em></span> if this FactoryBean returns singletons,
            <span class="emphasis"><em>false</em></span> otherwise</p></li><li><p><code class="literal">Class getObjectType()</code>: has to return
            either the object type returned by the
            <code class="literal">getObject()</code> method or <code class="literal">null</code>
            if the type isn't known in advance</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-child-bean-definitions"></a>3.5.&nbsp;Abstract and child bean definitions</h2></div></div></div><p>A bean definition potentially contains a large amount of
    configuration information, including container specific information (i.e.
    initialization method, static factory method name, etc.) and constructor
    arguments and property values. A child bean definition is a bean
    definition which inherits configuration data from a parent definition. It
    is then able to override some values, or add others, as needed. Using
    parent and child bean definitions can potentially save a lot of typing.
    Effectively, this is a form of templating.</p><p>When working with a BeanFactory programmatically, child bean
    definitions are represented by the <code class="literal">ChildBeanDefinition</code>
    class. Most users will never work with them on this level, instead
    configuring bean definitions declaratively in something like the
    XmlBeanFactory. In an XmlBeanFactory bean definition, a child bean
    definition is indicated simply by using the <code class="literal">parent</code>
    attribute, specifying the parent bean as the value of this
    attribute.</p><pre class="programlisting">&lt;bean id="inheritedTestBean" abstract="true"
    class="org.springframework.beans.TestBean"&gt;
  &lt;property name="name" value="parent"/&gt;
  &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass" class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBean" init-method="initialize"&gt;
  &lt;property name="name" value="override"/&gt;
  &lt;!-- age should inherit value of 1 from parent --&gt;
&lt;/bean&gt;</pre><p>A child bean definition will use the bean class from the parent
    definition if none is specified, but can also override it. In the latter
    case, the child bean class must be compatible with the parent, i.e. it
    must accept the parent's property values.</p><p>A child bean definition will inherit constructor argument values,
    property values and method overrides from the parent, with the option to
    add new values. If init method, destroy method and/or static factory
    method are specified, they will override the corresponding parent
    settings.</p><p>The remaining settings will <span class="emphasis"><em>always</em></span> be taken
    from the child definition: <span class="emphasis"><em>depends on</em></span>,
    <span class="emphasis"><em>autowire mode</em></span>, <span class="emphasis"><em>dependency check</em></span>,
    <span class="emphasis"><em>singleton</em></span>, <span class="emphasis"><em>lazy init</em></span>.</p><p>Note that in the example above, we have explicitly marked the parent
    bean definition as <span class="emphasis"><em>abstract</em></span> by using the
    <span class="emphasis"><em>abstract</em></span> attribute. In the case that the parent
    definition does not specify a class:</p><pre class="programlisting">&lt;bean id="inheritedTestBeanWithoutClass"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
  &lt;property name="name" value="override"/&gt;
  &lt;!-- age should inherit value of 1 from parent --&gt;
&lt;/bean&gt;</pre><p>the parent bean cannot get instantiated on its own since it is
    incomplete, and it's also considered abstract. When a definition is
    considered abstract like this (explicitly or implicitly), it's usable just
    as a pure template or abstract bean definition that will serve as parent
    definition for child definitions. Trying to use such an abstract parent
    bean on its own (by referring to it as a ref property of another bean, or
    doing an explicit getBean() call with the parent bean id, will result in
    an error. Similarly, the container's internal
    <span class="emphasis"><em>preInstantiateSingletons</em></span> method will completely
    ignore bean definitions which are considered abstract.</p><p><span class="emphasis"><em>Important Note</em></span>: Application contexts (but not
    simple bean factories) will by default pre-instantiate all singletons.
    Therefore it is important (at least for singleton beans) that if you have
    a (parent) bean definition which you intend to use only as a template, and
    this definition specifies a class, you must make sure to set the
    <span class="emphasis"><em>abstract</em></span> attribute to <span class="emphasis"><em>true</em></span>,
    otherwise the application context will actually pre-instantiate it.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-client"></a>3.6.&nbsp;Interacting with the BeanFactory</h2></div></div></div><p>A BeanFactory is essentially nothing more than the interface for an
    advanced factory capable of maintaining a registry of different beans and
    their dependencies. The BeanFactory enables you to read bean definitions
    and access them using the bean factory. When using just the BeanFactory
    you would create one and read in some bean definitions in the XML format
    as follows: </p><pre class="programlisting">InputStream is = new FileInputStream("beans.xml");
XmlBeanFactory factory = new XmlBeanFactory(is);</pre><p>Basically that's all there is to it. Using
    <code class="literal">getBean(String)</code> you can retrieve instances of your
    beans. You'll get a reference to the same bean if you defined it as a
    singleton (the default) or you'll get a new instance each time if you set
    <code class="literal">singleton</code> to <span class="emphasis"><em>false</em></span>. The
    client-side view of the BeanFactory is surprisingly simple. The
    <code class="literal">BeanFactory</code> interface has only five methods for clients
    to call: </p><div class="itemizedlist"><ul type="disc" compact><li><p><code class="literal">boolean containsBean(String)</code>: returns true
          if the BeanFactory contains a bean definition or bean instance that
          matches the given name</p></li><li><p><code class="literal">Object getBean(String)</code>: returns an instance
          of the bean registered under the given name. Depending on how the
          bean was configured by the BeanFactory configuration, either a
          singleton and thus shared instance or a newly created bean will be
          returned. A <code class="literal">BeansException</code> will be thrown when
          either the bean could not be found (in which case it'll be a
          <code class="literal">NoSuchBeanDefinitionException</code>), or an exception
          occurred while instantiating and preparing the bean</p></li><li><p><code class="literal">Object getBean(String,Class)</code>: returns a
          bean, registered under the given name. The bean returned will be
          cast to the given Class. If the bean could not be cast,
          corresponding exceptions will be thrown
          (<code class="literal">BeanNotOfRequiredTypeException</code>). Furthermore,
          all rules of the getBean(String) method apply (see above)</p></li><li><p><code class="literal">boolean isSingleton(String)</code>: determines
          whether or not the bean definition or bean instance registered under
          the given name is a singleton or a prototype. If no bean
          corresponding to the given name could not be found, an exception
          will be thrown
          (<code class="literal">NoSuchBeanDefinitionException</code>)</p></li><li><p><code class="literal">String[] getAliases(String)</code>: Return the
          aliases for the given bean name, if any were defined in the bean
          definition</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1704"></a>3.6.1.&nbsp;Obtaining a FactoryBean, not its product</h3></div></div></div><p>Sometimes there is a need to ask a BeanFactory for an actual
      FactoryBean instance itself, not the bean it produces. This may be done
      by prepending the bean id with <code class="literal">&amp;</code> when calling the
      <code class="methodname">getBean</code> method of BeanFactory (including
      ApplicationContext). So for a given FactoryBean with an id
      <code class="literal">myBean</code>, invoking <code class="literal">getBean("myBean")</code>
      on the BeanFactory will return the product of the FactoryBean, but
      invoking <code class="literal">getBean("&amp;myBean")</code> will return the
      FactoryBean instance itself.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-customizing"></a>3.7.&nbsp;Customizing beans with BeanPostProcessors</h2></div></div></div><p>A bean post-processor is a java class which implements the
    <code class="literal">org.springframework.beans.factory.config.BeanPostProcessor</code>
    interface, which consists of two callback methods. When such a class is
    registered as a post-processor with the BeanFactory, for each bean
    instance that is created by the BeanFactory, the post-processor will get a
    callback from the BeanFactory before any initialization methods
    (<span class="emphasis"><em>afterPropertiesSet</em></span> and any declared init method) are
    called, and also afterwords. The post-processor is free to do what it
    wishes with the bean, including ignoring the callback completely. A bean
    post-processor will typically check for marker interfaces, or do something
    such as wrap a bean with a proxy. Some Spring helper classes are
    implemented as bean post-processors.</p><p>It is important to know that a BeanFactory treats bean
    post-processors slightly differently than an ApplicationContext. An
    ApplicationContext will automatically detect any beans which are deployed
    into it which implement the <code class="literal">BeanPostProcessor</code>
    interface, and register them as post-processors, to be then called
    appropriately by the factory on bean creation. Nothing else needs to be
    done other than deploying the post-processor in a similar fashion to any
    other bean. On the other hand, when using plain BeanFactories, bean
    post-processors have to manually be <span class="emphasis"><em>explicitly</em></span>
    registered, with a code sequence such as the following:</p><pre class="programlisting">ConfigurableBeanFactory bf = new .....;     // create BeanFactory
   ...                       // now register some beans
// now register any needed BeanPostProcessors
MyBeanPostProcessor pp = new MyBeanPostProcessor();
bf.addBeanPostProcessor(pp);

// now start using the factory
  ...</pre><p>Since this manual registration step is not convenient, and
    ApplictionContexts are functionally supersets of BeanFactories, it is
    generally recommended that ApplicationContext variants are used when bean
    post-processors are needed.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-customizing-factory-postprocessors"></a>3.8.&nbsp;Customizing bean factories with BeanFactoryPostProcessors</h2></div></div></div><p>A bean factory post-processor is a java class which implements the
    <code class="literal">org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>
    interface. It is executed manually (in the case of the BeanFactory) or
    automatically (in the case of the ApplicationContext) to apply changes of
    some sort to an entire BeanFactory, after it has been constructed. Spring
    includes a number of pre-existing bean factory post-processors, such as
    <code class="literal">PropertyResourceConfigurer</code> and
    <code class="literal">PropertyPlaceHolderConfigurer</code>, both described below,
    and <code class="literal">BeanNameAutoProxyCreator</code>, very useful for wrapping
    other beans transactionally or with any other kind of proxy, as described
    later in this manual. The BeanFactoryPostProcessor can be used to add
    custom editors (as also mentioned in <a href="#beans-beanfactory-customeditors" title="3.9.&nbsp;Registering additional custom PropertyEditors">Section&nbsp;3.9, &#8220;Registering additional custom PropertyEditors&#8221;</a>).</p><p>In a BeanFactory, the process of applying a BeanFactoryPostProcessor
    is manual, and will be similar to this:</p><pre class="programlisting">XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
// create placeholderconfigurer to bring in some property
// values from a Properties file
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));
// now actually do the replacement
cfg.postProcessBeanFactory(factory);</pre><p><a name="beans-factory-autodetect-beanfactorypostprocessors"></a>An
    ApplicationContext will detect any beans which are deployed into it which
    implement the <code class="literal">BeanFactoryPostProcessor</code> interface, and
    automatically use them as bean factory post-processors, at the appropriate
    time. Nothing else needs to be done other than deploying these
    post-processor in a similar fashion to any other bean.</p><p>Since this manual step is not convenient, and ApplictionContexts are
    functionally supersets of BeanFactories, it is generally recommended that
    ApplicationContext variants are used when bean factory post-processors are
    needed.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-placeholderconfigurer"></a>3.8.1.&nbsp;The <code class="literal">PropertyPlaceholderConfigurer</code></h3></div></div></div><p>The <code class="literal">PropertyPlaceholderConfigurer</code>, implemented
      as a bean factory post-processor, is used to externalize some property
      values from a BeanFactory definition, into another separate file in Java
      Properties format. This is useful to allow the person deploying an
      application to customize some key properties (for example database URLs,
      usernames and passwords), without the complexity or risk of modifying
      the main XML definition file or files for the BeanFactory.</p><p>Consider a fragment from a BeanFactory definition, where a
      DataSource with placeholder values is defined:</p><p>In the example below, a datasource is defined, and we will
      configure some properties from an external Properties file. At runtime,
      we will apply a <code class="literal">PropertyPlaceholderConfigurer</code> to the
      BeanFactory which will replace some properties of the datasource:</p><pre class="programlisting">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
  &lt;property name="url" value="${jdbc.url}"/&gt;
  &lt;property name="username" value="${jdbc.username}"/&gt;
  &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;</pre><p>The actual values come from another file in Properties
      format:</p><pre class="programlisting">jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre><p>To use this with a BeanFactory, the bean factory post-processor is
      manually executed on it:</p><pre class="programlisting">XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));
cfg.postProcessBeanFactory(factory);</pre><p>Note that ApplicationContexts are able to automatically recognize
      and apply beans deployed in them which implement
      BeanFactoryPostProcessor. This means that as described here, applying
      PropertyPlaceholderConfiguer is much more convenient when using an
      ApplicationContext. For this reason, it is recommended that users
      wishing to use this or other bean factory postprocessors use an
      ApplicationContext instead of a BeanFactory.</p><p>The <code class="literal">PropertyPlaceHolderConfigurer</code> doesn't only
      look for properties in the Properties file you specify, but also checks
      against the Java System properties if it cannot find a property you are
      trying to use. This behavior can be customized by setting the
      <code class="literal">systemPropertiesMode</code> property of the configurer. It
      has three values, one to tell the configurer to always override, one to
      let it <span class="emphasis"><em>never</em></span> override and one to let it override
      only if the property cannot be found in the properties file specified.
      Please consult the JavaDoc for the PropertiesPlaceholderConfigurer for
      more information.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-overrideconfigurer"></a>3.8.2.&nbsp;The <code class="literal">PropertyOverrideConfigurer</code></h3></div></div></div><p>The <code class="literal">PropertyOverrideConfigurer</code>, another bean
      factory post-processor, is similar to the
      <code class="literal">PropertyPlaceholderConfigurer</code>, but in contrast to the
      latter, the original definitions can have default values or no values at
      all for bean properties. If an overriding Properties file does not have
      an entry for a certain bean property, the default context definition is
      used.</p><p>Note that the bean factory definition is <span class="emphasis"><em>not</em></span>
      aware of being overridden, so it is not immediately obvious when looking
      at the XML definition file that the override configurer is being used.
      In case that there are multiple PropertyOverrideConfigurers that define
      different values for the same bean property, the last one will win (due
      to the overriding mechanism).</p><p>Properties file configuration lines are expected to be in the
      format:</p><pre class="programlisting"><span class="emphasis"><em>beanName.property=value</em></span></pre><p>An example properties file could look like:</p><pre class="programlisting">dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre><p>This example file would be usable against a BeanFactory definition
      which contains a bean in it called <span class="emphasis"><em>dataSource</em></span>,
      which has <span class="emphasis"><em>driver</em></span> and <span class="emphasis"><em>url</em></span>
      properties.</p><p>Note that compound property names are also supported, as long as
      every component of the path except the final property being overriden is
      already non-null (presumably initialized by the constructors). In this
      example:</p><pre class="programlisting">foo.fred.bob.sammy=123</pre><p>the
      <code class="literal">sammy</code> property of the <code class="literal">bob</code> property
      of the <code class="literal">fred</code> property of the <code class="literal">foo</code>
      bean is being set to the scalar value 123.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beanfactory-customeditors"></a>3.9.&nbsp;Registering additional custom PropertyEditors</h2></div></div></div><p>When setting bean properties as a string value, a BeanFactory
    ultimately uses standard JavaBeans PropertyEditors to convert these
    Strings to the complex type of the property. Spring pre-registers a number
    of custom PropertyEditors (for example, to convert a classname expressed
    as a string into a real Class object). Additionally, Java's standard
    JavaBeans PropertyEditor lookup mechanism allows a PropertyEditor for a
    class to be simply named appropriately and placed in the same package as
    the class it provides support for, to be found automatically.</p><p>If there is a need to register other custom PropertyEditors, there
    are several mechanisms available.</p><p>The most manual approach, which is not normally convenient or
    recommended, is to simply use the
    <code class="literal">registerCustomEditor()</code> method of the
    <code class="literal">ConfigurableBeanFactory</code> interface, assuming you have a
    BeanFactory reference.</p><p>The more convenient mechanism is to use a special bean factory
    post-processor called <code class="literal">CustomEditorConfigurer</code>. Although
    bean factory post-processors can be used semi-manually with BeanFactories,
    this one has a nested property setup, so it is strongly recommended that,
    as described <a href="#beans-applicationcontext-customeditors" title="3.14.&nbsp;Registering additional custom PropertyEditors">here</a>, it is used
    with the ApplicationContext, where it may be deployed in similar fashion
    to any other bean, and automatically detected and applied.</p><p>Note that all bean factories and application contexts automatically
    use a number of built-in property editors, through their use of something
    called a <code class="literal">BeanWrapper</code> to handle property conversions.
    The standard property editors that the BeanWrapper registers are listed in
    the next chapter. Additionally, ApplicationContexts also override or add
    an additional 3 editors to handle resource lookups in a manner appropriate
    to the specific application context type. Thee are:
    <code class="literal">InputStreamEditor</code>, <code class="literal">ResourceEditor</code>
    and <code class="literal">URLEditor</code>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beanfactory-alias"></a>3.10.&nbsp;Using the alias element to add aliases for existing beans</h2></div></div></div><p>In a bean definition itself, you may supply more than one name for
    the bean, by using a combination of up to one name spcified via the
    <code class="literal">id</code> attribute, and any number of other names via the
    <code class="literal">alias</code> attribute. All these names can be considered
    equivalent aliases to the same bean, and are useful for some situations,
    such as allowing each component used in an application to refer to a
    common dependency using a bean name that is specific to that component
    itslef.</p><p>Having to specify all alias when the bean is actually defined is not
    always adequate however. It is sometimes desirable to introduce an alias
    for a bean which is define elsewhere. This may be done via a standalone
    <code class="literal">alias</code> element.</p><p><code class="literal"> &lt;alias name="fromName"
    alias="toName"/&gt;</code></p><p>In this case, a bean in the same context which is named
    <code class="literal">fromName</code>, may also after the use of this alias
    definition, be referred to as <code class="literal">toName</code>.</p><p>As a concrete example, consider the case where component A defines a
    DataSource bean called componentA-dataSource, in its XML fragment.
    Component B would however like to refer to the DataSource as
    componentB-dataSource in its XML fragment. And the main application,
    MyApp, defines its own XML fragment and assembles the final application
    context from all three fragments, and would like to refer to the
    DataSource as myApp-dataSource. This scenario can be easily handled by
    adding to the MyApp XML fragement the following standalone aliases:</p><p><code class="literal"> </code><code class="literal">&lt;alias name="componentA-dataSource"
    alias="componentB-dataSource"/&gt; &lt;alias name="componentA-dataSource"
    alias="myApp-dataSource"/&gt;</code></p><p>Now each component and the main app can refer to the dataSource via
    a name that is unique and guaranteed not to clash with any other
    definition (effectively there is a namespace), yet they refer to the same
    bean.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-introduction"></a>3.11.&nbsp;Introduction to the <code class="literal">ApplicationContext</code></h2></div></div></div><p>While the <code class="literal">beans</code> package provides basic
    functionality for managing and manipulating beans, often in a programmatic
    way, the <code class="literal">context</code> package adds <code class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/context/ApplicationContext.html" target="_top">ApplicationContext</a></code>,
    which enhances BeanFactory functionality in a more
    <span class="emphasis"><em>framework-oriented style</em></span>. Many users will use
    ApplicationContext in a completely declarative fashion, not even having to
    create it manually, but instead relying on support classes such as
    ContextLoader to automatically start an ApplicationContext as part of the
    normal startup process of a J2EE web-app. Of course, it is still possible
    to programmatically create an ApplicationContext.</p><p>The basis for the context package is the
    <code class="literal">ApplicationContext</code> interface, located in the
    <code class="literal">org.springframework.context</code> package. Deriving from the
    BeanFactory interface, it provides all the functionality of BeanFactory.
    To allow working in a more framework-oriented fashion, using layering and
    hierarchical contexts, the context package also provides the following:
    </p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>MessageSource</em></span>, providing access to
          messages in, i18n-style</p></li><li><p><span class="emphasis"><em>Access to resources</em></span>, such as URLs and
          files</p></li><li><p><span class="emphasis"><em>Event propagation</em></span> to beans implementing
          the <code class="literal">ApplicationListener</code> interface</p></li><li><p><span class="emphasis"><em>Loading of multiple (hierarchical)
          contexts</em></span>, allowing each to be focused on one particular
          layer, for example the web layer of an application</p></li></ul></div><p>As the ApplicationContext includes all functionality of the
    BeanFactory, it is generally recommended that it be used over the
    BeanFactory, except for a few limited situations such as perhaps in an
    Applet, where memory consumption might be critical, and a few extra
    kilobytes might make a difference. The following sections described
    functionality which ApplicationContext adds to basic BeanFactory
    capabilities.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-functionality"></a>3.12.&nbsp;Added functionality of the
    <code class="literal">ApplicationContext</code></h2></div></div></div><p>As already stated in the previous section, the ApplicationContext
    has a couple of features that distinguish it from the BeanFactory. Let us
    review them one-by-one.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-messagesource"></a>3.12.1.&nbsp;Using the <code class="literal">MessageSource</code></h3></div></div></div><p>The ApplicationContext interface extends an interface called
      <code class="literal">MessageSource</code>, and therefore provides messaging (i18n
      or internationalization) functionality. Together with the
      <code class="literal">NestingMessageSource</code>, capable of resolving
      hierarchical messages, these are the basic interfaces Spring provides to
      do message resolution. Let's quickly review the methods defined there:
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><code class="literal">String getMessage (String code, Object[] args,
            String default, Locale loc)</code>: the basic method used to
            retrieve a message from the MessageSource. When no message is
            found for the specified locale, the default message is used. Any
            arguments passed in are used as replacement values, using the
            <code class="literal">MessageFormat</code> functionality provided by the
            standard library.</p></li><li><p><code class="literal">String getMessage (String code, Object[] args,
            Locale loc)</code>: essentially the same as the previous
            method, but with one difference: no default message can be
            specified; if the message cannot be found, a
            <code class="literal">NoSuchMessageException</code> is thrown.</p></li><li><p><code class="literal">String getMessage(MessageSourceResolvable
            resolvable, Locale locale)</code>: all properties used in the
            methods above are also wrapped in a class named
            <code class="literal">MessageSourceResolvable</code>, which you can use via
            this method.</p></li></ul></div><p>When an ApplicationContext gets loaded, it automatically searches
      for a MessageSource bean defined in the context. The bean has to have
      the name <code class="literal">messageSource</code>. If such a bean is found, all
      calls to the methods described above will be delegated to the message
      source that was found. If no message source was found, the
      ApplicationContext attempts to see if it has a parent containing a bean
      with the same name. If so, it uses that bean as the MessageSource. If it
      can't find any source for messages, an empty
      <code class="literal">StaticMessageSource</code> will be instantiated in order to
      be able to accept calls to the methods defined above.</p><p>Spring currently provides two <code class="literal">MessageSource</code>
      implementations. These are the
      <code class="literal">ResourceBundleMessageSource</code> and the
      <code class="literal">StaticMessageSource</code>. Both implement
      <code class="literal">NestingMessageSource</code> in order to do nested messaging.
      The StaticMessageSource is hardly ever used but provides programmatic
      ways to add messages to the source. The ResourceBundleMessageSource is
      more interesting and is the one we will provides an example for:
      </p><pre class="programlisting">&lt;beans&gt;
  &lt;bean id="messageSource"
        class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
    &lt;property name="basenames"&gt;
      &lt;list&gt;
        &lt;value&gt;format&lt;/value&gt;
        &lt;value&gt;exceptions&lt;/value&gt;
        &lt;value&gt;windows&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt; </pre><p>This assumes you have three resource bundles defined on your
      classpath called <code class="literal">format</code>,
      <code class="literal">exceptions</code> and <code class="literal">windows</code>. Using the
      JDK standard way of resolving messages through ResourceBundles, any
      request to resolve a message will be handled. TODO: SHOW AN
      EXAMPLE</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-events"></a>3.12.2.&nbsp;Propagating events</h3></div></div></div><p>Event handling in the ApplicationContext is provided through the
      <code class="literal">ApplicationEvent</code> class and
      <code class="literal">ApplicationListener</code> interface. If a bean which
      implements the <code class="literal">ApplicationListener</code> interface is
      deployed into the context, every time an
      <code class="literal">ApplicationEvent</code> gets published to the
      ApplicationContext, that bean will be notified. Essentially, this is the
      standard <span class="emphasis"><em>Observer</em></span> design pattern. Spring provides
      three standard events: </p><div class="table"><a name="d0e2102"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Built-in Events</b></p><div class="table-contents"><table summary="Built-in Events" border="1"><colgroup><col><col></colgroup><thead><tr><th>Event</th><th>Explanation</th></tr></thead><tbody><tr><td><code class="literal">ContextRefreshedEvent</code></td><td>Event published when the ApplicationContext is
                initialized or refreshed. Initialized here means that all
                beans are loaded, singletons are pre-instantiated and the
                ApplicationContext is ready for use</td></tr><tr><td><code class="literal">ContextClosedEvent</code></td><td>Event published when the ApplicationContext is closed,
                using the <code class="literal">close()</code> method on the
                ApplicationContext. Closed here means that singletons are
                destroyed</td></tr><tr><td><code class="literal">RequestHandledEvent</code></td><td>A web-specific event telling all beans that a HTTP
                request has been serviced (i.e. this will be published
                <span class="emphasis"><em>after</em></span> the request has been finished).
                Note that this event is only applicable for web applications
                using Spring's DispatcherServlet</td></tr></tbody></table></div></div><p><br class="table-break"></p><p>Implementing custom events can be done as well. Simply call the
      <code class="literal">publishEvent()</code> method on the ApplicationContext,
      specifying a parameter which is an instance of your custom event class
      implementing ApplicationEvent. Event listeners receive events
      synchronously. This means the publishEvent() method blocks until all
      listeners have finished processing the event. Furthermore, when a
      listener receives an event it operates inside the transaction context of
      the publisher, if a transaction context is available.</p><p>Let's look at an example. First, the ApplicationContext:
      </p><pre class="programlisting">&lt;bean id="emailer" class="example.EmailBean"&gt;
  &lt;property name="blackList"&gt;
    &lt;list&gt;
      &lt;value&gt;black@list.org&lt;/value&gt;
      &lt;value&gt;white@list.org&lt;/value&gt;
      &lt;value&gt;john@doe.org&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="blackListListener" class="example.BlackListNotifier"&gt;
  &lt;property name="notificationAddress" value="spam@list.org"/&gt;
&lt;/bean&gt;</pre><p>and then, the actual beans: </p><pre class="programlisting">public class EmailBean implements ApplicationContextAware {

    /** the blacklist */
    private List blackList;
    
    public void setBlackList(List blackList) {
        this.blackList = blackList;
    }
    
    public void setApplicationContext(ApplicationContext ctx) {
        this.ctx = ctx;
    }
    
    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent evt = new BlackListEvent(address, text);
            ctx.publishEvent(evt);
            return;
        }
        // send email
    }
}

public class BlackListNotifier implement ApplicationListener {

    /** notification address */
    private String notificationAddress;
    
    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(ApplicationEvent evt) {
        if (evt instanceof BlackListEvent) {
            // notify appropriate person
        }
    }
}</pre><p>Of course, this particular example could probably be
      implemented in better ways (perhaps by using AOP features), but it
      should be sufficient to illustrate the basic event mechanism.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-resources"></a>3.12.3.&nbsp;Low-level resources and the application context</h3></div></div></div><p>For optimal usage and understanding of application contexts, users
      should generally familiarize themselves with Spring's
      <code class="literal">Resource</code> abstraction, as described in <a href="#resources" title="Chapter&nbsp;4.&nbsp;Abstracting Access to Low-Level Resources">Chapter&nbsp;4, <i>Abstracting Access to Low-Level Resources</i></a>.</p><p>An application context is a <code class="literal">ResourceLoader</code>,
      able to be used to load <code class="literal">Resource</code>s. A
      <code class="literal">Resource</code> is essentially a
      <code class="literal">java.net.URL</code> on steroids (in fact, it just wraps and
      uses a URL where appropriate), which can be used to obtain low-level
      resources from almost any location in a transparent fashion, including
      from the classpath, a filesystem location, anywhere describable with a
      standard URL, and some other variations. If the resource location string
      is a simple path without any special prefixes, where those resources
      come from is specific and appropriate to the actual application context
      type.</p><p>A bean deployed into the application context may implement the
      special marker interface, <code class="literal">ResourceLoaderAware</code>, to be
      automatically called back at initialization time with the application
      context itself pased in as the <code class="literal">ResourceLoader</code>.</p><p>A bean may also expose properties of type
      <code class="literal">Resource</code>, to be used to access static resources, and
      expect that they will be injected into it like any other properties. The
      person deploying the bean may specify those <code class="literal">Resource</code>
      properties as simple String paths, and rely on a special JavaBean
      PropertyEditor that is automatically registerd by the context, to
      convert those text strings to actual <code class="literal">Resource</code>
      objects.</p><p>The location path or paths supplied to an ApplicationContext
      constructor are actually resource strings, and in simple form are
      treated appropriately to the specific context implementation (i.e.
      ClassPathXmlApplicationContext treats a simple location path as a
      classpath location), but may also be used with special prefixes to force
      loading of definitions from the classpath or a URL, regardless of the
      actual context type.</p><p>The previously mentioned chapter provides much more information on
      these topics.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-context-customization"></a>3.13.&nbsp;Customized behavior in the ApplicationContext</h2></div></div></div><p>The BeanFactory already offers a number of mechanisms to control the
    lifecycle of beans deployed in it (such as marker interfaces like
    <code class="literal">InitializingBean</code> or <code class="literal">DisposableBean</code>,
    their configuration only equivalents such as the
    <code class="literal">init-method</code> and <code class="literal">destroy-method</code>
    attributes in an XmlBeanFactory config, and bean post-processors. In an
    ApplicationContext, all of these still work, but additional mechanisms are
    added for customizing behavior of beans and the container.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-context-applicationcontextaware"></a>3.13.1.&nbsp;<code class="literal">ApplicationContextAware</code> marker
      interface</h3></div></div></div><p>All marker interfaces available with BeanFactories still work. The
      ApplicationContext does add one extra marker interface which beans may
      implement,
      <code class="literal">org.springframework.context.ApplicationContextAware</code>.
      A bean which implements this interface and is deployed into the context
      will be called back on creation of the bean, using the interface's
      <code class="literal">setApplicationContext()</code> method, and provided with a
      reference to the context, which may be stored for later interaction with
      the context.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-context-beanpostprocessor"></a>3.13.2.&nbsp;The <code class="literal">BeanPostProcessor</code></h3></div></div></div><p>Bean post-processors, java classes which implement the
      <code class="literal">org.springframework.beans.factory.config.BeanPostProcessor</code>
      interface, have <a href="#beans-factory-customizing" title="3.7.&nbsp;Customizing beans with BeanPostProcessors">already</a>
      been mentioned. It is worth mentioning again here though, that
      post-processors are much more convenient to use in ApplicationContexts
      than in plain BeanFactories. In an ApplicationContext, any deployed bean
      which implements the above marker interface is automatically detected
      and registered as a bean post-processor, to be called appropriately at
      creation time for each bean in the factory.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-context-beanfactorypostprocessor"></a>3.13.3.&nbsp;The <code class="literal">BeanFactoryPostProcessor</code></h3></div></div></div><p>Bean factory post-processors, java classes which implement the
      <code class="literal">org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>
      interface, have <a href="#beans-factory-customizing-factory-postprocessors" title="3.8.&nbsp;Customizing bean factories with BeanFactoryPostProcessors">already</a>
      been mentioned. It is worth mentioning again here though, that bean
      factory post-processors are much more convenient to use in
      ApplicationContexts than in plain BeanFactories. In an
      ApplicationContext, any deployed bean which implements the above marker
      interface is automatically detected as a bean factory post-processor, to
      be called at the appropriate time.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-context-placeholderconfigurer"></a>3.13.4.&nbsp;The <code class="literal">PropertyPlaceholderConfigurer</code></h3></div></div></div><p>The <code class="literal">PropertyPlaceholderConfigurer</code> has <a href="#beans-factory-placeholderconfigurer" title="3.8.1.&nbsp;The PropertyPlaceholderConfigurer">already</a> been
      described, as used with a BeanFactory. It is worth mentioning here
      though, that it is generally more convenient to use it with an
      ApplicationContext, since the context will automatically recognize and
      apply any bean factory post-processors, such as this one, when they are
      simply deployed into it like any other bean. There is no need for a
      manual step to execute it.</p><pre class="programlisting">&lt;!-- property placeholder post-processor --&gt;
&lt;bean id="placeholderConfig"
      class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
  &lt;property name="location" value="jdbc.properties"/&gt;
&lt;/bean&gt;</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-applicationcontext-customeditors"></a>3.14.&nbsp;Registering additional custom PropertyEditors</h2></div></div></div><p>As <a href="#beans-beanfactory-customeditors" title="3.9.&nbsp;Registering additional custom PropertyEditors">previously</a>
    mentioned, standard JavaBeans PropertyEditors are used to convert property
    values expressed as strings to the actual complex type of the property.
    <code class="literal">CustomEditorConfigurer</code>, a bean factory post-processor,
    may be used to conveniently add support for additional PropertyEditors to
    an ApplicationContext.</p><p>Consider a user class <span class="emphasis"><em>ExoticType</em></span>, and another
    class <span class="emphasis"><em>DependsOnExoticType</em></span> which needs ExoticType set
    as a property:</p><pre class="programlisting">public class ExoticType {
    private String name;
    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType {    
    private ExoticType type;
    public void setType(ExoticType type) {
        this.type = type;
    }
}</pre><p>When things are properly set up, we want to be able to
    assign the type property as a string, which a PropertyEditor will behind
    the scenes convert into a real ExoticType object.: </p><pre class="programlisting">&lt;bean id="sample" class="example.DependsOnExoticType"&gt;
    &lt;property name="type"&gt;&lt;value&gt;aNameForExoticType&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The PropertyEditor could look similar to this:
    </p><pre class="programlisting">// converts string representation to ExoticType object
public class ExoticTypeEditor extends PropertyEditorSupport {

    private String format;

    public void setFormat(String format) {
        this.format = format;
    }
    
    public void setAsText(String text) {
        if (format != null &amp;&amp; format.equals("upperCase")) {
            text = text.toUpperCase();
        }
        ExoticType type = new ExoticType(text);
        setValue(type);
    }
}</pre><p>Finally, we use <code class="literal">CustomEditorConfigurer</code> to
    register the new PropertyEditor with the ApplicationContext, which will
    then be able to use it as needed.: </p><pre class="programlisting">&lt;bean id="customEditorConfigurer" 
    class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
  &lt;property name="customEditors"&gt;
    &lt;map&gt;
      &lt;entry key="example.ExoticType"&gt;
        &lt;bean class="example.ExoticTypeEditor"&gt;
          &lt;property name="format" value="upperCase"/&gt;
        &lt;/bean&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2303"></a>3.15.&nbsp;Setting a bean property or constructor arg from a property
    expression</h2></div></div></div><p><code class="literal">PropertyPathFactoryBean</code> is a
    <code class="literal">FactoryBean</code> that evaluates a property path on a given
    target object. The target object can be specified directly or via a bean
    name. This value may then be used in another bean definition as a property
    value or constructor argument.</p><p>Here's an example where a path is used against another bean, by
    name:</p><pre class="programlisting">// target bean to be referenced by name
&lt;bean id="person" class="org.springframework.beans.TestBean" singleton="false"&gt;
  &lt;property name="age"&gt;&lt;value&gt;10&lt;/value&gt;&lt;/property&gt;
  &lt;property name="spouse"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age"&gt;&lt;value&gt;11&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

// will result in 11, which is the value of property 'spouse.age' of bean 'person'
&lt;bean id="theAge" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
  &lt;property name="targetBeanName"&gt;&lt;value&gt;person&lt;/value&gt;&lt;/property&gt;
  &lt;property name="propertyPath"&gt;&lt;value&gt;spouse.age&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>In this example, a path is evaluated against an inner bean:</p><pre class="programlisting">// will result in 12, which is the value of property 'age' of the inner bean
&lt;bean id="theAge" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
  &lt;property name="targetObject"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age"&gt;&lt;value&gt;12&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="propertyPath"&gt;&lt;value&gt;age&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p> There is also a shortcut form, where the bean
    name is the property path.</p><pre class="programlisting">// will result in 10, which is the value of property 'age' of bean 'person'
&lt;bean id="person.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</pre><p>This form does mean that there is no choice in the name of the bean,
    any reference to it will also have to use the same id, which is the path.
    Of curse, if used as an inner bean, there is no need to refer to it at
    all:</p><pre class="programlisting">&lt;bean id="..." class="..."&gt;
  &lt;property name="age"&gt;
    &lt;bean id="person.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The result type may be specifically set in the
    actual definition. This is not necessary for most use cases, but can be of
    use for some. Please see the JavaDocs for more info on this
    feature.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2331"></a>3.16.&nbsp;Setting a bean property or constructor arg from a field
    value</h2></div></div></div><p>FieldRetrievingFactoryBean is a FactoryBean which retrieves a static
    or non-static field value. It is typically used for retrieving public
    static final constants, which may then be used to set a property value or
    constructor arg for another bean.</p><p>Here's an example which shows how a static field is exposed, by
    using the staticField property:</p><pre class="programlisting">&lt;bean id="myField"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"&gt;
  &lt;property name="staticField"&gt;&lt;value&gt;java.sql.Connection.TRANSACTION_SERIALIZABLE&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>There's also a convenience usage form where the static field is
    specified as a bean name:</p><pre class="programlisting">&lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
      class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;</pre><p>This means there is no longer any choice in what the bean id is (so
    any other bean that refers to it will also have to use this longer name),
    but this form is very concise to define, and very convenient to use as an
    inner bean since the id doesn't have to be specified for the bean
    reference:</p><pre class="programlisting">&lt;bean id="..." class="..."&gt;
  &lt;property name="isolation"&gt;
    &lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>It's also possible to access a non-static field
    of another bean, as described in the JavaDocs.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2351"></a>3.17.&nbsp;Invoking another method and optionally using the return
    value.</h2></div></div></div><p>it is sometimes necessary to call a static or non-static method in
    one class, just to perform some sort of initialization, before some other
    class is used. Additionally, it is sometimes necessary to set a property
    on a bean, as the result of a method call on another bean in the
    container, or a static method call on any arbitrary class. For both of
    these purposes, a helper class called
    <code class="classname">MethodInvokingFactoryBean</code> may be used. This is a
    <code class="literal"><code class="classname">FactoryBean</code></code> which returns a
    value which is the result of a static or instance method
    invocation.</p><p>We would however recommend that for the second use case,
    factory-methods, described previously, are a better all around
    choice.</p><p>An example (in an XML based BeanFactory definition) of a bean
    definition which uses this class to force some sort of static
    initialization:</p><pre class="programlisting">&lt;bean id="force-init" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="staticMethod"&gt;&lt;value&gt;com.example.MyClass.initialize&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="bean1" class="..." depends-on="force-init"&gt;
  ...
&lt;/bean&gt;</pre><p>Note that the definition for
    <code class="literal">bean1</code> has used the <code class="literal">depends-on</code>
    attribute to refer to the <code class="literal">force-init</code> bean, which will
    trigger initializing <code class="literal">force-init</code> first, and thus calling
    the static initializer method, when <code class="literal">bean1</code> is first
    initialized.</p><p>Here's an example of a bean definition which uses this class to call
    a static factory method:</p><pre class="programlisting">&lt;bean id="myClass" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="staticMethod"&gt;&lt;value&gt;com.whatever.MyClassFactory.getInstance&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>An example of calling a static method then an instance method to get
    at a Java System property. Somewhat verbose, but it works.</p><pre class="programlisting">&lt;bean id="sysProps" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetClass"&gt;&lt;value&gt;java.lang.System&lt;/value&gt;&lt;/property&gt;
  &lt;property name="targetMethod"&gt;&lt;value&gt;getProperties&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="javaVersion" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetObject"&gt;&lt;ref local="sysProps"/&gt;&lt;/property&gt;
  &lt;property name="targetMethod"&gt;&lt;value&gt;getProperty&lt;/value&gt;&lt;/property&gt;
  &lt;property name="arguments"&gt;
    &lt;list&gt;
      &lt;value&gt;java.version&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that as it is expected to be used mostly for accessing factory
    methods, MethodInvokingFactoryBean by default operates in a
    <span class="emphasis"><em>singleton</em></span> fashion. The first request by the container
    for the factory to produce an object will cause the specified method
    invocation, whose return value will be cached and returned for the current
    and subsequent requests. An internal <code class="literal">singleton</code> property
    of the factory may be set to false, to cause it to invoke the target
    method each time it is asked for an object.</p><p>A static target method may be specified by setting the
    <code class="literal">targetMethod</code> property to a String representing the
    static method name, with <code class="literal">targetClass</code> specifying the
    Class that the static method is defined on. Alternatively, a target
    instance method may be specified, by setting the
    <code class="literal">targetObject</code> property as the target object, and the
    <code class="literal">targetMethod</code> property as the name of the method to call
    on that target object. Arguments for the method invocation may be
    specified by setting the <code class="literal">arguments</code> property.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-import"></a>3.18.&nbsp;Importing Bean Definitions from One File Into Another</h2></div></div></div><p>It's often useful to split up container definitions into multiple
    XML files. One way to then load an application context which is configured
    from all these XML fragments is to use the application context constructor
    which takes multiple Resource locations. With a bean factory, a bean
    definition reader can be used multiple times to read definitions from each
    file in turn.</p><p>Generally, the Spring team prefers the above approach, since it
    keeps container configurations files unaware of the fact that they are
    being combined with others. However, an alternate approach is to from one
    XML bean definition file, use one or more instances of the
    <code class="literal">import</code> element to load definitions from one or more
    other files. Any <code class="literal">import</code> elements must be placed before
    <code class="literal">bean</code> elements in the file doing the importing. Let's
    look at a sample:</p><pre class="programlisting">&lt;beans&gt;

  &lt;import resource="services.xml"/&gt;

  &lt;import resource="resources/messageSource.xml"/&gt;

  &lt;import resource="/resources/themeSource.xml"/&gt;

  &lt;bean id="bean1" class="..."/&gt;

  &lt;bean id="bean2" class="..."/&gt;
  . . .</pre><p>In this example, external bean definitions are being loaded from 3
    files, <code class="literal">services.xml</code>,
    <code class="literal">messageSource.xml</code>, and
    <code class="literal">themeSource.xml</code>. All location paths are considered
    relative to the definition file doing the importing, so
    <code class="literal">services.xml</code> in this case must be in the same directory
    or classpath location as the file doing the importing, while
    <code class="literal">messageSource.xml</code> and
    <code class="literal">themeSource.xml</code> must be in a
    <code class="literal">resources</code> location below the location of the importing
    file. As you can see, a leading slash is actually ignored, but given that
    these are considered relative paths, it is probably better form not to use
    the slash at all.</p><p>The contents of the files being imported must be fully valid XML
    bean definition files according to the DTD, including the top level
    <code class="literal">beans</code> element.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-create"></a>3.19.&nbsp;Creating an ApplicationContext from a web application</h2></div></div></div><p>As opposed to the BeanFactory, which will often be created
    programmatically, ApplicationContexts can be created declaratively using
    for example a <code class="literal">ContextLoader</code>. Of course you can also
    create ApplicationContexts programmatically using one of the
    ApplicationContext implementations. First, let's examine the ContextLoader
    and its implementations.</p><p>The ContextLoader has two implementations: the
    <code class="literal">ContextLoaderListener</code> and the
    <code class="literal">ContextLoaderServlet</code>. They both have the same
    functionality but differ in that the listener cannot be used in Servlet
    2.2 compatible containers. Since the Servlet 2.4 specification, listeners
    are required to initialize after startup of a web application. A lot of
    2.3 compatible containers already implement this feature. It is up to you
    as to which one you use, but all things being equal you should probably
    prefer <code class="literal">ContextLoaderListener</code>; for more information on
    compatibility, have a look at the JavaDoc for the
    <code class="literal">ContextLoaderServlet</code>.</p><p>You can register an ApplicationContext using the
    <code class="literal">ContextLoaderListener</code> as follows: </p><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!-- OR USE THE CONTEXTLOADERSERVLET INSTEAD OF THE LISTENER
&lt;servlet&gt;
  &lt;servlet-name&gt;context&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
--&gt;</pre><p> The listener inspects the
    <code class="literal">contextConfigLocation</code> parameter. If it doesn't exist,
    it'll use <code class="literal">/WEB-INF/applicationContext.xml</code> as a default.
    When it <span class="emphasis"><em>does</em></span> exist, it'll separate the String using
    predefined delimiters (comma, semi-colon and space) and use the values as
    locations where application contexts will be searched for. The
    ContextLoaderServlet can - as said - be used instead of the
    ContextLoaderListener. The servlet will use the contextConfigLocation
    parameter just as the listener does.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2507"></a>3.20.&nbsp;Glue code and the evil singleton</h2></div></div></div><p>The majority of the code inside an application is best written in a
    Dependency Injection (Inversion of Control) style, where that code is
    served out of a BeanFactory or ApplicationContext container, has its own
    dependencies supplied by the container when it is created, and is
    completely unaware of the container. However, for the small glue layers of
    code that are sometimes needed to tie other code together, there is
    sometimes a need for singleton (or quasi-singleton) style access to a
    BeanFactory or ApplicationContext. For example, third party code may try
    to construct new objects directly (<code class="literal">Class.forName()</code>
    style), without the ability to force it to get these objects out of a
    BeanFactory. If the object constructed by the third party code is just a
    small stub or proxy, which then uses a singleton style access to a
    BeanFactory/ApplicationContext to get a real object to delegate to, then
    inversion of control has still been achieved for the majority of the code
    (the object coming out of the BeanFactory); thus most code is still
    unaware of the container or how it is accessed, and remains uncoupled from
    other code, with all ensuing benefits. EJBs may also use this stub/proxy
    approach to delegate to a plain java implementation object, coming out of
    a BeanFactory. While the BeanFactory ideally does not have to be a
    singleton, it may be unrealistic in terms of memory usage or
    initialization times (when using beans in the BeanFactory such as a
    Hibernate SessionFactory) for each bean to use its own, non-singleton
    BeanFactory.</p><p>As another example, in a complex J2EE apps with multiple layers
    (i.e. various JAR files, EJBs, and WAR files packaged as an EAR), with
    each layer having its own ApplicationContext definition (effectively
    forming a hierarchy), the preferred approach when there is only one
    web-app (WAR) in the top hierarchy is to simply create one composite
    ApplicationContext from the multiple XML definition files from each layer.
    All the ApplicationContext variants may be constructed from multiple
    definition files in this fashion. However, if there are multiple sibling
    web-apps at the top of the hierarchy, it is problematic to create an
    ApplicationContext for each web-app which consists of mostly identical
    bean definitions from lower layers, as there may be issues due to
    increased memory usage, issues with creating multiple copies of beans
    which take a long time to initialize (i.e. a Hibernate SessionFactory),
    and possible issues due to side-effects. As an alternative, classes such
    as <code class="literal"><a href="???" target="_top">ContextSingletonBeanFactoryLocator</a></code> or
    <code class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a></code>
    may be used to demand load multiple hierarchical (i.e. one is a parent of
    another) BeanFactories or ApplicationContexts in an effectively singleton
    fashion, which may then be used as the parents of the web-app
    ApplicationContexts. The result is that bean definitions for lower layers
    are loaded only as needed, and loaded only once.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2525"></a>3.20.1.&nbsp;Using SingletonBeanFactoryLocator and
      ContextSingletonBeanFactoryLocator</h3></div></div></div><p>You can see a detailed example of using <code class="literal"><a href="http://www.springframework.org/docs/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a></code>
      and <code class="literal"><a href="???" target="_top">ContextSingletonBeanFactoryLocator</a></code> by
      viewing their respective JavaDocs.</p><p>As mentioned in the chapter on EJBs, the Spring convenience base
      classes for EJBs normally use a non-singleton
      <code class="literal">BeanFactoryLocator</code> implementation, which is easily
      replaced by the use of <code class="literal">SingletonBeanFactoryLocator</code>
      and <code class="literal">ContextSingletonBeanFactoryLocator</code> if there is a
      need.</p></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e1266" href="#d0e1266">1</a>] </sup>See <a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Setting bean properties and collaborators">Section&nbsp;3.3.1, &#8220;Setting bean properties and collaborators&#8221;</a></p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="resources"></a>Chapter&nbsp;4.&nbsp;Abstracting Access to Low-Level Resources</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2552"></a>4.1.&nbsp;Overview</h2></div></div></div><p>Java's standard <code class="literal">java.net.URL</code> interface and
    istandard handlers for vairous URL prefixes are unfortunately not quite
    adequate enough for all access to low-level resources. There is for
    example no standardized <code class="literal">URL</code> implementation which may be
    used to access a resource that needs to be obtained from somewhere on the
    classpath, or relative to a <code class="literal">ServletContext</code>, for
    example. While it is possible to register new handlers for specialized URL
    prefixes (similar to existing handlers for prefixes such as
    <code class="literal">http:</code>), this is generally quite complicated, and the
    <code class="literal">URL</code> interface still lacks some desireable
    functionality, such as a method to check the existence of the resource
    being pointed to.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2572"></a>4.2.&nbsp;The <code class="literal">Resource</code> interface</h2></div></div></div><p>Spring's <code class="literal">Resource</code> interface is meant to be a more
    capable interface for abstracting access to low-level resources.</p><pre class="programlisting">public interface Resource extends InputStreamSource {

    boolean exists();

    boolean isOpen();

    URL getURL() throws IOException;

    File getFile() throws IOException;

    Resource createRelative(String relativePath) throws IOException;

    String getFilename();

    String getDescription();
}

public interface InputStreamSource {

    InputStream getInputStream() throws IOException;

}</pre><p>Some of the most important methods are:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">getInputStream()</code>: locates and opens the
        resource, returning an <code class="literal">InputStream</code> for reading it.
        It is expected that each invocation returns a fresh
        <code class="literal">InputStream</code>. It is the responsibility of the caller
        to close the stream.</p></li><li><p><code class="literal">exists()</code>: returns a boolean indicating
        whether this resource actually exists in physical form</p></li><li><p><code class="literal">isOpen()</code>: returns a boolean indicating
        whether this resource represents a handle with an open stream. If
        true, the <code class="literal">InputStream</code> cannot be read multiple
        times, and must be read once only and then closed to avoid resource
        leaks. Will be false for all usual resource implementations, with the
        exception of <code class="literal">InputStreamResource</code>.</p></li><li><p><code class="literal">getDescription()</code>: returns a description for
        this resource, to be used for error output when working with the
        resource. This is often the fully qualified file name or the actual
        URL</p></li></ul></div><p>Other methods allow you to obtain an actual URL or File object
    representing the resource, if the underlaying implementation is
    compatible, and supports that functionality.</p><p><code class="literal">Resource</code> is used extensively in Spring itself, as
    an argument type in many method signatures when a resource is needed.
    Other methods in some Spring APIs (such as the constructors to various
    <code class="literal">ApplicationContext</code> implementations), take a
    <code class="literal">String</code> which in unadorned or simple form is used to
    create a <code class="literal">Resource</code> appropriate to that context
    implementation, or via special prefixes on the <code class="literal">String</code>
    path, allow the caller to specify that a specific
    <code class="literal">Resource</code> implementation should be created and used.
    Internally, a JavaBeans <code class="literal">PropertyEditor</code> is used to
    convert the <code class="literal">String</code> to the appropriate
    <code class="literal">Resource</code> type, but this is irrelevant to the
    user.</p><p>While <code class="literal">Resource</code> is used a lot with Spring and by
    Spring, it's actually very useful to use as a general utility class by
    itself in your own code, for access to resources, even when your code
    doesn't know or care about any other parts of Spring. While this couples
    your code to Spring, it really only couples it to this small set of
    utility classes, which are serving as a more capable replacement for
    <code class="literal">URL</code>, and can be considered equivalent to any other
    library you would use for this purpose.</p><p>It's important to note that Resource doesn't replace functionality,
    it wraps it where possible. For example, a UrlResource wraps a URL, and
    uses the wrapped URL to do its work.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2660"></a>4.3.&nbsp;Built-in Resource implementations</h2></div></div></div><p>There are a number of built-in Resource implementations.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2665"></a>4.3.1.&nbsp;<code class="literal">UrlResource</code></h3></div></div></div><p>This wraps a java.net.URL, and may be used to access any object
      that is normally accessible via a URL, such as files, an http target, an
      ftp target, etc. All URLs have a standardized String representation,
      such that appropriate standardized prefixes are used to indicate one URL
      type vs. another. This includes <code class="literal">file:</code> for accessing
      filesystem paths, <code class="literal">http:</code> for accessing resources via
      the HTTP protocol, <code class="literal">ftp:</code> for accessing resources via
      ftp, etc.</p><p>A <code class="literal">UrlResource</code> is created by Java code
      explicitly using the <code class="literal">UrlResource</code> constructor, but
      will often be created implicitly when you call an API method which takes
      a <code class="literal">String</code> argument which is meant to represent a path.
      For the latter case, a JavaBeans <code class="literal">PropertyEditor</code> will
      ultimately decide which type of Resource to create. If the path string
      contains a few well-known (to it, that is) prefixes such as
      <code class="literal">classpath:</code>, it will create an appropriate specialized
      <code class="literal">Resource</code> for that prefix. However, if it doesn't
      recognize the prefiix, it will assume the this is just a standard URL
      string, and will create a <code class="literal">UrlResource</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2703"></a>4.3.2.&nbsp;<code class="literal">ClassPathResource</code></h3></div></div></div><p>This class represents a resource which should be obtained from the
      classpath. This uses either the thread context class loader, a given
      class loader, or a given class for loading resources.</p><p>This implementation of <code class="literal">Resource</code> supports
      resolution as <code class="literal">java.io.File</code> if the class path resource
      resides in the file system, but not for classpath resources which reside
      in a jar and have not been expanded (by the servlet engine, or whatever
      the environment is) to the filesystem. It always supports resolution as
      <code class="literal">java.net.URL</code>.</p><p>A <code class="literal">ClassPathResource</code> is created by Java code
      explicitly using the <code class="literal">ClassPathResource</code> constructor,
      but will often be created implicitly when you call an API method which
      takes a <code class="literal">String</code> argument which is meant to represent a
      path. For the latter case, a JavaBeans <code class="literal">PropertyEditor</code>
      will recognize the special prefix <code class="literal">classpath:</code>on the
      string path, and create a <code class="literal">ClassPathResource</code> in that
      case.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2740"></a>4.3.3.&nbsp;<code class="literal">FileSystemResource</code></h3></div></div></div><p>This is a <code class="literal">Resource</code> implementation for
      <code class="literal">java.io.File</code> handles. It obviously supports
      resolution as a <code class="literal">File</code>, and as a
      <code class="literal">URL</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2758"></a>4.3.4.&nbsp;<code class="literal">ServletContextResource</code></h3></div></div></div><p>This is a <code class="literal">Resource</code> implementation for
      ServletContext resources, interpreting relative paths within the web
      application root directory.</p><p>This always supports stream access and URL access, but only allows
      <code class="literal">java.io.File</code> access when the web application archive
      is expanded and the resource is physically on the filesystem. Whether or
      not it's expanded and on the filesystem like this, or accessed directly
      from the JAR or somewhere else like a DB (it's conceivable) is actually
      dependent on the Servlet container.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2772"></a>4.3.5.&nbsp;<code class="literal">InputStreamResource</code></h3></div></div></div><p>A <code class="literal">Resource</code> implementation for a given
      InputStream. This should only be used if no specific Resource
      implementation is applicable. In particular, prefer ByteArrayResource or
      any of the file-based Resource implementations where possible..</p><p>In contrast to other Resource implementations, this is a
      descriptor for an <span class="emphasis"><em>already</em></span> opened resource -
      therefore returning "true" from <code class="literal">isOpen()</code>. Do not use
      it if you need to keep the resource descriptor somewhere, or if you need
      to read a stream multiple times.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2789"></a>4.3.6.&nbsp;<code class="literal">ByteArrayResource</code></h3></div></div></div><p>This is a <code class="literal">Resource</code> implementation for a given
      byte array. It creates <code class="literal">ByteArrayInputStreams</code> for the
      given byte array.</p><p>It's useful for loading content from any given byte array, without
      having to resort to a single-use InputStreamResource.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2803"></a>4.4.&nbsp;The <code class="literal">ResourceLoader</code> Interface</h2></div></div></div><p>The <code class="literal">ResourceLoader</code> interface is meant to be
    implemented by objects that can return (i.e load)
    <code class="literal">Resources</code>.</p><pre class="programlisting">public interface ResourceLoader {
    Resource getResource(String location);
}</pre><p>All application contexts implement
    <code class="literal">ResourceLoader</code> therefore all application contexts may
    be used to obtain <code class="literal">Resource</code>s.</p><p>When you call <code class="literal">getResource()</code> on a specific
    application context, and the location path specified doesn't have a
    specific prefix, you will get back a Resource type that is appropriate to
    that particular application context. For example, if you ask a
    ClassPathXmlApplicationContext</p><pre class="programlisting">    Resource template = ctx.getResource("some/resource/path/myTemplate.txt);</pre><p>you'll
    get back a <code class="literal">ClassPathResource</code>, but if the same method is
    called on a FileSystemXmlApplicationContext, you'd get back a
    FileSystemResource. For a <code class="literal">WebApplicationContext</code>, you'd
    get a <code class="literal">ServletContextResource</code>, and so on.</p><p>As such, you can load resources in a fashion appropriate to the
    particular application context.</p><p>On the other hand, you may also force ClassPathResource to be used,
    regardless of the application context type, by specifying the special
    classpath: prefix:</p><pre class="programlisting">    Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt);</pre><p>or
    force a UrlResource to be used by specifyng any of the standard
    java.net.URL prefixes:</p><pre class="programlisting">    Resource template = ctx.getResource("file:/some/resource/path/myTemplate.txt);</pre><pre class="programlisting">    Resource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt);</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2858"></a>4.5.&nbsp;The <code class="literal">ResourceLoaderAware</code> interface</h2></div></div></div><p>The <code class="literal">ResourceLoaderAware</code> interface is a special
    marker interface, for objects that expect to be provided with a
    ResourceLoader:</p><pre class="programlisting">public interface ResourceLoaderAware {
   void setResourceLoader(ResourceLoader resourceLoader);
}</pre><p>When a bean implements
    <code class="literal">ResourceLoaderAware</code> and is deployed into an application
    context, it is recognized by the application context and called back by
    it, with the application context itself passed in as the
    <code class="literal">ResourceLoader</code> argument.</p><p>Of course, since an <code class="literal">ApplicationContext</code> is a
    <code class="literal">ResourceLoader</code>, the bean could also implement
    ApplicationContextAware and use the passed in context directly to load
    resources, but in general, it's better to use the specialized
    ResourceLoader interface if that's all that's needed, as there is less of
    a degree of coupling to Spring. The code would just be coupled to the
    resource loading interface, which can be considered a utility interface,
    not the whole context interface.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2887"></a>4.6.&nbsp;Setting <code class="literal">Resource</code>s as properties</h2></div></div></div><p>If the bean itself is going to determine and supply the resource
    path through some sort of dynamic process it probably makes sense for the
    bean to use the <code class="literal">ResourceLoader</code> interface to load
    resources. Consider as an example the loading of a template of some sort,
    where the specific one needed that depends on the role of the user. If on
    the other hand the resources are static, it makes sense to eliminate the
    use of the ResourceLoader interface completely, and just have the bean
    expose the <code class="literal">Resource</code> properties it needs, and expect
    that they will be injected into it.</p><p>What makes it trivial to then inject these properties, is that all
    application contexts register and use a special JavaBeans PropertyEditor
    which can convert String paths to <code class="literal">Resource</code> objects. So
    if myBean has a template property of type Resource, it can be configured
    with a text string for that resource, as follows:</p><pre class="programlisting">&lt;bean id="myBean" class="..."&gt;
  &lt;property name="template" value="some/resource/path/myTemplate.txt"/&gt;
&lt;/bean&gt;</pre><p>Note that the resource path has no prefix, so
    because the application context itself is going to be used as the
    <code class="literal">ResourceLoader</code>, the resource itself will be loaded via
    a <code class="literal">ClassPathResource</code>,
    <code class="literal">FileSystemResource</code>,
    <code class="literal">ServletContextResource</code>, etc., as appropriate depending
    on the type of the context.</p><p>If there is a need to force a specifc <code class="literal">Resource</code>
    type to be used, then a prefix may be used. The following two examples
    show how to force a <code class="literal">ClassPathResource</code> and a
    <code class="literal">UrlResource</code> (the latter being used to access a
    filesystem file).</p><pre class="programlisting">  &lt;property name="template" value="classpath:some/resource/path/myTemplate.txt"/&gt;
</pre><pre class="programlisting">  &lt;property name="template" value="file:/some/resource/path/myTemplate.txt"/&gt;
</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2938"></a>4.7.&nbsp;Application contexts and <code class="literal">Resource</code> paths</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2944"></a>4.7.1.&nbsp;Constructing application contexts</h3></div></div></div><p>An application context constuctor (for a specific application
      context type) generally takes a string or array of strings as the
      location path(s) of the resource(s) such as XML files that make up the
      definition of the context.</p><p>When such a location path doesn't have a prefix, the specific
      Resource type built from that path and used to load the definiton,
      depends on and is appropriate to the specific application context. For
      example, if you create a ClassPathXmlApplicationContext as
      follows:</p><pre class="programlisting">ApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");</pre><p>then the definition will be loaded from the classpath, as a
      ClassPathResource will be used. But if you create a
      FilleSystemXmlApplicationContext as follows:</p><pre class="programlisting">ApplicationContext ctx =
    new FileSystemClassPathXmlApplicationContext("conf/appContext.xml");</pre><p>then the definition will be loaded from a filesystem location, in
      this case relative to the current working directory.</p><p>Note that the use of the special classpath prefix or a standard
      URL prefix on the location path will override the default type of
      <code class="literal">Resource</code> created to load the definition. So this
      <code class="literal">FileSystemXmlApplicationContext</code></p><pre class="programlisting">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");</pre><p>will
      actually load its definition from the classpath. However, it's still a
      <code class="literal">FileSystemXmlApplicationContext</code>. If it's subsequently
      used as a <code class="literal">ResourceLoader</code>, any unprefixed paths are
      still treated as filesystem paths.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2977"></a>4.7.2.&nbsp;The <code class="literal">classpath*:</code> prefix</h3></div></div></div><p>When constructing an XML-based application context, a location
      string may use the special classpath*: prefix:</p><pre class="programlisting">ApplicationContext ctx =
    new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");</pre><p>This
      special prefix specifies that all classpath resources that match the
      gven name should be obtained (internally, this essentially happens via a
      <code class="literal">ClassLoader.getResources(...)</code> call), and then merged
      to form the final application context definition.</p><p>One use for this mechanism is when doing component-style
      application assembly. All components can 'publish' context definition
      fragments to a well-known location path, and when the final application
      context is created using the same path prefixed via
      <code class="literal">classpath*</code>:, all component fragments will be picked
      up automatically.</p><p>Note that this special prefix is specific to application contexts,
      and is resolved at construction time. It has nothing to do with the
      <code class="literal">Resource</code> type itself. It's not possible to use the
      <code class="literal">classpath*</code>: prefix to construct an actual
      <code class="literal">Resource</code>, as a resource points to just one resource
      at a time.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3008"></a>4.7.3.&nbsp;Unexpected application context handling of FileSystemResource
      absolute paths</h3></div></div></div><p>A <code class="literal">FileSystemResource</code> that is not attached to a
      <code class="literal">FileSystemApplicationContext</code> (that is, a
      FileSystemApplicationContext is not the actual
      <code class="literal">ResourceLoader</code>) will treat absolute vs. relative
      paths as you would expect. Relative paths are relative to the current
      working directory, while absolute paths are relative to the root of the
      filesystem.</p><p>For backwards compatibility (historical) reasons however, this
      changes when the <code class="literal">FileSystemApplicationContext</code> is the
      <code class="literal">ResourceLoader.</code>
      <code class="literal">FileSystemApplicationContext</code> simply forces all
      attached <code class="literal">FileSystemResources</code> to treat all location
      paths as relative, whether they start with a leading slash or not. In
      practice, this means the following are equivalent:</p><pre class="programlisting">ApplicationContext ctx =
    new FileSystemClassPathXmlApplicationContext("conf/context.xml");</pre><pre class="programlisting">ApplicationContext ctx =
    new FileSystemClassPathXmlApplicationContext("/conf/context.xml");</pre><p>as
      well as the following</p><pre class="programlisting">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("some/resource/path/myTemplate.txt");</pre><pre class="programlisting">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("/some/resource/path/myTemplate.txt");</pre><p>Even
      though it would make sense for them to be different, as one case being
      relative vs. one being absolute.</p><p>In practice, if true absolute filesystem paths are needed, it is
      better to forgo the use of absolute paths with
      <code class="literal">FileSystemResource</code>/<code class="literal">FileSystemXmlApplicationContext</code>,
      and just force the use of a UrlResource, by using the
      <code class="literal">file:</code> URL prefix.</p><pre class="programlisting">// actual context type doesn't matter, the Resource will always be UrlResource
ctx.getResource("file:/some/resource/path/myTemplate.txt");</pre><pre class="programlisting">// force this FileSystemXmlApplicationContext to load it's definition via a UrlResource
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("file:/conf/context.xml");</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="validation"></a>Chapter&nbsp;5.&nbsp;PropertyEditors, data binding, validation and the BeanWrapper</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-introduction"></a>5.1.&nbsp;Introduction</h2></div></div></div><p>The big question is whether or not validation should be considered
    <span class="emphasis"><em>business logic</em></span>. There are pros and cons for both
    answers, and Spring offers a design for validation (and data binding) that
    does not exclude either one of them. Validation should specifically not be
    tied to the web tier, should be easy to localize and it should be
    possible to plug in any validator available. Considering the above, Spring
    has come up with a <code class="literal">Validator</code> interface that's both
    basic and usable in every layer of an application.</p><p>Data binding is useful for allowing user input to be dynamically
    bound to the domain model of an application (or whatever objects you use
    to process user input). Spring provides the so-called
    <code class="literal">DataBinder</code> to do exactly that. The Validator and the
    DataBinder make up the <code class="literal">validation</code> package, which is
    primarily used in but not limited to the MVC framework.</p><p>The <code class="literal">BeanWrapper</code> is a fundamental concept in the
    Spring Framework and is used in a lot of places. However, you probably
    will not ever have the need to use the BeanWrapper directly. Because this
    is reference documentation however, we felt that some explanation might be
    right. We're explaining the BeanWrapper in this chapter since if you were
    going to use it at all, you would probably do that when trying to bind
    data to objects, which is strongly related to the BeanWrapper.</p><p>Spring uses PropertyEditors all over the place. The concept of a
    PropertyEditor is part of the JavaBeans specification. Just as the
    BeanWrapper, it's best to explain the use of PropertyEditors in this
    chapter as well, since it's closely related to the BeanWrapper and the
    DataBinder.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-databinding"></a>5.2.&nbsp;Binding data using the <code class="literal">DataBinder</code></h2></div></div></div><p>The DataBinder builds on top of the BeanWrapper<sup>[<a name="d0e3100" href="#ftn.d0e3100">2</a>]</sup>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beans"></a>5.3.&nbsp;Bean manipulation and the <code class="literal">BeanWrapper</code></h2></div></div></div><p>The <code class="literal">org.springframework.beans</code> package adheres to
    the JavaBeans standard provided by Sun. A JavaBean is simply a class with
    a default no-argument constructor, which follows a naming conventions
    where a property named <code class="literal">prop</code> has a setter
    <code class="literal">setProp(...)</code> and a getter <code class="literal">getProp()</code>.
    For more information about JavaBeans and the specification, please refer
    to Sun's website (<a href="http://java.sun.com/products/javabeans/" target="_top">java.sun.com/products/javabeans</a>).</p><p>One quite important concept of the beans package is the
    <code class="literal">BeanWrapper</code> interface and its corresponding
    implementation (<code class="literal">BeanWrapperImpl</code>). As quoted from the
    JavaDoc, the BeanWrapper offers functionality to set and get property
    values (individually or in bulk), get property descriptors, and to query
    properties to determine if they are readable or writable. Also, the
    BeanWrapper offers support for nested properties, enabling the setting of
    properties on sub-properties to an unlimited depth. Then, the BeanWrapper
    supports the ability to add standard JavaBeans
    <code class="literal">PropertyChangeListeners</code> and
    <code class="literal">VetoableChangeListeners</code>, without the need for
    supporting code in the target class. Last but not least, the BeanWrapper
    provides support for the setting of indexed properties. The BeanWrapper
    usually isn't used by application code directly, but by the
    <code class="literal">DataBinder</code> and the
    <code class="literal">BeanFactory</code>.</p><p>The way the BeanWrapper works is partly indicated by its name:
    <span class="emphasis"><em>it wraps a bean</em></span> to perform actions on that bean, like
    setting and retrieving properties.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conventions"></a>5.3.1.&nbsp;Setting and getting basic and nested properties</h3></div></div></div><p>Setting and getting properties is done using the
      <code class="literal">setPropertyValue(s)</code> and
      <code class="literal">getPropertyValue(s)</code> methods that both come with a
      couple of overloaded variants. They're all described in more detail in
      the JavaDoc Spring comes with. What's important to know is that there
      are a couple of conventions for indicating properties of an object. A
      couple of examples: </p><div class="table"><a name="d0e3165"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;Examples of properties</b></p><div class="table-contents"><table summary="Examples of properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Expression</th><th>Explanation</th></tr></thead><tbody><tr><td><code class="literal">name</code></td><td>Indicates the property <code class="literal">name</code>
                corresponding to the methods <code class="literal">getName()</code> or
                <code class="literal">isName()</code> and
                <code class="literal">setName()</code></td></tr><tr><td><code class="literal">account.name</code></td><td>Indicates the nested property <code class="literal">name</code>
                of the property <code class="literal">account</code> corresponding e.g.
                to the methods <code class="literal">getAccount().setName()</code> or
                <code class="literal">getAccount().getName()</code></td></tr><tr><td><code class="literal">account[2]</code></td><td>Indicates the <span class="emphasis"><em>third</em></span> element of the
                indexed property <code class="literal">account</code>. Indexed
                properties can be of type <code class="literal">array</code>,
                <code class="literal">list</code> or other <span class="emphasis"><em>naturally
                ordered</em></span> collection</td></tr><tr><td><code class="literal">account[COMPANYNAME]</code></td><td>Indicates the value of the map entry indexed by the key
                <span class="emphasis"><em>COMPANYNAME</em></span> of the Map property
                <code class="literal">account</code></td></tr></tbody></table></div></div><p><br class="table-break"></p><p>Below you'll find some examples of working with the BeanWrapper to
      get and set properties.</p><p><span class="emphasis"><em>Note: this part is not important to you if you're not
      planning to work with the BeanWrapper directly. If you're just using the
      <code class="literal">DataBinder</code> and the <code class="literal">BeanFactory</code> and
      their out-of-the-box implementation, you should skip ahead to the
      section about <code class="literal">PropertyEditors</code>.</em></span></p><p>Consider the following two classes: </p><pre class="programlisting">public class Company {
    private String name;
    private Employee managingDirector;

    public String getName()	{ 
        return this.name; 
    }
    public void setName(String name) { 
        this.name = name; 
    } 
    public Employee getManagingDirector() { 
        return this.managingDirector; 
    }
    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}</pre><p> </p><pre class="programlisting">public class Employee {
    private float salary;

    public float getSalary() {
        return salary;
    }
    public void setSalary(float salary) {
        this.salary = salary;
    }
}</pre><p>The following code snippets show some examples of how to retrieve
      and manipulate some of the properties of instantiated
      <code class="literal">Companies</code> and <code class="literal">Employees</code>:
      </p><pre class="programlisting">Company c = new Company();
BeanWrapper bwComp = BeanWrapperImpl(c);
// setting the company name...
bwComp.setPropertyValue("name", "Some Company Inc.");
// ... can also be done like this:
PropertyValue v = new PropertyValue("name", "Some Company Inc.");
bwComp.setPropertyValue(v);

// ok, let's create the director and tie it to the company:
Employee jim = new Employee();
BeanWrapper bwJim = BeanWrapperImpl(jim);
bwJim.setPropertyValue("name", "Jim Stravinsky");
bwComp.setPropertyValue("managingDirector", jim);

// retrieving the salary of the managingDirector through the company
Float salary = (Float)bwComp.getPropertyValue("managingDirector.salary");</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conversion"></a>5.3.2.&nbsp;Built-in <code class="literal">PropertyEditors</code>, converting
      types</h3></div></div></div><p>Spring heavily uses the concept of
      <code class="literal">PropertyEditors</code>. Sometimes it might be handy to be
      able to represent properties in a different way than the object itself.
      For example, a date can be represented in a human readable way, while
      we're still able to convert the human readable form back to the original
      date (or even better: convert any date entered in a human readable form,
      back to Date objects). This behavior can be achieved by
      <span class="emphasis"><em>registering custom editors</em></span>, of type
      <code class="literal">java.beans.PropertyEditor</code>. Registering custom editors
      on a BeanWrapper or alternately in a specific Application Context as
      mentioned in the previous chapter, gives it the knowledge of how to
      convert properties to the desired type. Read more about PropertyEditors
      in the JavaDoc of the <code class="literal">java.beans</code> package provided by
      Sun.</p><p>A couple of examples where property editing is used in Spring
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>setting properties on beans</em></span> is done
            using PropertyEditors. When mentioning
            <code class="literal">java.lang.String</code> as the value of a property of
            some bean you're declaring in XML file, Spring will (if the setter
            of the corresponding property has a Class-parameter) use the
            <code class="literal">ClassEditor</code> to try to resolve the parameter to
            a Class object</p></li><li><p><span class="emphasis"><em>parsing HTTP request parameters</em></span> in
            Spring's MVC framework is done using all kinds of PropertyEditors
            that you can manually bind in all subclasses of the
            <code class="literal">CommandController</code></p></li></ul></div><p>Spring has a number of built-in PropertyEditors to make life easy.
      Each of those is listed below and they are all located in the
      <code class="literal">org.springframework.beans.propertyeditors</code> package.
      Most, but not all (as indicated below), are registered by default by
      BeanWrapperImpl. Where the property editor is configurable in some
      fashion, you can of course still register your own variant to override
      the default one: </p><div class="table"><a name="d0e3321"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;Built-in PropertyEditors</b></p><div class="table-contents"><table summary="Built-in PropertyEditors" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class</th><th>Explanation</th></tr></thead><tbody><tr><td><code class="literal">ByteArrayPropertyEditor</code></td><td>Editor for byte arrays. Strings will simply be
                converted to their corresponding byte representations.
                Registered by default by BeanWrapperImpl.</td></tr><tr><td><code class="literal">ClassEditor</code></td><td>Parses Strings representing classes to actual classes
                and the other way around. When a class is not found, an
                IllegalArgumentException is thrown. Registered by default by
                BeanWrapperImpl.</td></tr><tr><td><code class="literal">CustomBooleanEditor</code></td><td>Customizable property editor for Boolean properties.
                Registered by default by BeanWrapperImpl, but, can be
                overridden by registering custom instance of it as custom
                editor.</td></tr><tr><td><code class="literal">CustomCollectionEditor</code></td><td>Property editor for Collections, converting any source Collection
                to a given target Collection type.</td></tr><tr><td><code class="literal">CustomDateEditor</code></td><td>Customizable property editor for java.util.Date,
                supporting a custom DateFormat. NOT registered by default. Must
                be user registered as needed with appropriate format.</td></tr><tr><td><code class="literal">CustomNumberEditor</code></td><td>Customizable property editor for any Number subclass
                like Integer, Long, Float, Double. Registered by default by
                BeanWrapperImpl, but, can be overridden by registering custom
                instance of it as custom editor.</td></tr><tr><td><code class="literal">FileEditor</code></td><td>Capable of resolving Strings to
                <code class="literal">java.io.File</code> objects. Registered by default by
                BeanWrapperImpl. </td></tr><tr><td><code class="literal">InputStreamEditor</code></td><td>One-way property editor, capable of taking a text
                string and producing (via an intermediate ResourceEditor and
                Resource) an InputStream, so InputStream properties may be
                directly set as Strings. Note that the default usage
                will not close the InputStream for you! Registered by default
                by BeanWrapperImpl.</td></tr><tr><td><code class="literal">LocaleEditor</code></td><td>Capable of resolving Strings to
                <code class="literal">Locale</code> objects and vice versa (the String
                format is [language]_[country]_[variant], which is the same
                thing the toString() method of Locale provides). Registered by
                default by BeanWrapperImpl.</td></tr><tr><td><code class="literal">PropertiesEditor</code></td><td>Capable of converting Strings (formatted using the
                format as defined in the Javadoc for the java.lang.Properties
                class) to <code class="literal">Properties</code> objects. Registered by
                default by BeanWrapperImpl.</td></tr><tr><td><code class="literal">StringArrayPropertyEditor</code></td><td>Capable of resolving a comma-delimited list of String
                to a String-array and vice versa. Registered by default by
                BeanWrapperImpl.</td></tr><tr><td><code class="literal">StringTrimmerEditor</code></td><td>Property editor that trims Strings. Optionally allows
                transforming an empty string into a null value. NOT registered
                by default. Must be user registered as needed.</td></tr><tr><td><code class="literal">URLEditor</code></td><td>Capable of resolving a String representation of a URL
                to an actual <code class="literal">URL</code> object. Registered by
                default by BeanWrapperImpl.</td></tr></tbody></table></div></div><p><br class="table-break"></p><p>Spring uses the
      <code class="literal">java.beans.PropertyEditorManager</code> to set the
      search path for property editors that might be needed. The search path
      also includes <code class="literal">sun.bean.editors</code>, which includes
      PropertyEditors for Font, Color and all the primitive types. Note also
      that the standard JavaBeans infrastructure will automatically discover
      PropertyEditors (without you having to register them) if they are in the
      same package as the class they handle, and have the same name as that
      class, with 'Editor' appended.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-other"></a>5.3.3.&nbsp;Other features worth mentioning</h3></div></div></div><p>Besides the features you've seen in the previous sections there a
      couple of features that might be interesting to you, though not worth an
      entire section. </p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>determining readability and
            writability</em></span>: using the <code class="literal">isReadable()</code>
            and <code class="literal">isWritable()</code> methods, you can determine
            whether or not a property is readable or writable</p></li><li><p><span class="emphasis"><em>retrieving PropertyDescriptors</em></span>: using
            <code class="literal">getPropertyDescriptor(String)</code> and
            <code class="literal">getPropertyDescriptors()</code> you can retrieve
            objects of type <code class="literal">java.beans.PropertyDescriptor</code>,
            that might come in handy sometimes</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validator"></a>5.4.&nbsp;Validation using Spring's Validator interface</h2></div></div></div><p>
			Spring's features a Validator interface you can use to validate objects.
			The Validator interface, is pretty straightforward and works using with
			a so-called Errors object. In other words, while validating, validators
			will report validation failures to the Errors object.
		</p><p>
			As said already, the Validator interface is pretty straightforward, just
			as implementing one yourself. Let's consider a small data object:
			</p><pre class="programlisting">
public class Person {
  private String name;
  private int age;

  // the usual suspects: getters and setters
}</pre><p>
		</p><p>
			Using the <code class="literal">org.springframework.validation.Validator</code>
			interface we're going to provide validation behavior for the <code class="literal">Person</code>
			class. This is the Validator interface:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p><code class="literal">supports(Class)</code> - indicates whether or not this validator
					supports the given object</p><p><code class="literal">validate(Object, org.springframework.validation.Errors)</code> - 
					validates the given object and in case of validation errors, put registers
					those with the given Errors object</p></li></ul></div><p>
		</p><p>
			Implementing a validator is fairly straightforward, especially when you know of the 
			<code class="literal">ValidationUtils</code> Spring also provides. Let's review 
			how a validator is created:
			</p><pre class="programlisting">
public class PersonValidator implements Validator {
	
	public boolean supports(Class clzz) {
		return Person.class.equals(clzz);
	}
	
	public void validate(Object obj, Errors e) {
		ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
		Person p = (Person)obj;
		if (p.getAge() &lt; 0) {
			e.rejectValue("age", "negativevalue");
		} else if (p.getAge() &gt; 110) {
			e.rejectValue("age", "tooold");
		}
	}
}</pre><p>
			As you can see, the ValidationUtils is used to reject the name
			property. Have a look at the JavaDoc for ValidationUtils to see
			what functionality it provides besides the example we gave just now.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-errors"></a>5.5.&nbsp;The Errors interface</h2></div></div></div><p>
			Validation errors are reported to the Errors object passed to the validator.
			In case of Spring Web MVC you can use <code class="literal">spring:bind</code> tags to
			inspect the error messages, but of course you can also inspect the errors
			object yourself. The methods it offers are pretty straightforward. More information
			can be found in the JavaDoc.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-conversion"></a>5.6.&nbsp;Resolving codes to error messages</h2></div></div></div><p>
			We've talked about databinding and validation. Outputting messages corresponding to 
			validation errors is the last thing we need to discuss. In the example we've shown
			above, we rejected the <code class="literal">name</code> and the <code class="literal">age</code> field.
			If, using a <code class="literal">MessageSource</code>, we're going to output the error messages
			we will do so using the error code we've given when rejecting the field ('name' and 'age'
			in this case). When you call (either directly, or indirectly, using for example the 
			<code class="literal">ValidationUtils</code> class) <code class="literal">rejectValue</code> or one of
			the other <code class="literal">reject</code> method from the Errors interface, the underlying 
			implementation will not only register the code, you've passed in, but also a number of
			additional error codes. What error codes it registers is determined by the
			<code class="literal">MessageCodesResolver</code> that is used.
			By default, the <code class="literal">DefaultMessageCodesResolver</code> is used, which for example
			not only register a message with the code you gave, but also messages that include the 
			field name you passed to the reject method. So in case you reject a field using
			<code class="literal">rejectValue("age", "tooold")</code>, apart from the <code class="literal">tooold</code> code,
			Spring will also register <code class="literal">tooold.age</code> and <code class="literal">tooold.age.int</code>
			(so the first will include the field name and the second will include the type of the field).
		</p><p>
			More information on the MessageCodesResolver and the default strategy can be found online with the JavaDocs for
			<a href="http://www.springframework.org/docs/api/org/springframework/validation/MessageCodesResolver.html" target="_top">
				MessageCodesResolver
			</a> and 
			<a href="http://www.springframework.org/docs/api/org/springframework/validation/DefaultMessageCodesResolver.html" target="_top">
				DefaultMessageCodesResolver
			</a> respectively. 
		</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e3100" href="#d0e3100">2</a>] </sup>See <a href="#beans" title="Chapter&nbsp;3.&nbsp;Beans, BeanFactory and the ApplicationContext">the beans chapter</a> for more
        information</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="aop"></a>Chapter&nbsp;6.&nbsp;Spring AOP: Aspect Oriented Programming with Spring</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-introduction"></a>6.1.&nbsp;Concepts</h2></div></div></div><p><span class="emphasis"><em>Aspect-Oriented Programming</em></span>
    (<span class="emphasis"><em>AOP</em></span>) complements OOP by providing another way of
    thinking about program structure. While OO decomposes applications into a
    hierarchy of objects, AOP decomposes programs into
    <span class="emphasis"><em>aspects</em></span> or <span class="emphasis"><em>concerns</em></span>. This
    enables modularization of concerns such as transaction management that
    would otherwise cut across multiple objects. (Such concerns are often
    termed <span class="emphasis"><em>crosscutting</em></span> concerns.)</p><p>One of the key components of Spring is the <span class="emphasis"><em>AOP
    framework</em></span>. While the Spring IoC containers (BeanFactory and
    ApplicationContext) do not depend on AOP, meaning you don't need to use
    AOP if you don't want to, AOP complements Spring IoC to provide a very
    capable middleware solution.</p><p>AOP is used in Spring:</p><div class="itemizedlist"><ul type="disc"><li><p>To provide declarative enterprise services, especially as a
        replacement for EJB declarative services. The most important such
        service is <span class="emphasis"><em>declarative transaction management</em></span>,
        which builds on Spring's transaction abstraction.</p></li><li><p>To allow users to implement custom aspects, complementing their
        use of OOP with AOP.</p></li></ul></div><p>Thus you can view Spring AOP as either an enabling technology that
    allows Spring to provide declarative transaction management without EJB;
    or use the full power of the Spring AOP framework to implement custom
    aspects.</p><p class="remark"><i><span class="remark">If you are interested only in generic declarative services or
    other pre-packaged declarative middleware services such as pooling, you
    don't need to work directly with Spring AOP, and can skip most of this
    chapter.</span></i></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-defn"></a>6.1.1.&nbsp;AOP concepts</h3></div></div></div><p>Let us begin by defining some central AOP concepts. These terms
      are not Spring-specific. Unfortunately, AOP terminology is not
      particularly intuitive. However, it would be even more confusing if
      Spring used its own terminology.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Aspect</em></span>: A modularization of a concern for
          which the implementation might otherwise cut across multiple
          objects. Transaction management is a good example of a crosscutting
          concern in J2EE applications. Aspects are implemented using Spring
          as Advisors or interceptors.</p></li><li><p><span class="emphasis"><em>Joinpoint</em></span>: Point during the execution of
          a program, such as a method invocation or a particular exception
          being thrown. In Spring AOP, a joinpoint is always method
          invocation. Spring does not use the term joinpoint prominently;
          joinpoint information is accessible through methods on the
          <code class="literal">MethodInvocation</code> argument passed to interceptors,
          and is evaluated by implementations of the
          <code class="literal">org.springframework.aop.Pointcut
          </code>interface.</p></li><li><p><span class="emphasis"><em>Advice</em></span>: Action taken by the AOP framework
          at a particular joinpoint. Different types of advice include
          "around," "before" and "throws" advice. Advice types are discussed
          below. Many AOP frameworks, including Spring, model an advice as an
          <span class="emphasis"><em>interceptor</em></span>, maintaining a chain of
          interceptors "around" the joinpoint.</p></li><li><p><span class="emphasis"><em>Pointcut</em></span>: A set of joinpoints specifying
          when an advice should fire. An AOP framework must allow developers
          to specify pointcuts: for example, using regular expressions.</p></li><li><p><span class="emphasis"><em>Introduction</em></span>: Adding methods or fields to
          an advised class. Spring allows you to introduce new interfaces to
          any advised object. For example, you could use an introduction to
          make any object implement an <code class="literal">IsModified</code>
          interface, to simplify caching.</p></li><li><p><span class="emphasis"><em>Target object</em></span>: Object containing the
          joinpoint. Also referred to as <span class="emphasis"><em>advised</em></span> or
          <span class="emphasis"><em>proxied</em></span> object.</p></li><li><p><span class="emphasis"><em>AOP proxy</em></span>: Object created by the AOP
          framework, including advice. In Spring, an AOP proxy will be a JDK
          dynamic proxy or a CGLIB proxy.</p></li><li><p><span class="emphasis"><em>Weaving</em></span>: Assembling aspects to create an
          advised object. This can be done at compile time (using the AspectJ
          compiler, for example), or at runtime. Spring, like other pure Java
          AOP frameworks, performs weaving at runtime.</p></li></ul></div><p>Different advice types include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Around advice</em></span>: Advice that surrounds a
          joinpoint such as a method invocation. This is the most powerful
          kind of advice. Around advices will perform custom behavior before
          and after the method invocation. They are responsible for choosing
          whether to proceed to the joinpoint or to shortcut executing by
          returning their own return value or throwing an exception.</p></li><li><p><span class="emphasis"><em>Before advice</em></span>: Advice that executes
          before a joinpoint, but which does not have the ability to prevent
          execution flow proceeding to the joinpoint (unless it throws an
          exception).</p></li><li><p><span class="emphasis"><em>Throws advice</em></span>: Advice to be executed if a
          method throws an exception. Spring provides strongly typed throws
          advice, so you can write code that catches the exception (and
          subclasses) you're interested in, without needing to cast from
          Throwable or Exception.</p></li><li><p><span class="emphasis"><em>After returning advice</em></span>: Advice to be
          executed after a joinpoint completes normally: for example, if a
          method returns without throwing an exception.</p></li></ul></div><p>Around advice is the most general kind of advice. Most
      interception-based AOP frameworks, such as Nanning Aspects, provide only
      around advice.</p><p>As Spring, like AspectJ, provides a full range of advice types, we
      recommend that you use the least powerful advice type that can implement
      the required behavior. For example, if you need only to update a cache
      with the return value of a method, you are better off implementing an
      after returning advice than an around advice, although an around advice
      can accomplish the same thing. Using the most specific advice type
      provides a simpler programming model with less potential for errors. For
      example, you don't need to invoke the <code class="literal">proceed()</code>
      method on the MethodInvocation used for around advice, and hence can't
      fail to invoke it.</p><p>The pointcut concept is the key to AOP, distinguishing AOP from
      older technologies offering interception. Pointcuts enable advice to be
      targeted independently of the OO hierarchy. For example, an around
      advice providing declarative transaction management can be applied to a
      set of methods spanning multiple objects. Thus pointcuts provide the
      structural element of AOP.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-spring-defn"></a>6.1.2.&nbsp;Spring AOP capabilities and goals</h3></div></div></div><p>Spring AOP is implemented in pure Java. There is no need for a
      special compilation process. Spring AOP does not need to control the
      class loader hierarchy, and is thus suitable for use in a J2EE web
      container or application server.</p><p>Spring currently supports interception of method invocations.
      Field interception is not implemented, although support for field
      interception could be added without breaking the core Spring AOP
      APIs.</p><p class="remark"><i><span class="remark">Field interception arguably violates OO encapsulation. We don't
      believe it is wise in application development. If you require field
      interception, consider using AspectJ.</span></i></p><p>Spring provides classes to represent pointcuts and different
      advice types. Spring uses the term <span class="emphasis"><em>advisor</em></span> for an
      object representing an aspect, including both an advice and a pointcut
      targeting it to specific joinpoints.</p><p>Different advice types are <code class="literal">MethodInterceptor</code>
      (from the AOP Alliance interception API); and the advice interfaces
      defined in the <code class="literal">org.springframework.aop</code> package. All
      advices must implement the <code class="literal">org.aopalliance.aop.Advice</code>
      tag interface. Advices supported out the box are
      <code class="literal">MethodInterceptor</code> ; <code class="literal">ThrowsAdvice</code>;
      <code class="literal">BeforeAdvice</code>; and
      <code class="literal">AfterReturningAdvice</code>. We'll discuss advice types in
      detail below.</p><p>Spring implements the <span class="emphasis"><em>AOP Alliance</em></span>
      interception interfaces (<a href="http://www.sourceforge.net/projects/aopalliance" target="_top">http://www.sourceforge.net/projects/aopalliance</a>).
      Around advice must implement the AOP Alliance
      <code class="literal">org.aopalliance.intercept.MethodInterceptor</code>
      interface. Implementations of this interface can run in Spring or any
      other AOP Alliance compliant implementation. Currently JAC implements
      the AOP Alliance interfaces, and Nanning and Dynaop are likely to in
      early 2004.</p><p>Spring's approach to AOP differs from that of most other AOP
      frameworks. The aim is not to provide the most complete AOP
      implementation (although Spring AOP is quite capable); it is rather to
      provide a close integration between AOP implementation and Spring IoC to
      help solve common problems in enterprise applications.</p><p>Thus, for example, Spring's AOP functionality is normally used in
      conjunction with a Spring IoC container. AOP advice is specified using
      normal bean definition syntax (although this allows powerful
      "autoproxying" capabilities); advice and pointcuts are themselves
      managed by Spring IoC: a crucial difference from other AOP
      implementations. There are some things you can't do easily or
      efficiently with Spring AOP, such as advise very fine-grained objects.
      AspectJ is probably the best choice in such cases. However, our
      experience is that Spring AOP provides an excellent solution to most
      problems in J2EE applications that are amenable to AOP.</p><p>Spring AOP will never strive to compete with AspectJ or
      AspectWerkz to provide a comprehensive AOP solution. We believe that
      both proxy-based frameworks like Spring and full-blown frameworks such
      as AspectJ are valuable, and that they are complementary, rather than in
      competition. Thus a major priority for Spring 1.1 will be seamlessly
      integrating Spring AOP and IoC with AspectJ, to enable all uses of AOP
      to be catered for within a consistent Spring-based application
      architecture. This integration will not affect the Spring AOP API or the
      AOP Alliance API; Spring AOP will remain backward-compatible.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-proxies"></a>6.1.3.&nbsp;AOP Proxies in Spring</h3></div></div></div><p>Spring defaults to using J2SE <span class="emphasis"><em>dynamic proxies</em></span>
      for AOP proxies. This enables any interface or set of interfaces to be
      proxied.</p><p>Spring can also use CGLIB proxies. This is necessary to proxy
      classes, rather than interfaces. CGLIB is used by default if a business
      object doesn't implement an interface. As it's good practice to
      <span class="emphasis"><em>program to interfaces rather than classes</em></span>, business
      objects normally will implement one or more business interfaces.</p><p>It is possible to force the use of CGLIB: we'll discuss this
      below, and explain why you'd want to do this.</p><p class="remark"><i><span class="remark">Beyond Spring 1.0, Spring may offer additional types of AOP
      proxy, including wholly generated classes. This won't affect the
      programming model.</span></i></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-introduction-pointcuts"></a>6.2.&nbsp;Pointcuts in Spring</h2></div></div></div><p>Let's look at how Spring handles the crucial pointcut
    concept.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3772"></a>6.2.1.&nbsp;Concepts</h3></div></div></div><p>Spring's pointcut model enables pointcut reuse independent of
      advice types. It's possible to target different advice using the same
      pointcut.</p><p>The <code class="literal">org.springframework.aop.Pointcut</code> interface
      is the central interface, used to target advices to particular classes
      and methods. The complete interface is shown below:</p><pre class="programlisting">public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

}</pre><p>Splitting the <code class="literal">Pointcut</code> interface into two parts
      allows reuse of class and method matching parts, and fine-grained
      composition operations (such as performing a "union" with another method
      matcher).</p><p>The <code class="literal">ClassFilter</code> interface is used to restrict
      the pointcut to a given set of target classes. If the
      <code class="literal">matches()</code> method always returns true, all target
      classes will be matched:</p><pre class="programlisting">public interface ClassFilter {

    boolean matches(Class clazz);
}</pre><p>The <code class="literal">MethodMatcher</code> interface is normally more
      important. The complete interface is shown below:</p><pre class="programlisting">public interface MethodMatcher {

    boolean matches(Method m, Class targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class targetClass, Object[] args);
}</pre><p>The <code class="literal">matches(Method, Class) </code>method is used to
      test whether this pointcut will ever match a given method on a target
      class. This evaluation can be performed when an AOP proxy is created, to
      avoid the need for a test on every method invocation. If the 2-argument
      matches method returns true for a given method, and the
      <code class="literal">isRuntime()</code> method for the MethodMatcher returns
      true, the 3-argument matches method will be invoked on every method
      invocation. This enables a pointcut to look at the arguments passed to
      the method invocation immediately before the target advice is to
      execute.</p><p>Most MethodMatchers are static, meaning that their
      <code class="literal">isRuntime()</code> method returns false. In this case, the
      3-argument matches method will never be invoked.</p><p class="remark"><i><span class="remark">If possible, try to make pointcuts static, allowing the AOP
      framework to cache the results of pointcut evaluation when an AOP proxy
      is created.</span></i></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3821"></a>6.2.2.&nbsp;Operations on pointcuts</h3></div></div></div><p>Spring supports operations on pointcuts: notably,
      <span class="emphasis"><em>union</em></span> and <span class="emphasis"><em>intersection</em></span>.</p><p>Union means the methods that either pointcut matches.</p><p>Intersection means the methods that both pointcuts match.</p><p>Union is usually more useful.</p><p>Pointcuts can be composed using the static methods in the
      <span class="emphasis"><em>org.springframework.aop.support.Pointcuts</em></span> class, or
      using the <span class="emphasis"><em>ComposablePointcut</em></span> class in the same
      package.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3846"></a>6.2.3.&nbsp;Convenience pointcut implementations</h3></div></div></div><p>Spring provides several convenient pointcut implementations. Some
      can be used out of the box; others are intended to be subclassed in
      application-specific pointcuts.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3851"></a>6.2.3.1.&nbsp;Static pointcuts</h4></div></div></div><p>Static pointcuts are based on method and target class, and
        cannot take into account the method's arguments. Static pointcuts are
        sufficient--and best--for most usages. It's possible for Spring to
        evaluate a static pointcut only once, when a method is first invoked:
        after that, there is no need to evaluate the pointcut again with each
        method invocation.</p><p>Let's consider some static pointcut implementations included
        with Spring.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3858"></a>6.2.3.1.1.&nbsp;Regular expression pointcuts</h5></div></div></div><p>One obvious way to specific static pointcuts is regular
          expressions. Several AOP frameworks besides Spring make this
          possible.
          <code class="literal">org.springframework.aop.support.Perl5RegexpMethodPointcut</code>
          is a generic regular expression pointcut, using Perl 5 regular
          expression syntax. the <code class="literal">Perl5RegexpMethodPointcut</code> class
					depends on Jakarta ORO for regular expression matching. Spring also provides
					the <code class="literal">JdkRegexpMethodPointcut</code> class that uses the regular
					expression support in JDK 1.4+.</p><p>Using the <code class="literal">Perl5RegexpMethodPointcut</code> class,
					you can provide a list of pattern Strings. If any of these is a match,
					the pointcut will evaluate to true. (So the result is effectively the
					union of these pointcuts.)</p><p>The usage is shown below:</p><pre class="programlisting">&lt;bean id="settersAndAbsquatulatePointcut" 
    class="org.springframework.aop.support.Perl5RegexpMethodPointcut"&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Spring provides a convenience class,
          <code class="literal">RegexpMethodPointcutAdvisor</code>, that allows us to
          reference an Advice also (Remember that an Advice can be an interceptor,
					before advice, throws advice etc.). Behind the scenes, Spring will use the
					<code class="literal">JdkRegexpMethodPointcut</code> on J2SE 1.4 or above, and will
					fall back to <code class="literal">Perl5RegexpMethodPointcut</code> on older VMs.
					The use of <code class="literal">Perl5RegexpMethodPointcut</code> can be forced
				  by setting the <code class="literal">perl5</code> property to true.
					Using <code class="literal">RegexpMethodPointcutAdvisor</code> simplifies wiring,
					as the one bean serves as both pointcut and advisor, as shown below:</p><pre class="programlisting">&lt;bean id="settersAndAbsquatulateAdvisor" 
    class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
    &lt;property name="advice"&gt;
        &lt;ref local="beanNameOfAopAllianceInterceptor"/&gt;
    &lt;/property&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>RegexpMethodPointcutAdvisor</em></span> can be used
          with any Advice type.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3909"></a>6.2.3.1.2.&nbsp;Attribute-driven pointcuts</h5></div></div></div><p>An important type of static pointcut is a
          <span class="emphasis"><em>metadata-driven</em></span> pointcut. This uses the values
          of metadata attributes: typically, source-level metadata.</p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3917"></a>6.2.3.2.&nbsp;Dynamic pointcuts</h4></div></div></div><p>Dynamic pointcuts are costlier to evaluate than static
        pointcuts. They take into account method
        <span class="emphasis"><em>arguments</em></span>, as well as static information. This
        means that they must be evaluated with every method invocation; the
        result cannot be cached, as arguments will vary.</p><p>The main example is the <code class="literal">control flow</code>
        pointcut.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e3930"></a>6.2.3.2.1.&nbsp;Control flow pointcuts</h5></div></div></div><p>Spring control flow pointcuts are conceptually similar to
          AspectJ <span class="emphasis"><em>cflow</em></span> pointcuts, although less
          powerful. (There is currently no way to specify that a pointcut
          executes below another pointcut.) A control flow pointcut matches
          the current call stack. For example, it might fire if the joinpoint
          was invoked by a method in the <code class="literal">com.mycompany.web</code>
          package, or by the <code class="literal">SomeCaller</code> class. Control flow
          pointcuts are specified using the
          <code class="literal">org.springframework.aop.support.ControlFlowPointcut
          </code>class.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>Control flow pointcuts are significantly more expensive to
              evaluate at runtime than even other dynamic pointcuts. In Java
              1.4, the cost is about 5 times that of other dynamic pointcuts;
              in Java 1.3 more than 10.</p></td></tr></table></div></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3950"></a>6.2.4.&nbsp;Pointcut superclasses</h3></div></div></div><p>Spring provides useful pointcut superclasses to help you to
      implement your own pointcuts.</p><p>Because static pointcuts are most useful, you'll probably subclass
      StaticMethodMatcherPointcut, as shown below. This requires implemented
      just one abstract method (although it's possible to override other
      methods to customize behavior):</p><pre class="programlisting">class TestStaticPointcut extends StaticMethodMatcherPointcut {

    public boolean matches(Method m, Class targetClass) {
        // return true if custom criteria match
    }
}</pre><p>There are also superclasses for dynamic pointcuts.</p><p>You can use custom pointcuts with any advice type in Spring 1.0
      RC2 and above.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3963"></a>6.2.5.&nbsp;Custom pointcuts</h3></div></div></div><p>Because pointcuts in Spring are Java classes, rather than language
      features (as in AspectJ) it's possible to declare custom pointcuts,
      whether static or dynamic. However, there is no support out of the box
      for the sophisticated pointcut expressions that can be coded in AspectJ
      syntax. However, custom pointcuts in Spring can be arbitrarily
      complex.</p><p class="remark"><i><span class="remark">Later versions of Spring may offer support for "semantic
      pointcuts" as offered by JAC: for example, "all methods that change
      instance variables in the target object."</span></i></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3970"></a>6.3.&nbsp;Advice types in Spring</h2></div></div></div><p>Let's now look at how Spring AOP handles advice.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3975"></a>6.3.1.&nbsp;Advice lifecycles</h3></div></div></div><p>Spring advices can be shared across all advised objects, or unique
      to each advised object. This corresponds to
      <span class="emphasis"><em>per-class</em></span> or <span class="emphasis"><em>per-instance</em></span>
      advice.</p><p>Per-class advice is used most often. It is appropriate for generic
      advice such as transaction advisors. These do not depend on the state of
      the proxied object or add new state; they merely act on the method and
      arguments.</p><p>Per-instance advice is appropriate for introductions, to support
      mixins. In this case, the advice adds state to the proxied
      object.</p><p>It's possible to use a mix of shared and per-instance advice in
      the same AOP proxy.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-advice-types"></a>6.3.2.&nbsp;Advice types in Spring</h3></div></div></div><p>Spring provides several advice types out of the box, and is
      extensible to support arbitrary advice types. Let us look at the basic
      concepts and standard advice types.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e3997"></a>6.3.2.1.&nbsp;Interception around advice</h4></div></div></div><p>The most fundamental advice type in Spring is
        <span class="emphasis"><em>interception around advice</em></span>.</p><p>Spring is compliant with the AOP Alliance interface for around
        advice using method interception. MethodInterceptors implementing
        around advice should implement the following interface:</p><pre class="programlisting">public interface MethodInterceptor extends Interceptor {
  
    Object invoke(MethodInvocation invocation) throws Throwable;
}</pre><p>The <span class="emphasis"><em>MethodInvocation</em></span> argument to the
        <span class="emphasis"><em>invoke()</em></span> method exposes the method being invoked;
        the target joinpoint; the AOP proxy; and the arguments to the method.
        The <span class="emphasis"><em>invoke()</em></span> method should return the
        invocation's result: the return value of the joinpoint.</p><p>A simple <span class="emphasis"><em>MethodInterceptor</em></span> implementation
        looks as follows:</p><pre class="programlisting">public class DebugInterceptor implements MethodInterceptor {

    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before: invocation=[" + invocation + "]");
        Object rval = invocation.proceed();
        System.out.println("Invocation returned");
        return rval;
    }
}</pre><p>Note the call to the MethodInvocation's
        <span class="emphasis"><em>proceed()</em></span> method. This proceeds down the
        interceptor chain towards the joinpoint. Most interceptors will invoke
        this method, and return its return value. However, a
        MethodInterceptor, like any around advice, can return a different
        value or throw an exception rather than invoke the proceed method.
        However, you don't want to do this without good reason!</p><p class="remark"><i><span class="remark">MethodInterceptors offer interoperability with other AOP
        Alliance-compliant AOP implementations. The other advice types
        discussed in the remainder of this section implement common AOP
        concepts, but in a Spring-specific way. While there is an advantage in
        using the most specific advice type, stick with MethodInterceptor
        around advice if you are likely to want to run the aspect in another
        AOP framework. Note that pointcuts are not currently interoperable
        between frameworks, and the AOP Alliance does not currently define
        pointcut interfaces.</span></i></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4034"></a>6.3.2.2.&nbsp;Before advice</h4></div></div></div><p>A simpler advice type is a <span class="bold"><strong>before
        advice</strong></span>. This does not need a
        <code class="literal">MethodInvocation</code> object, since it will only be
        called before entering the method.</p><p>The main advantage of a before advice is that there is no need
        to invoke the <code class="literal">proceed() </code>method, and therefore no
        possibility of inadvertently failing to proceed down the interceptor
        chain.</p><p>The <code class="literal">MethodBeforeAdvice</code> interface is shown
        below. (Spring's API design would allow for field before advice,
        although the usual objects apply to field interception and it's
        unlikely that Spring will ever implement it).</p><pre class="programlisting">public interface MethodBeforeAdvice extends BeforeAdvice {

    void before(Method m, Object[] args, Object target) throws Throwable;
}</pre><p>Note the the return type is <code class="literal">void</code>. Before
        advice can insert custom behavior before the joinpoint executes, but
        cannot change the return value. If a before advice throws an
        exception, this will abort further execution of the interceptor chain.
        The exception will propagate back up the interceptor chain. If it is
        unchecked, or on the signature of the invoked method, it will be
        passed directly to the client; otherwise it will be wrapped in an
        unchecked exception by the AOP proxy.</p><p>An example of a before advice in Spring, which counts all
        method invocations:</p><pre class="programlisting">public class CountingBeforeAdvice implements MethodBeforeAdvice {

    private int count;

    public void before(Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() { 
        return count; 
    }
}</pre><p class="remark"><i><span class="remark">Before advice can be used with any pointcut.</span></i></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4068"></a>6.3.2.3.&nbsp;Throws advice</h4></div></div></div><p><span class="bold"><strong>Throws advice</strong></span> is invoked after
        the return of the joinpoint if the joinpoint threw an exception.
        Spring offers typed throws advice. Note that this means that the
        <code class="literal">org.springframework.aop.ThrowsAdvice</code> interface does
        not contain any methods: it is a tag interface identifying that the
        given object implements one or more typed throws advice methods. These
        should be of form</p><pre class="programlisting">afterThrowing([Method], [args], [target], subclassOfThrowable) </pre><p>Only the last argument is required. Thus there from one to four
        arguments, depending on whether the advice method is interested in the
        method and arguments. The following are examples of throws
        advices.</p><p>This advice will be invoked if a
        <code class="literal">RemoteException</code> is thrown (including
        subclasses):</p><pre class="programlisting">public class RemoteThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
}</pre><p>The following advice is invoked if a
        <span class="emphasis"><em>ServletException</em></span> is thrown. Unlike the above
        advice, it declares 4 arguments, so that it has access to the invoked
        method, method arguments and target object:</p><pre class="programlisting">public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something will all arguments
    }
}</pre><p>The final example illustrates how these two methods could be
        used in a single class, which handles both
        <code class="literal">RemoteException</code> and
        <code class="literal">ServletException</code>. Any number of throws advice
        methods can be combined in a single class.</p><pre class="programlisting">public static class CombinedThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
 
    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something will all arguments
    }
}</pre><p class="remark"><i><span class="remark">Throws advice can be used with any pointcut.</span></i></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4108"></a>6.3.2.4.&nbsp;After Returning advice</h4></div></div></div><p>An after returning advice in Spring must implement the
        <span class="emphasis"><em>org.springframework.aop.AfterReturningAdvice</em></span>
        interface, shown below:</p><pre class="programlisting">public interface AfterReturningAdvice extends Advice {

    void afterReturning(Object returnValue, Method m, Object[] args, Object target) 
            throws Throwable;
}</pre><p>An after returning advice has access to the return value (which
        it cannot modify), invoked method, methods arguments and
        target.</p><p>The following after returning advice counts all successful
        method invocations that have not thrown exceptions:</p><pre class="programlisting">public class CountingAfterReturningAdvice implements AfterReturningAdvice {

    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</pre><p>This advice doesn't change the execution path. If it throws an
        exception, this will be thrown up the interceptor chain instead of the
        return value.</p><p class="remark"><i><span class="remark">After returning advice can be used with any pointcut.</span></i></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4128"></a>6.3.2.5.&nbsp;Introduction advice</h4></div></div></div><p>Spring treats introduction advice as a special kind of
        interception advice.</p><p>Introduction requires an <code class="literal">IntroductionAdvisor</code>,
        and an <code class="literal">IntroductionInterceptor</code>, implementing the
        following interface:</p><pre class="programlisting">public interface IntroductionInterceptor extends MethodInterceptor {

    boolean implementsInterface(Class intf);
}</pre><p>The <code class="literal">invoke() </code>method inherited from the AOP
        Alliance <code class="literal">MethodInterceptor</code> interface must implement
        the introduction: that is, if the invoked method is on an introduced
        interface, the introduction interceptor is responsible for handling
        the method call--it cannot invoke <code class="literal">proceed()</code>.</p><p>Introduction advice cannot be used with any pointcut, as it
        applies only at class, rather than method, level. You can only use
        introduction advice with the <code class="literal">IntroductionAdvisor</code>, which
        has the following methods:</p><pre class="programlisting">public interface IntroductionAdvisor extends Advisor, IntroductionInfo {

	ClassFilter getClassFilter();

	void validateInterfaces() throws IllegalArgumentException;
}

public interface IntroductionInfo {

	Class[] getInterfaces();
}</pre><p>There is no <code class="literal">MethodMatcher</code>, and hence no
        <code class="literal">Pointcut</code>, associated with introduction advice. Only
        class filtering is logical.</p><p>The <code class="literal">getInterfaces()</code> method returns the
        interfaces introduced by this advisor.</p> The <code class="literal">validateInterfaces()</code>
		method is used internally to see whether or not the introduced interfaces can be
		implemented by the configured <code class="literal">IntroductionInterceptor</code>.

		<p>Let's look at a simple example from the Spring test suite. Let's
        suppose we want to introduce the following interface to one or more
        objects:</p><pre class="programlisting">public interface Lockable {
    void lock();
    void unlock();
    boolean locked();
}</pre><p>This illustrates a <span class="bold"><strong>mixin</strong></span>. We
        want to be able to cast advised objects to Lockable, whatever their
        type, and call lock and unlock methods. If we call the lock() method,
        we want all setter methods to throw a
        <code class="literal">LockedException</code>. Thus we can add an aspect that
        provides the ability to make objects immutable, without them having
        any knowledge of it: a good example of AOP.</p><p>Firstly, we'll need an
        <code class="literal">IntroductionInterceptor</code> that does the heavy
        lifting. In this case, we extend the
        <code class="literal">org.springframework.aop.support.DelegatingIntroductionInterceptor</code>
        convenience class. We could implement IntroductionInterceptor
        directly, but using
        <code class="literal">DelegatingIntroductionInterceptor</code> is best for most
        cases.</p><p>The <code class="literal">DelegatingIntroductionInterceptor</code> is
        designed to delegate an introduction to an actual implementation of
        the introduced interface(s), concealing the use of interception to do
        so. The delegate can be set to any object using a constructor
        argument; the default delegate (when the no-arg constructor is used)
        is this. Thus in the example below, the delegate is the
        <code class="literal">LockMixin</code> subclass of
        <code class="literal">DelegatingIntroductionInterceptor</code>. Given a delegate
        (by default itself) a
        <code class="literal">DelegatingIntroductionInterceptor</code> instance looks
        for all interfaces implemented by the delegate (other than
        IntroductionInterceptor), and will support introductions against any
        of them. It's possible for subclasses such as
        <code class="literal">LockMixin</code> to call the
        <code class="literal">suppressInterflace(Class intf) </code>method to suppress
        interfaces that should not be exposed. However, no matter how many
        interfaces an <code class="literal">IntroductionInterceptor</code> is prepared
        to support, the <code class="literal">IntroductionAdvisor</code> used will
        control which interfaces are actually exposed. An introduced interface
        will conceal any implementation of the same interface by the
        target.</p><p>Thus LockMixin subclasses
        <code class="literal">DelegatingIntroductionInterceptor</code> and implements
        Lockable itself. The superclass automatically picks up that Lockable
        can be supported for introduction, so we don't need to specify that.
        We could introduce any number of interfaces in this way.</p><p>Note the use of the <code class="literal">locked</code> instance variable.
        This effectively adds additional state to that held in the target
        object.</p><pre class="programlisting">public class LockMixin extends DelegatingIntroductionInterceptor 
    implements Lockable {

    private boolean locked;

    public void lock() {
        this.locked = true;
    }

    public void unlock() {
        this.locked = false;
    }

    public boolean locked() {
        return this.locked;
    }

    public Object invoke(MethodInvocation invocation) throws Throwable {
        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0)
            throw new LockedException();
        return super.invoke(invocation);
    }

}</pre><p>Often it isn't necessary to override the <code class="literal">invoke()
        </code>method: the
        <code class="literal">DelegatingIntroductionInterceptor</code>
        implementation--which calls the delegate method if the method is
        introduced, otherwise proceeds towards the joinpoint--is usually
        sufficient. In the present case, we need to add a check: no setter
        method can be invoked if in locked mode.</p><p>The introduction advisor required is simple. All it needs to do
        is hold a distinct <code class="literal">LockMixin</code> instance, and specify
        the introduced interfaces--in this case, just
        <code class="literal">Lockable</code>. A more complex example might take a
        reference to the introduction interceptor (which would be defined as a
        prototype): in this case, there's no configuration relevant for a
        <code class="literal">LockMixin</code>, so we simply create it using
        <code class="literal">new</code>.</p><pre class="programlisting">public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

    public LockMixinAdvisor() {
        super(new LockMixin(), Lockable.class);
    }
}</pre><p>We can apply this advisor very simply: it requires no
        configuration. (However, it <span class="emphasis"><em>is</em></span> necessary: It's
        impossible to use an <code class="literal">IntroductionInterceptor</code>
        without an <span class="emphasis"><em>IntroductionAdvisor</em></span>.) As usual with
        introductions, the advisor must be per-instance, as it is stateful. We
        need a different instance of <code class="literal">LockMixinAdvisor</code>, and
        hence <code class="literal">LockMixin</code>, for each advised object. The
        advisor comprises part of the advised object's state.</p><p>We can apply this advisor programmatically, using the
        <code class="literal">Advised.addAdvisor() </code>method, or (the recommended
        way) in XML configuration, like any other advisor. All proxy creation
        choices discussed below, including "auto proxy creators," correctly
        handle introductions and stateful mixins.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4291"></a>6.4.&nbsp;Advisors in Spring</h2></div></div></div><p>In Spring, an Advisor is a modularization of an aspect. Advisors
    typically incorporate both an advice and a pointcut.</p><p>Apart from the special case of introductions, any advisor can be
    used with any advice.
    <code class="literal">org.springframework.aop.support.DefaultPointcutAdvisor</code>
    is the most commonly used advisor class. For example, it can be used with
    a <code class="literal">MethodInterceptor</code>, <code class="literal">BeforeAdvice</code> or
    <code class="literal">ThrowsAdvice</code>.</p><p>It is possible to mix advisor and advice types in Spring in the same
    AOP proxy. For example, you could use a interception around advice, throws
    advice and before advice in one proxy configuration: Spring will
    automatically create the necessary create interceptor chain.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-pfb"></a>6.5.&nbsp;Using the ProxyFactoryBean to create AOP proxies</h2></div></div></div><p>If you're using the Spring IoC container (an ApplicationContext or
    BeanFactory) for your business objects--and you should be!--you will want
    to use one of Spring's AOP FactoryBeans. (Remember that a factory bean
    introduces a layer of indirection, enabling it to create objects of a
    different type).</p><p>The basic way to create an AOP proxy in Spring is to use the
    <span class="emphasis"><em>org.springframework.aop.framework.ProxyFactoryBean</em></span>.
    This gives complete control over the pointcuts and advice that will apply,
    and their ordering. However, there are simpler options that are preferable
    if you don't need such control.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pfb-1"></a>6.5.1.&nbsp;Basics</h3></div></div></div><p>The <code class="literal">ProxyFactoryBean</code>, like other Spring
      <code class="literal">FactoryBean</code> implementations, introduces a level of
      indirection. If you define a <code class="literal">ProxyFactoryBean</code> with
      name <code class="literal">foo</code>, what objects referencing
      <code class="literal">foo</code> see is not the
      <code class="literal">ProxyFactoryBean</code> instance itself, but an object
      created by the <code class="literal">ProxyFactoryBean's</code> implementation of
      the <code class="literal">getObject() </code>method. This method will create an
      AOP proxy wrapping a target object.</p><p>One of the most important benefits of using a
      <code class="literal">ProxyFactoryBean</code> or other IoC-aware class to create
      AOP proxies, is that it means that advices and pointcuts can also be
      managed by IoC. This is a powerful feature, enabling certain approaches
      that are hard to achieve with other AOP frameworks. For example, an
      advice may itself reference application objects (besides the target,
      which should be available in any AOP framework), benefiting from all the
      pluggability provided by Dependency Injection.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pfb-2"></a>6.5.2.&nbsp;JavaBean properties</h3></div></div></div><p>Like most FactoryBean implementations provided with Spring,
      <code class="literal">ProxyFactoryBean</code> is itself a JavaBean. Its properties
      are used to:</p><div class="itemizedlist"><ul type="disc"><li><p>Specify the target you want to proxy</p></li><li><p>Specify whether to use CGLIB</p></li></ul></div><p>Some key properties are inherited from
      <code class="literal">org.springframework.aop.framework.ProxyConfig</code>: the
      superclass for all AOP proxy factories. These include:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">proxyTargetClass</code>: true if we should proxy
          the target class, rather than its interfaces. If this is true we
          need to use CGLIB.</p></li><li><p><code class="literal">optimize</code>: whether to apply aggressive
          optimization to created proxies. Don't use this setting unless you
          understand how the relevant AOP proxy handles optimization. This is
          currently used only for CGLIB proxies; it has no effect with JDK
          dynamic proxies (the default).</p></li><li><p><code class="literal">frozen</code>: whether advice changes should be
          disallowed once the proxy factory has been configured. Default is
          false.</p></li><li><p><code class="literal">exposeProxy</code>: whether the current proxy
          should be exposed in a ThreadLocal so that it can be accessed by the
          target. (It's available via the MethodInvocation without the need
          for a ThreadLocal.) If a target needs to obtain the proxy and
          exposeProxy is true, the target can use the
          <code class="literal">AopContext.currentProxy()</code> method.</p></li><li><p><code class="literal">aopProxyFactory</code>: the implementation of
          AopProxyFactory to use. Offers a way of customizing whether to use
          dynamic proxies, CGLIB or any other proxy strategy. The default
          implementation will choose dynamic proxies or CGLIB appropriately.
          There should be no need to use this property; it's intended to allow
          the addition of new proxy types in Spring 1.1.</p></li></ul></div><p>Other properties specific to <code class="literal">ProxyFactory</code>Bean
      include:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">proxyInterfaces</code>: array of String interface
          names. If this isn't supplied, a CGLIB proxy for the target class
          will be used</p></li><li><p><code class="literal">interceptorNames</code>: String array of Advisor,
          interceptor or other advice names to apply. Ordering is significant.
          First come, first serve that is. The first interceptor in the list
          will be the first to be able to intercept the invocation (of course
          if it concerns a regular <code class="literal">MethodInterceptor</code> or
          <code class="literal">BeforeAdvice</code>.</p><p>The names are bean names in the current factory, including bean
          names from ancestor factories. You can't mention bean references
          here since doing so would result in the ProxyFactoryBean ignoring
          the singleton setting of the advise.</p><p>You can append an interceptor name with an asterisk (*).
          This will result in the application of all advisor beans with names starting
          with the part before the asterisk to be applied. An example of using
          this feature can be found below.</p></li><li><p>singleton: whether or not the factory should return a single
          object, no matter how often the <code class="literal">getObject()</code>
          method is called. Several <code class="literal">FactoryBean</code>
          implementations offer such a method. Default value is true. If you
          want to use stateful advice--for example, for stateful mixins--use
          prototype advices along with a singleton value of false.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4440"></a>6.5.3.&nbsp;Proxying interfaces</h3></div></div></div><p>Let's look at a simple example of ProxyFactoryBean in action. This
      example involves:</p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>target bean</em></span> that will be proxied. This
          is the "personTarget" bean definition in the example below.</p></li><li><p>An Advisor and an Interceptor used to provide advice.</p></li><li><p>An AOP proxy bean definition specifying the target object (the
          personTarget bean) and the interfaces to proxy, along with the
          advices to apply.</p></li></ul></div><pre class="programlisting">&lt;bean id="personTarget" class="com.mycompany.PersonImpl"&gt;
    &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
    &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"&gt;
&lt;/bean&gt;

&lt;bean id="person" 
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;

    &lt;property name="target"&gt;&lt;ref local="personTarget"/&gt;&lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the <code class="literal">interceptorNames</code> property takes a
      list of String: the bean names of the interceptor or advisors in the
      current factory. Advisors, interceptors, before, after returning and
      throws advice objects can be used. The ordering of advisors is
      significant.</p><p class="remark"><i><span class="remark">You might be wondering why the list doesn't hold bean
      references. The reason for this is that if the ProxyFactoryBean's
      singleton property is set to false, it must be able to return
      independent proxy instances. If any of the advisors is itself a
      prototype, an independent instance would need to be returned, so it's
      necessary to be able to obtain an instance of the prototype from the
      factory; holding a reference isn't sufficient.</span></i></p><p>The "person" bean definition above can be used in place of a
      Person implementation, as follows:</p><pre class="programlisting">Person person = (Person) factory.getBean("person");</pre><p>Other beans in the same IoC context can express a strongly typed
      dependency on it, as with an ordinary Java object:</p><pre class="programlisting">&lt;bean id="personUser" class="com.mycompany.PersonUser"&gt;
  &lt;property name="person"&gt;&lt;ref local="person" /&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The <code class="literal">PersonUser</code> class in this example would
      expose a property of type Person. As far as it's concerned, the AOP
      proxy can be used transparently in place of a "real" person
      implementation. However, its class would be a dynamic proxy class. It
      would be possible to cast it to the <code class="literal">Advised</code> interface
      (discussed below).</p><p>It's possible to conceal the distinction between target and proxy
      using an anonymous <span class="emphasis"><em>inner bean</em></span>, as follows. Only the
      <code class="literal">ProxyFactoryBean</code> definition is different; the advice
      is included only for completeness:</p><pre class="programlisting">&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
  &lt;property name="someProperty"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;

&lt;bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="proxyInterfaces"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;
  &lt;!-- Use inner bean, not local reference to target --&gt;
  &lt;property name="target"&gt;
    &lt;bean class="com.mycompany.PersonImpl"&gt;
      &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
      &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;myAdvisor&lt;/value&gt;
      &lt;value&gt;debugInterceptor&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>This has the advantage that there's only one object of type
      <code class="literal">Person</code>: useful if we want to prevent users of the
      application context obtaining a reference to the un-advised object, or
      need to avoid any ambiguity with Spring IoC
      <span class="emphasis"><em>autowiring</em></span>. There's also arguably an advantage in
      that the ProxyFactoryBean definition is self-contained. However, there
      are times when being able to obtain the un-advised target from the
      factory might actually be an <span class="emphasis"><em>advantage</em></span>: for
      example, in certain test scenarios.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4507"></a>6.5.4.&nbsp;Proxying classes</h3></div></div></div><p>What if you need to proxy a class, rather than one or more
      interfaces?</p><p>Imagine that in our example above, there was no
      <code class="literal">Person</code> interface: we needed to advise a class called
      <code class="literal">Person</code> that didn't implement any business interface.
      In this case, you can configure Spring to use CGLIB proxying, rather
      than dynamic proxies. Simply set the <code class="literal">proxyTargetClass</code>
      property on the ProxyFactoryBean above to true. While it's best to
      program to interfaces, rather than classes, the ability to advise
      classes that don't implement interfaces can be useful when working with
      legacy code. (In general, Spring isn't prescriptive. While it makes it
      easy to apply good practices, it avoids forcing a particular
      approach.)</p><p>If you want to you can force the use of CGLIB in any case, even if
      you do have interfaces.</p><p>CGLIB proxying works by generating a subclass of the target class
      at runtime. Spring configures this generated subclass to delegate method
      calls to the original target: the subclass is used to implement the
      <span class="emphasis"><em>Decorator</em></span> pattern, weaving in the advice.</p><p>CGLIB proxying should generally be transparent to users. However,
      there are some issues to consider:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">Final</code> methods can't be advised, as they
          can't be overridden.</p></li><li><p>You'll need the CGLIB 2 binaries on your classpath; dynamic
          proxies are available with the JDK</p></li></ul></div><p>There's little performance difference between CGLIB proxying and
      dynamic proxies. As of Spring 1.0, dynamic proxies are slightly faster.
      However, this may change in the future. Performance should not be a
      decisive consideration in this case.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4543"></a>6.5.5.&nbsp;Using 'global' advisors</h3></div></div></div><p>
            By appending an asterisk to an interceptor name, all advisors with
            bean names matching the part before the asterisk, will be added
            to the advisor chain. This can come in handy if you need to add a
            standard set of 'global' advisors:
</p><pre class="programlisting">
&lt;bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="target" ref="service"/&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;global*&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;
&lt;bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/&gt;
</pre><p>
        </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-tfb"></a>6.6.&nbsp;Convenient proxy creation</h2></div></div></div><p>Often we don't need the full power of the
    <code class="literal">ProxyFactoryBean</code>, because we're only interested in one
    aspect: For example, transaction management.</p><p>There are a number of convenience factories we can use to create AOP
    proxies when we want to focus on a specific aspect. These are discussed in
    other chapters, so we'll just provide a quick survey of some of them
    here.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4561"></a>6.6.1.&nbsp;TransactionProxyFactoryBean</h3></div></div></div><p>The <span class="bold"><strong>JPetStore</strong></span> sample application
      shipped with Spring shows the use of the
      TransactionProxyFactoryBean.</p><p>The <code class="literal">TransactionProxyFactoryBean</code> is a subclass
      of <code class="literal">ProxyConfig</code>, so basic configuration is shared with
      <code class="literal">ProxyFactoryBean</code>. (See list of
      <code class="literal">ProxyConfig</code> properties above.)</p><p>The following example from the JPetStore illustrates how this
      works. As with a <code class="literal">ProxyFactoryBean</code>, there is a target
      bean definition. Dependencies should be expressed on the proxied factory
      bean definition ("petStore" here), rather than the target POJO
      ("petStoreTarget").</p><p>The <code class="literal">TransactionProxyFactoryBean</code> requires a
      target, and information about "transaction attributes," specifying which
      methods should be transactional and the required propagation and other
      settings:</p><pre class="programlisting">&lt;bean id="petStoreTarget" class="org.springframework.samples.jpetstore.domain.logic.PetStoreImpl"&gt;
  &lt;property name="accountDao"&gt;&lt;ref bean="accountDao"/&gt;&lt;/property&gt;
  &lt;!-- Other dependencies omitted --&gt;
&lt;/bean&gt;

&lt;bean id="petStore" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="target" ref="petStoreTarget"/&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="insert*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
      &lt;prop key="update*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
      &lt;prop key="*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>As with the <code class="literal">ProxyFactoryBean</code>, we might choose
      to use an inner bean to set the value of <code class="literal">target</code>
      property, instead of a reference to a top-level target bean.</p><p>The <code class="literal">TransactionProxyFactoryBean</code> automatically
      creates a transaction advisor, including a pointcut based on the
      transaction attributes, so only transactional methods are
      advised.</p><p>The <code class="literal">TransactionProxyFactoryBean</code> allows the
      specification of "pre" and "post" advice, using the preInterceptors and
      postInterceptors properties. These take Object arrays of interceptors,
      other advice or Advisors to place in the interception chain before or
      after the transaction interceptor. These can be populated using a
      &lt;list&gt; element in XML bean definitions, as follows:</p><pre class="programlisting">&lt;property name="preInterceptors"&gt;
  &lt;list&gt;
    &lt;ref bean="authorizationInterceptor"/&gt;
    &lt;ref bean="notificationBeforeAdvice"/&gt;
  &lt;/list&gt;
&lt;/property&gt;
&lt;property name="postInterceptors"&gt;
  &lt;list&gt;
    &lt;ref bean="myAdvisor"/&gt;
  &lt;/list&gt;
&lt;/property&gt;</pre><p>These properties could be added to the "petStore" bean definition
      above. A common usage is to combine transactionality with declarative
      security: a similar approach to that offered by EJB.</p><p>Because of the use of actual instance references, rather than bean
      names as in <code class="literal">ProxyFactoryBean</code>, pre and post
      interceptors can be used only for shared-instance advice. Thus they are
      not useful for stateful advice: for example, in mixins. This is
      consistent with the TransactionProxyFactoryBean's purpose. It provides a
      simple way of doing common transaction setup. If you need more complex,
      customized, AOP, consider using the generic
      <code class="literal">ProxyFactoryBean</code>, or an auto proxy creator (see
      below).</p><p class="remark"><i><span class="remark">Especially if we view Spring AOP as, in many cases, a
      replacement for EJB, we find that most advice is fairly generic and uses
      a shared-instance model. Declarative transaction management and security
      checks are classic examples.</span></i></p><p>The <code class="literal">TransactionProxyFactoryBean</code> depends on a
      <code class="literal">PlatformTransactionManager</code> implementation via its
      <code class="literal">transactionManager</code> JavaBean property. This allows for
      pluggable transaction implementation, based on JTA, JDBC or other
      strategies. This relates to the Spring transaction abstraction, rather
      than AOP. We'll discuss the transaction infrastructure in the next
      chapter.</p><p class="remark"><i><span class="remark">If you're interested only in declarative transaction management,
      the TransactionProxyFactoryBean is a good solution, and simpler than
      using a ProxyFactoryBean.</span></i></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4642"></a>6.6.2.&nbsp;EJB proxies</h3></div></div></div><p>Other dedicated proxies create proxies for EJBs, enabling the EJB
      "business methods" interface to be used directly by calling code.
      Calling code does not need to perform JNDI lookups or use EJB create
      methods: A significant improvement in readability and architectural
      flexibility.</p><p>See the chapter on Spring EJB services in this manual for further
      information.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-concise-proxy"></a>6.7.&nbsp;Concise proxy definitions</h2></div></div></div><p>Especially when defining transactional proxies, you may end up with
    many similar proxy definitions. The use of parent and child bean
    definitions, along with inner bean definitions, can result in much cleaner
    and more concise proxy definitions.</p><p>First a parent, <span class="emphasis"><em>template</em></span>, bean definition is
    created for the proxy:</p><pre class="programlisting">&lt;bean id="txProxyTemplate" abstract="true"
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>This will never be instantiated itself, so may actually be
    incomplete. Then each proxy which needs to be created is just a child bean
    definition, which to wraps the target of the proxy as an inner bean
    definition, since the target will never be used on its own
    anyways.</p><pre class="programlisting">&lt;bean id="myService" parent="txProxyTemplate"&gt;
  &lt;property name="target"&gt;
    &lt;bean class="org.springframework.samples.MyServiceImpl"&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>It is of course possible to override properties from the parent
    template, such as in this case, the transaction propagation
    settings:</p><pre class="programlisting">&lt;bean id="mySpecialService" parent="txProxyTemplate"&gt;
  &lt;property name="target"&gt;
    &lt;bean class="org.springframework.samples.MySpecialServiceImpl"&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="find*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="load*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="store*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that in the example above, we have explicitly marked the parent
    bean definition as <span class="emphasis"><em>abstract</em></span> by using the
    <span class="emphasis"><em>abstract</em></span> attribute, as described <a href="#beans-child-bean-definitions" title="3.5.&nbsp;Abstract and child bean definitions">previously</a>, so that it may
	not actually ever be instantiated. Application contexts (but not
    simple bean factories) will by default pre-instantiate all singletons.
    Therefore it is important (at least for singleton beans) that if you have
    a (parent) bean definition which you intend to use only as a template, and
    this definition specifies a class, you must make sure to set the
    <span class="emphasis"><em>abstract</em></span> attribute to <span class="emphasis"><em>true</em></span>,
    otherwise the application context will actually try to pre-instantiate it.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-prog"></a>6.8.&nbsp;Creating AOP proxies programmatically with the ProxyFactory</h2></div></div></div><p>It's easy to create AOP proxies programmatically using Spring. This
    enables you to use Spring AOP without dependency on Spring IoC.</p><p>The following listing shows creation of a proxy for a target object,
    with one interceptor and one advisor. The interfaces implemented by the
    target object will automatically be proxied:</p><pre class="programlisting">ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addInterceptor(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</pre><p>The first step is to construct a object of type
    <code class="literal">org.springframework.aop.framework.ProxyFactory</code>. You can
    create this with a target object, as in the above example, or specify the
    interfaces to be proxied in an alternate constructor.</p><p>You can add interceptors or advisors, and manipulate them for the
    life of the ProxyFactory. If you add an
    IntroductionInterceptionAroundAdvisor you can cause the proxy to implement
    additional interfaces.</p><p>There are also convenience methods on ProxyFactory (inherited from
    AdvisedSupport) allowing you to add other advice types such as before and
    throws advice. AdvisedSupport is the superclass of both ProxyFactory and
    ProxyFactoryBean.</p><p class="remark"><i><span class="remark">Integrating AOP proxy creation with the IoC framework is best
    practice in most applications. We recommend that you externalize
    configuration from Java code with AOP, as in general.</span></i></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e4708"></a>6.9.&nbsp;Manipulating advised objects</h2></div></div></div><p>However you create AOP proxies, you can manipulate them using the
    <code class="literal">org.springframework.aop.framework.Advised</code> interface.
    Any AOP proxy can be cast to this interface, whatever other interfaces it
    implements. This interface includes the following methods:</p><pre class="programlisting">Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) 
        throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();</pre><p>The <code class="literal">getAdvisors()</code> method will return an Advisor
    for every advisor, interceptor or other advice type that has been added to
    the factory. If you added an Advisor, the returned advisor at this index
    will be the object that you added. If you added an interceptor or other
    advice type, Spring will have wrapped this in an advisor with a pointcut
    that always returns true. Thus if you added a
    <code class="literal">MethodInterceptor</code>, the advisor returned for this index
    will be an <code class="literal">DefaultPointcutAdvisor</code> returning your
    <code class="literal">MethodInterceptor</code> and a pointcut that matches all
    classes and methods.</p><p>The <code class="literal">addAdvisor()</code> methods can be used to add any
    Advisor. Usually the advisor holding pointcut and advice will be the
    generic <code class="literal">DefaultPointcutAdvisor</code>, which can be used with
    any advice or pointcut (but not for introduction).</p><p>By default, it's possible to add or remove advisors or interceptors
    even once a proxy has been created. The only restriction is that it's
    impossible to add or remove an introduction advisor, as existing proxies
    from the factory will not show the interface change. (You can obtain a new
    proxy from the factory to avoid this problem.)</p><p>A simple example of casting an AOP proxy to the
    <code class="literal">Advised</code> interface and examining and manipulating its
    advice:</p><pre class="programlisting">Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + " advisors");

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(new DebugInterceptor());

// Add selective advice using a pointcut
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals("Added two advisors",
     oldAdvisorCount + 2, advised.getAdvisors().length);</pre><p class="remark"><i><span class="remark">It's questionable whether it's advisable (no pun intended) to
    modify advice on a business object in production, although there are no
    doubt legitimate usage cases. However, it can be very useful in
    development: for example, in tests. I have sometimes found it very useful
    to be able to add test code in the form of an interceptor or other advice,
    getting inside a method invocation I want to test. (For example, the
    advice can get inside a transaction created for that method: for example,
    to run SQL to check that a database was correctly updated, before marking
    the transaction for roll back.)</span></i></p><p>Depending on how you created the proxy, you can usually set a
    <code class="literal">frozen</code> flag, in which case the
    <code class="literal">Advised</code> <code class="literal">isFrozen()</code> method will
    return true, and any attempts to modify advice through addition or removal
    will result in an <code class="literal">AopConfigException</code>. The ability to
    freeze the state of an advised object is useful in some cases: For
    example, to prevent calling code removing a security interceptor. It may
    also be used in Spring 1.1 to allow aggressive optimization if runtime
    advice modification is known not to be required.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-autoproxy"></a>6.10.&nbsp;Using the "autoproxy" facility</h2></div></div></div><p>So far we've considered explicit creation of AOP proxies using a
    <code class="literal">ProxyFactoryBean</code> or similar factory bean.</p><p>Spring also allows us to use "autoproxy" bean definitions, which can
    automatically proxy selected bean definitions. This is built on Spring
    "bean post processor" infrastructure, which enables modification of any
    bean definition as the container loads.</p><p>In this model, you set up some special bean definitions in your XML
    bean definition file configuring the auto proxy infrastructure. This
    allows you just to declare the targets eligible for autoproxying: you
    don't need to use <code class="literal">ProxyFactoryBean</code>.</p><p>There are two ways to do this:</p><div class="itemizedlist"><ul type="disc"><li><p>Using an autoproxy creator that refers to specific beans in the
        current context</p></li><li><p>A special case of autoproxy creation that deserves to be
        considered separately; autoproxy creation driven by source-level
        metadata attributes</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-autoproxy-choices"></a>6.10.1.&nbsp;Autoproxy bean definitions</h3></div></div></div><p>The <code class="literal">org.springframework.aop.framework.autoproxy</code>
      package provides the following standard autoproxy creators.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4798"></a>6.10.1.1.&nbsp;BeanNameAutoProxyCreator</h4></div></div></div><p>The BeanNameAutoProxyCreator automatically creates AOP proxies
        for beans with names matching literal values or wildcards.</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
  &lt;property name="beanNames"&gt;&lt;value&gt;jdk*,onlyJdk&lt;/value&gt;&lt;/property&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;myInterceptor&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>As with <code class="literal">ProxyFactoryBean</code>, there is an
        interceptorNames property rather than a list of interceptor, to allow
        correct behavior for prototype advisors. Named "interceptors" can be
        advisors or any advice type.</p><p>As with auto proxying in general, the main point of using
        <code class="literal">BeanNameAutoProxyCreator</code> is to apply the same
        configuration consistently to multiple objects, and with minimal
        volume of configuration. It is a popular choice for applying
        declarative transactions to multiple objects.</p><p>Bean definitions whose names match, such as "jdkMyBean" and
        "onlyJdk" in the above example, are plain old bean definitions with
        the target class. An AOP proxy will be created automatically by the
        <code class="literal">BeanNameAutoProxyCreator</code>. The same advice will be
        applied to all matching beans. Note that if advisors are used (rather
        than the interceptor in the above example), the pointcuts may apply
        differently to different beans.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4821"></a>6.10.1.2.&nbsp;DefaultAdvisorAutoProxyCreator</h4></div></div></div><p>A more general and extremely powerful auto proxy creator is
        <code class="literal">DefaultAdvisorAutoProxyCreator</code>. This will
        automagically apply eligible advisors in the current context, without
        the need to include specific bean names in the autoproxy advisor's
        bean definition. It offers the same merit of consistent configuration
        and avoidance of duplication as
        <code class="literal">BeanNameAutoProxyCreator</code>.</p><p>Using this mechanism involves:</p><div class="itemizedlist"><ul type="disc"><li><p>Specifying a
            <code class="literal">DefaultAdvisorAutoProxyCreator</code> bean
            definition</p></li><li><p>Specifying any number of Advisors in the same or related
            contexts. Note that these <span class="emphasis"><em>must</em></span> be Advisors,
            not just interceptors or other advices. This is necessary because
            there must be a pointcut to evaluate, to check the eligibility of
            each advice to candidate bean definitions.</p></li></ul></div><p>The <code class="literal">DefaultAdvisorAutoProxyCreator</code> will
        automatically evaluate the pointcut contained in each advisor, to see
        what (if any) advice it should apply to each business object (such as
        "businessObject1" and "businessObject2" in the example).</p><p>This means that any number of advisors can be applied
        automatically to each business object. If no pointcut in any of the
        advisors matches any method in a business object, the object will not
        be proxied. As bean definitions are added for new business objects,
        they will automatically be proxied if necessary.</p><p>Autoproxying in general has the advantage of making it
        impossible for callers or dependencies to obtain an un-advised object.
        Calling getBean("businessObject1") on this ApplicationContext will
        return an AOP proxy, not the target business object. (The "inner bean"
        idiom shown earlier also offers this benefit.)</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="customAdvisor" class="com.mycompany.MyAdvisor"/&gt;

&lt;bean id="businessObject1" class="com.mycompany.BusinessObject1"&gt;
  &lt;!-- Properties omitted --&gt;
&lt;/bean&gt;

&lt;bean id="businessObject2" class="com.mycompany.BusinessObject2"/&gt;
</pre><p>The <code class="literal">DefaultAdvisorAutoProxyCreator</code> is very
        useful if you want to apply the same advice consistently to many
        business objects. Once the infrastructure definitions are in place,
        you can simply add new business objects without including specific
        proxy configuration. You can also drop in additional aspects very
        easily--for example, tracing or performance monitoring aspects--with
        minimal change to configuration.</p><p>The DefaultAdvisorAutoProxyCreator offers support for filtering
        (using a naming convention so that only certain advisors are
        evaluated, allowing use of multiple, differently configured,
        AdvisorAutoProxyCreators in the same factory) and ordering. Advisors
        can implement the <code class="literal">org.springframework.core.Ordered</code>
        interface to ensure correct ordering if this is an issue. The
        TransactionAttributeSourceAdvisor used in the above example has a
        configurable order value; default is unordered.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e4869"></a>6.10.1.3.&nbsp;AbstractAdvisorAutoProxyCreator</h4></div></div></div><p>This is the superclass of DefaultAdvisorAutoProxyCreator. You
        can create your own autoproxy creators by subclassing this class, in
        the unlikely event that advisor definitions offer insufficient
        customization to the behavior of the framework
        <code class="literal">DefaultAdvisorAutoProxyCreator</code>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-autoproxy-metadata"></a>6.10.2.&nbsp;Using metadata-driven auto-proxying</h3></div></div></div><p>A particularly important type of autoproxying is driven by
      metadata. This produces a similar programming model to .NET
      <code class="literal">ServicedComponents</code>. Instead of using XML deployment
      descriptors as in EJB, configuration for transaction management and
      other enterprise services is held in source-level attributes.</p><p>In this case, you use the
      <code class="literal">DefaultAdvisorAutoProxyCreator</code>, in combination with
      Advisors that understand metadata attributes. The metadata specifics are
      held in the pointcut part of the candidate advisors, rather than in the
      autoproxy creation class itself.</p><p>This is really a special case of the
      <code class="literal">DefaultAdvisorAutoProxyCreator</code>, but deserves
      consideration on its own. (The metadata-aware code is in the pointcuts
      contained in the advisors, not the AOP framework itself.)</p><p>The <code class="literal">/attributes</code> directory of the JPetStore
      sample application shows the use of attribute-driven autoproxying. In
      this case, there's no need to use the
      <code class="literal">TransactionProxyFactoryBean</code>. Simply defining
      transactional attributes on business objects is sufficient, because of
      the use of metadata-aware pointcuts. The bean definitions include the
      following code, in <code class="literal">/WEB-INF/declarativeServices.xml</code>.
      Note that this is generic, and can be used outside the JPetStore:</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.interceptor.AttributesTransactionAttributeSource"&gt;
      &lt;property name="attributes" ref="attributes"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="attributes" class="org.springframework.metadata.commons.CommonsAttributes"/&gt;</pre><p>The <code class="literal">DefaultAdvisorAutoProxyCreator</code> bean
      definition (the name is not significant, hence it can even be omitted)
      will pick up all eligible pointcuts in the current application context.
      In this case, the "transactionAdvisor" bean definition, of type
      <code class="literal">TransactionAttributeSourceAdvisor</code>, will apply to
      classes or methods carrying a transaction attribute. The
      TransactionAttributeSourceAdvisor depends on a TransactionInterceptor,
      via constructor dependency. The example resolves this via autowiring.
      The <code class="literal">AttributesTransactionAttributeSource</code> depends on
      an implementation of the
      <code class="literal">org.springframework.metadata.Attributes</code> interface. In
      this fragment, the "attributes" bean satisfies this, using the Jakarta
      Commons Attributes API to obtain attribute information. (The application
      code must have been compiled using the Commons Attributes compilation
      task.)</p><p>The <code class="literal">/annotation</code> directory of the JPetStore
			sample application contains an analogous example for auto-proxying
			driven by JDK 1.5+ annotations. The following configuration enables
      automatic detection of Spring's <code class="literal">Transactional</code>
      annotation, leading to implicit proxies for beans containing that
      annotation:</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The <code class="literal">TransactionInterceptor</code> defined here depends
      on a <code class="literal">PlatformTransactionManager</code> definition, which is
      not included in this generic file (although it could be) because it will
      be specific to the application's transaction requirements (typically
      JTA, as in this example, or Hibernate, JDO or JDBC):</p><pre class="programlisting">&lt;bean id="transactionManager" 
    class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre><p class="remark"><i><span class="remark">If you require only declarative transaction management, using
      these generic XML definitions will result in Spring automatically
      proxying all classes or methods with transaction attributes. You won't
      need to work directly with AOP, and the programming model is similar to
      that of .NET ServicedComponents.</span></i></p><p>This mechanism is extensible. It's possible to do autoproxying
      based on custom attributes. You need to:</p><div class="itemizedlist"><ul type="disc"><li><p>Define your custom attribute.</p></li><li><p>Specify an Advisor with the necessary advice, including a
          pointcut that is triggered by the presence of the custom attribute
          on a class or method. You may be able to use an existing advice,
          merely implementing a static pointcut that picks up the custom
          attribute.</p></li></ul></div><p>It's possible for such advisors to be unique to each advised class
      (for example, mixins): they simply need to be defined as prototype,
      rather than singleton, bean definitions. For example, the
      <code class="literal">LockMixin</code> introduction interceptor from the Spring
      test suite, shown above, could be used in conjunction with an
      attribute-driven pointcut to target a mixin, as shown here. We use the
      generic <code class="literal">DefaultPointcutAdvisor</code>, configured using
      JavaBean properties:</p><pre class="programlisting">&lt;bean id="lockMixin" class="org.springframework.aop.LockMixin"
    singleton="false"/&gt;

&lt;bean id="lockableAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"
    singleton="false"&gt;
  &lt;property name="pointcut" ref="myAttributeAwarePointcut"/&gt;
  &lt;property name="advice" ref="lockMixin"/&gt;
&lt;/bean&gt;

&lt;bean id="anyBean" class="anyclass" ...</pre><p>If the attribute aware pointcut matches any methods in the
      <code class="literal">anyBean</code> or other bean definitions, the mixin will be
      applied. Note that both <code class="literal">lockMixin</code> and
      <code class="literal">lockableAdvisor</code> definitions are prototypes. The
      <code class="literal">myAttributeAwarePointcut</code> pointcut can be a singleton
      definition, as it doesn't hold state for individual advised
      objects.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-targetsource"></a>6.11.&nbsp;Using TargetSources</h2></div></div></div><p>Spring offers the concept of a <span class="emphasis"><em>TargetSource</em></span>,
    expressed in the <code class="literal">org.springframework.aop.TargetSource</code>
    interface. This interface is responsible for returning the "target object"
    implementing the joinpoint. The <code class="literal">TargetSource</code>
    implementation is asked for a target instance each time the AOP proxy
    handles a method invocation.</p><p>Developers using Spring AOP don't normally need to work directly
    with TargetSources, but this provides a powerful means of supporting
    pooling, hot swappable and other sophisticated targets. For example, a
    pooling TargetSource can return a different target instance for each
    invocation, using a pool to manage instances.</p><p>If you do not specify a TargetSource, a default implementation is
    used that wraps a local object. The same target is returned for each
    invocation (as you would expect).</p><p>Let's look at the standard target sources provided with Spring, and
    how you can use them.</p><p class="remark"><i><span class="remark">When using a custom target source, your target will usually need
    to be a prototype rather than a singleton bean definition. This allows
    Spring to create a new target instance when required.</span></i></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-swap"></a>6.11.1.&nbsp;Hot swappable target sources</h3></div></div></div><p>The
      <code class="literal">org.springframework.aop.target.HotSwappableTargetSource</code>
      exists to allow the target of an AOP proxy to be switched while allowing
      callers to keep their references to it.</p><p>Changing the target source's target takes effect immediately. The
      <code class="literal">HotSwappableTargetSource</code> is threadsafe.</p><p>You can change the target via the <code class="literal">swap()</code> method
      on HotSwappableTargetSource as follows:</p><pre class="programlisting">HotSwappableTargetSource swapper = 
    (HotSwappableTargetSource) beanFactory.getBean("swapper");
Object oldTarget = swapper.swap(newTarget);</pre><p>The XML definitions required look as follows:</p><pre class="programlisting">&lt;bean id="initialTarget" class="mycompany.OldTarget"/&gt;

&lt;bean id="swapper" class="org.springframework.aop.target.HotSwappableTargetSource"&gt;
  &lt;constructor-arg ref="initialTarget"/&gt;
&lt;/bean&gt;

&lt;bean id="swappable" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="targetSource" ref="swapper"/&gt;
&lt;/bean&gt;</pre><p>The above <code class="literal">swap()</code> call changes the target of the
      swappable bean. Clients who hold a reference to that bean will be
      unaware of the change, but will immediately start hitting the new
      target.</p><p>Although this example doesn't add any advice--and it's not
      necessary to add advice to use a <code class="literal">TargetSource</code>--of
      course any <code class="literal">TargetSource</code> can be used in conjunction
      with arbitrary advice.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-pool"></a>6.11.2.&nbsp;Pooling target sources</h3></div></div></div><p>Using a pooling target source provides a similar programming model
      to stateless session EJBs, in which a pool of identical instances is
      maintained, with method invocations going to free objects in the
      pool.</p><p>A crucial difference between Spring pooling and SLSB pooling is
      that Spring pooling can be applied to any POJO. As with Spring in
      general, this service can be applied in a non-invasive way.</p><p>Spring provides out-of-the-box support for Jakarta Commons Pool
      1.1, which provides a fairly efficient pooling implementation. You'll
      need the commons-pool Jar on your application's classpath to use this
      feature. It's also possible to subclass
      <code class="literal">org.springframework.aop.target.AbstractPoolingTargetSource</code>
      to support any other pooling API.</p><p>Sample configuration is shown below:</p><pre class="programlisting">&lt;bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject" 
    singleton="false"&gt;
  ... properties omitted
&lt;/bean&gt;

&lt;bean id="poolTargetSource" class="org.springframework.aop.target.CommonsPoolTargetSource"&gt;
  &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
  &lt;property name="maxSize" value="25"/&gt;
&lt;/bean&gt;

&lt;bean id="businessObject" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="targetSource" ref="poolTargetSource"/&gt;
  &lt;property name="interceptorNames" value="myInterceptor"/&gt;
&lt;/bean&gt;</pre><p>Note that the target object--"businessObjectTarget" in the
      example--<span class="emphasis"><em>must</em></span> be a prototype. This allows the
      <code class="literal">PoolingTargetSource</code> implementation to create new
      instances of the target to grow the pool as necessary. See the Javadoc
      for <code class="literal">AbstractPoolingTargetSource</code> and the concrete
      subclass you wish to use for information about it's properties: maxSize
      is the most basic, and always guaranteed to be present.</p><p>In this case, "myInterceptor" is the name of an interceptor that
      would need to be defined in the same IoC context. However, it isn't
      necessary to specify interceptors to use pooling. If you want only
      pooling, and no other advice, don't set the interceptorNames property at
      all.</p><p>It's possible to configure Spring so as to be able to cast any
      pooled object to the
      <code class="literal">org.springframework.aop.target.PoolingConfig</code>
      interface, which exposes information about the configuration and current
      size of the pool through an introduction. You'll need to define an
      advisor like this:</p><pre class="programlisting">&lt;bean id="poolConfig" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetObject" ref="poolTargetSource"/&gt;
  &lt;property name="targetMethod" value="getPoolingConfigMixin"/&gt;
&lt;/bean&gt;</pre><p>This advisor is obtained by calling a convenience method on the
      <code class="literal">AbstractPoolingTargetSource</code> class, hence the use of
      MethodInvokingFactoryBean. This advisor's name ("poolConfigAdvisor"
      here) must be in the list of interceptors names in the ProxyFactoryBean
      exposing the pooled object.</p><p>The cast will look as follows:</p><pre class="programlisting">PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
System.out.println("Max pool size is " + conf.getMaxSize());</pre><p class="remark"><i><span class="remark">Pooling stateless service objects is not usually necessary. We
      don't believe it should be the default choice, as most stateless objects
      are naturally thread safe, and instance pooling is problematic if
      resources are cached.</span></i></p><p>Simpler pooling is available using autoproxying. It's possible to
      set the TargetSources used by any autoproxy creator.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-prototype"></a>6.11.3.&nbsp;Prototype target sources</h3></div></div></div><p>Setting up a "prototype" target source is similar to a pooling
      TargetSource. In this case, a new instance of the target will be created
      on every method invocation. Although the cost of creating a new object
      isn't high in a modern JVM, the cost of wiring up the new object
      (satisfying its IoC dependencies) may be more expensive. Thus you
      shouldn't use this approach without very good reason.</p><p>To do this, you could modify the
      <code class="literal">poolTargetSource</code> definition shown above as follows.
      (I've also changed the name, for clarity.)</p><pre class="programlisting">&lt;bean id="prototypeTargetSource" class="org.springframework.aop.target.PrototypeTargetSource"&gt;
  &lt;property name="targetBeanName" ref="businessObjectTarget"/&gt;
&lt;/bean&gt;</pre><p>There's only one property: the name of the target bean.
      Inheritance is used in the TargetSource implementations to ensure
      consistent naming. As with the pooling target source, the target bean
      must be a prototype bean definition.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-threadlocal"></a>6.11.4.&nbsp;ThreadLocal target sources</h3></div></div></div><p>
            ThreadLocal target sources are useful if you need an object to be created
            for each incoming request (per thread that is). The concept of a
            <code class="literal">ThreadLocal</code> provide a JDK-wide facility to transparently
						store resource alongside a thread. Setting up a ThreadLocalTargetSource
            is pretty much the same as was explained for the other target sources:
        </p><p>
            </p><pre class="programlisting">&lt;bean id="threadlocalTargetSource" class="org.springframework.aop.target.ThreadLocalTargetSource"&gt;
  &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
&lt;/bean&gt;</pre><p>
        </p><p>
            <span class="emphasis"><em>ThreadLocals come with serious issues (potentially resulting in memory leaks)
            when incorrectly using them in a multi-threaded and multi-classloader environments. One should
            always consider wrapping a threadlocal in some other class and never directly use the ThreadLocal
            itself (except of course in the wrapper class). Also, one should always remember to correctly set and unset (where the
            latter simply involved a call to ThreadLocal.set(null)) the resource local to the thread.
            Unsetting should be done in any case since not unsetting it might result in problematic behavior.
            Spring's ThreadLocal support is doing this for you and should always be considered in favor of
            using ThreadLocals without other proper handling code.</em></span>
                                           </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-extensibility"></a>6.12.&nbsp;Defining new Advice types</h2></div></div></div><p>Spring AOP is designed to be extensible. While the interception
    implementation strategy is presently used internally, it is possible to
    support arbitrary advice types in addition to interception around advice,
    before, throws advice and after returning advice, which are supported out
    of the box.</p><p>The <code class="literal">org.springframework.aop.framework.adapter</code>
    package is an SPI package allowing support for new custom advice types to
    be added without changing the core framework. The only constraint on a
    custom Advice type is that it must implement the
    <code class="literal">org.aopalliance.aop.Advice</code> tag interface.</p><p>Please refer to the
    <code class="literal">org.springframework.aop.framework.adapter</code> package's
    Javadocs for further information</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5144"></a>6.13.&nbsp;Further reading and resources</h2></div></div></div><p>I recommend the excellent <span class="emphasis"><em>AspectJ in Action</em></span> by
    Ramnivas Laddad (Manning, 2003) for an introduction to AOP.</p><p>Please refer to the Spring sample applications for further examples
    of Spring AOP:</p><div class="itemizedlist"><ul type="disc"><li><p>The JPetStore's default configuration illustrates the use of the
        TransactionProxyFactoryBean for declarative transaction
        management</p></li><li><p>The <code class="literal">/attributes</code> directory of the JPetStore
        illustrates the use of attribute-driven declarative transaction
        management</p></li></ul></div><p>If you are interested in more advanced capabilities of Spring AOP,
    take a look at the test suite. The test coverage is over 90%, and this
    illustrates advanced features not discussed in this document.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="aspectj"></a>Chapter&nbsp;7.&nbsp;AspectJ Integration</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5169"></a>7.1.&nbsp;Overview</h2></div></div></div><p>Spring's proxy-based AOP framework is well suited for handling
    many generic middleware and application-specific problems. However, there
    are times when a more powerful AOP solution is required: for example, if
    we need to add additional fields to a class, or advise fine-grained
    objects that aren't created by the Spring IoC container.</p><p>We recommend the use of AspectJ in such cases. Accordingly, as of
    version 1.1, Spring provides a powerful integration with AspectJ.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5176"></a>7.2.&nbsp;Configuring AspectJ aspects using Spring IoC</h2></div></div></div><p>The most important part of the Spring/AspectJ integration allows
    Spring to configure AspectJ aspects using Dependency Injection. This
    brings similar benefits to aspects as to objects. For example:</p><div class="itemizedlist"><ul type="disc"><li><p>There is no need for aspects to use ad hoc configuration
        mechanisms; they can be configured in the same, consistent, approach
        used for the entire application.</p></li><li><p>Aspects can depend on application objects. For example, a
        security aspect can depend on a security manager, as we'll see in
        an example shortly. </p></li><li><p>It's possible to obtain a reference to an aspect through the
        relevant Spring context. This can allow for dynamic reconfiguration of
        the aspect.</p></li></ul></div><p>AspectJ aspects can expose JavaBean properties for Setter Injection,
    and even implement Spring lifecycle interfaces such as <code class="literal">BeanFactoryAware</code>.</p><p class="remark"><i><span class="remark">Note that AspectJ aspects cannot use Constructor Injection or
    Method Injection. This limitation is due to the fact that aspects do not
    have constructors that can be invoked like constructors of objects.</span></i></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5198"></a>7.2.1.&nbsp;"Singleton" aspects</h3></div></div></div><p>In most cases, AspectJ aspects are singletons, with one instance
      per class loader. This single instance is responsible for advising
      multiple object instances.</p><p>A Spring IoC container cannot instantiate an aspect, as aspects
      don't have callable constructors. But it can obtain a reference to
      an aspect using the static <code class="literal">aspectOf()</code> method that
      AspectJ defines for all aspects, and it can inject dependencies into
      that aspect.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5208"></a>7.2.1.1.&nbsp;Example</h4></div></div></div><p>Consider a security aspect, which depends on a security manager.
        This aspects applies to all changes in the value of the
        <code class="literal">balance</code> instance variable in the
        <code class="literal">Account</code> class. (We couldn't do this in the same
        way using Spring AOP.)</p><p>The AspectJ code for the aspect (one of the Spring/AspectJ
        samples), is shown below. Note that the dependency on the
        <code class="literal">SecurityManager</code> interface is expressed in a
        JavaBean property:</p><pre class="programlisting">public aspect BalanceChangeSecurityAspect {

   private SecurityManager securityManager;

   public void setSecurityManager(SecurityManager securityManager) {
      this.securityManager = securityManager;
   }

   private pointcut balanceChanged() : 
      set(int Account.balance);

   before() : balanceChanged() {
      this.securityManager.checkAuthorizedToModify();
   }
}</pre><p>We configure this aspect in the same way as an ordinary class.
        Note that the way in which we set the property reference is identical.
        Note that we must use the <code class="literal">factory-method</code> attribute
        to specify that we want the aspect "created" using the
        <code class="literal">aspectOf()</code> static method. In fact, this is
        <span class="emphasis"><em>locating</em></span>, rather than, <code class="literal">creating</code>,
        the aspect, but the Spring container doesn't care:</p><pre class="programlisting">&lt;bean id="securityAspect" 
   class="org.springframework.samples.aspectj.bank.BalanceChangeSecurityAspect" 
   factory-method="aspectOf"
&gt;
   &lt;property name="securityManager" ref="securityManager"/&gt;
&lt;/bean&gt;</pre><p>We don't need to do anything in Spring configuration to
        target this aspect. It contains the pointcut information in AspectJ
        code that controls where it applies. Thus it can apply even to objects
        not managed by the Spring IoC container.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5246"></a>7.2.1.2.&nbsp;Ordering issues</h4></div></div></div><p>to be completed</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5251"></a>7.2.2.&nbsp;Non-singleton aspects</h3></div></div></div><p>** Complete material on pertarget etc.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5256"></a>7.2.3.&nbsp;Gotchas</h3></div></div></div><p>to be completed</p><p>- Singleton issue</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5263"></a>7.3.&nbsp;Using AspectJ pointcuts to target Spring advice</h2></div></div></div><p>In a future release of Spring, we plan to provide the ability for
    AspectJ pointcut expressions to be used in Spring XML or other bean
    definition files, to target Spring advice. This will allow some of the
    power of the AspectJ pointcut model to be applied to Spring's
    proxy-based AOP framework. This will work in pure Java, and will not
    require the AspectJ compiler. Only the subset of AspectJ pointcuts
    relating to method invocation will be usable.</p><p>This feature replaces our previous plan to create a pointcut
    expression language for Spring.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5270"></a>7.4.&nbsp;Spring aspects for AspectJ</h2></div></div></div><p>In a future release of Spring, we will package some Spring services,
    such as the declarative transaction management service, as AspectJ aspects.
    This will enable them to be used by AspectJ users without dependence on the
    Spring AOP framework--potentially, even without dependence on the Spring
    IoC container.</p><p>This feature is probably of more interest to AspectJ users than
    Spring users.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transaction"></a>Chapter&nbsp;8.&nbsp;Transaction management</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5280"></a>8.1.&nbsp;The Spring transaction abstraction</h2></div></div></div><p>Spring provides a consistent abstraction for transaction management.
    This abstraction is one of the most important of Spring's abstractions,
    and delivers the following benefits:</p><div class="itemizedlist"><ul type="disc"><li><p>Provides a consistent programming model across different
          transaction APIs such as JTA, JDBC, Hibernate, iBATIS Database Layer
          and JDO.</p></li><li><p>Provides a simpler, easier to use, API for programmatic
          transaction management than most of these transaction APIs</p></li><li><p>Integrates with the Spring data access abstraction</p></li><li><p>Supports Spring declarative transaction management</p></li></ul></div><p>Traditionally, J2EE developers have had two choices for transaction
    management: to use <span class="emphasis"><em>global</em></span> or
    <span class="emphasis"><em>local</em></span> transactions. Global transactions are managed
    by the application server, using JTA. Local transactions are
    resource-specific: for example, a transaction associated with a JDBC
    connection. This choice had profound implications. Global transactions
    provide the ability to work with multiple transactional resources. (It's
    worth noting that most applications use a single transaction resource)
    With local transactions, the application server is not involved in
    transaction management, and cannot help ensure correctness across multiple
    resources.</p><p>Global transactions have a significant downside. Code needs to use
    JTA: a cumbersome API to use (partly due to its exception model).
    Furthermore, a JTA <code class="literal">UserTransaction</code> normally needs to be
    obtained from JNDI: meaning that we need to use <span class="emphasis"><em>both</em></span>
    JNDI and JTA to use JTA. Obviously all use of global transactions limits
    the reusability of application code, as JTA is normally only available in
    an application server environment.</p><p>The preferred way to use global transactions was via EJB
    <span class="emphasis"><em>CMT</em></span> (<span class="emphasis"><em>Container Managed
    Transaction</em></span>): a form of <span class="bold"><strong>declarative
    transaction management</strong></span> (as distinguished from <span class="bold"><strong>programmatic transaction management</strong></span>). EJB CMT
    removes the need for transaction-related JNDI lookups--although of course
    the use of EJB itself necessitates the use of JNDI. It removes most--not
    all--need to write Java code to control transactions. The significant
    downside is that CMT is (obviously) tied to JTA and an application server
    environment; and that it's only available if we choose to implement
    business logic in EJBs, or at least behind a transactional EJB facade. The
    negatives around EJB in general are so great that this is not an
    attractive proposition, when there are alternatives for declarative
    transaction management.</p><p>Local transactions may be easier to use, but also have significant
    disadvantages: They cannot work across multiple transactional resources,
    and tend to invade the programming model. For example, code that manages
    transactions using a JDBC connection cannot run within a global JTA
    transaction.</p><p>Spring resolves these problems. It enables application developers to
    use a consistent programming model <span class="emphasis"><em>in any
    environment</em></span>. You write your code once, and it can benefit from
    different transaction management strategies in different environments.
    Spring provides both declarative and programmatic transaction management.
    Declarative transaction management is preferred by most users, and
    recommended in most cases.</p><p>With programmatic transaction management developers work with the
    Spring transaction abstraction, which can run over any underlying
    transaction infrastructure. With the preferred declarative model
    developers typically write little or no code related to transaction
    management, and hence don't depend on Spring's or any other transaction
    API.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5337"></a>8.2.&nbsp;Transaction strategies</h2></div></div></div><p>The key to the Spring transaction abstraction is the notion of a
    <span class="emphasis"><em>transaction strategy</em></span>.</p><p>This is captured in the
    <code class="literal">org.springframework.transaction.PlatformTransactionManager</code>
    interface, shown below:</p><pre class="programlisting">public interface PlatformTransactionManager {

    TransactionStatus getTransaction(TransactionDefinition definition)
        throws TransactionException;

    void commit(TransactionStatus status) throws TransactionException;

    void rollback(TransactionStatus status) throws TransactionException;
}</pre><p>This is primarily an SPI interface, although it can be used
    programmatically. Note that in keeping with Spring's philosophy, this is
    an <span class="emphasis"><em>interface</em></span>. Thus it can easily be mocked or stubbed
    if necessary. Nor is it tied to a lookup strategy such as JNDI:
    PlatformTransactionManager implementations are defined like any other
    object in a Spring IoC container. This benefit alone makes this a
    worthwhile abstraction even when working with JTA: transactional code can
    be tested much more easily than if it directly used JTA.</p><p>In keeping with Spring's philosophy,
    <code class="literal">TransactionException</code> is unchecked. Failures of the
    transaction infrastructure are almost invariably fatal. In rare cases
    where application code can recover from them, the application developer
    can still choose to catch and handle
    <code class="literal">TransactionException</code>.</p><p>The <code class="literal">getTransaction() </code>method returns a
    <code class="literal">TransactionStatus</code> object, depending on a
    <code class="literal">TransactionDefinition</code> parameter. The returned
    <code class="literal">TransactionStatus</code> might represent a new or existing
    transaction (if there was a matching transaction in the current call
    stack).</p><p>As with J2EE transaction contexts, a
    <code class="literal">TransactionStatus</code> is associated with a <span class="bold"><strong>thread</strong></span> of execution.</p><p>The <code class="literal">TransactionDefinition</code> interface
    specifies:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>Transaction isolation</strong></span>: The
        degree of isolation this transaction has from the work of other
        transactions. For example, can this transaction see uncommitted writes
        from other transactions?</p></li><li><p><span class="bold"><strong>Transaction propagation</strong></span>:
        Normally all code executed within a transaction scope will run in that
        transaction. However, there are several options specifying behavior if
        a transactional method is executed when a transaction context already
        exists: For example, simply running in the existing transaction (the
        most common case); or suspending the existing transaction and creating
        a new transaction. Spring offers the transaction propagation options
        familiar from EJB CMT.</p></li><li><p><span class="bold"><strong>Transaction timeout</strong></span>: How long
        this transaction may run before timing out (automatically being rolled
        back by the underlying transaction infrastructure).</p></li><li><p><span class="bold"><strong>Read-only status</strong></span>: A read-only
        transaction does not modify any data. Read-only transactions can be a
        useful optimization in some cases (such as when using
        Hibernate).</p></li></ul></div><p>These settings reflect standard concepts. If necessary, please refer
    to a resource discussing transaction isolation levels and other core
    transaction concepts: Understanding such core concepts is essential to
    using Spring or any other transaction management solution.</p><p>The <code class="literal">TransactionStatus</code> interface provides a simple
    way for transactional code to control transaction execution and query
    transaction status. The concepts should be familiar, as they are common to
    all transaction APIs:</p><pre class="programlisting">public interface TransactionStatus {

    boolean isNewTransaction();

    void setRollbackOnly();

    boolean isRollbackOnly();
}</pre><p>However Spring transaction management is used, defining the
    <code class="literal">PlatformTransactionManager</code> implementation is essential.
    In good Spring fashion, this important definition is made using Inversion
    of Control.</p><p>PlatformTransactionManager implementations normally require
    knowledge of the environment in which they work: JDBC, JTA, Hibernate
    etc.</p><p>The following examples from
    <code class="literal">dataAccessContext-local.xml</code> from Spring's <span class="bold"><strong>jPetStore</strong></span> sample application show how a local
    PlatformTransactionManager implementation can be defined. This will work
    with JDBC.</p><p>We must define a JDBC DataSource, and then use the Spring
    DataSourceTransactionManager, giving it a reference to the
    DataSource.</p><pre class="programlisting">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
  &lt;property name="url" value="${jdbc.url}"/&gt;
  &lt;property name="username" value="${jdbc.username}"/&gt;
  &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;</pre><p>The PlatformTransactionManager definition will look like
    this:</p><pre class="programlisting">&lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</pre><p>If we use JTA, as in the <code class="literal">dataAccessContext-jta.xml
    </code>file from the same sample application, we need to use a
    container DataSource, obtained via JNDI, and a JtaTransactionManager
    implementation. The JtaTransactionManager doesn't need to know about the
    DataSource, or any other specific resources, as it will use the
    container's global transaction management.</p><pre class="programlisting">&lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName" value="jdbc/jpetstore"/&gt;&gt;
&lt;/bean&gt;

&lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre><p>We can use Hibernate local transactions easily, as shown in the
    following examples from the Spring <span class="bold"><strong>PetClinic</strong></span> sample application.</p><p>In this case, we need to define a Hibernate LocalSessionFactory,
    which application code will use to obtain Hibernate Sessions.</p><p>The DataSource bean definition will be similar to one of the above
    examples, and is not shown. (If it's a container DataSource it should be
    non-transactional as Spring, rather than the container, will manage
    transactions.)</p><p>The "txManager" bean in this case is of class
    HibernateTransactionManager. In the same way as the
    DataSourceTransactionManager needs a reference to the DataSource, the
    HibernateTransactionManager needs a reference to the
    SessionFactory.</p><pre class="programlisting">&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;property name="mappingResources"&gt;
    &lt;list&gt;
      &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="hibernateProperties"&gt;
    &lt;props&gt;
      &lt;prop key="hibernate.dialect"&gt;${hibernate.dialect}&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="txManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
  &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
&lt;/bean&gt;</pre><p>With Hibernate and JTA transactions we could simply use the
    JtaTransactionManager as with JDBC or any other resource strategy.</p><pre class="programlisting">&lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre><p>Note that this is identical to JTA configuration for any resource,
    as these are global transactions, which can enlist any transactional
    resource.</p><p><em><span class="remark">In all these cases, application code won't need to change at
    all. We can change how transactions are managed merely by changing
    configuration, even if that change means moving from local to global
    transactions or vice versa.</span></em></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5480"></a>8.3.&nbsp;Resource synchronization with transactions</h2></div></div></div><p>It should now be clear how different transaction managers are
    created, and how they are linked to related resources which need to be
    synchronized to transactions (i.e.
    <code class="literal">DataSourceTransactionManager</code> to a JDBC
    <code class="literal">DataSource</code>,
    <code class="literal">HibernateTransactionManager</code> to a Hibernate
    <code class="literal">SessionFactory</code>, etc.). There remains the question
    however of how the application code directly or indirectly using a
    persistence API (JDBC, Hibernate, JDO, etc.), ensures that these resources
    are obtained and handled properly, in terms of proper
    creation/reuse/cleanup and to trigger (optionally) transaction
    synchronization via the relevant
    <code class="literal">PlatformTransactionManager</code>.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5500"></a>8.3.1.&nbsp;High-level approach</h3></div></div></div><p>The preferred approach is to use Spring's highest level
      persistence integration APIs. These do not replace the native APIs, but
      do internally handle resource creation/reuse, cleanup, optional
      transaction synchronization of the resources and exception mapping, so
      that user data access code doesn't have to worry about these concerns at
      all, but can concentrate purely on non-boilerplate persistence logic.
      Generally, the same<span class="emphasis"><em> template</em></span> approach is followed
      for all persistence APIs, with classes such as
      <code class="literal">JdbcTemplate</code>, <code class="literal">HibernateTemplate</code>,
      <code class="literal">JdoTemplate</code>, etc.. These integration classes are
      detailed in subsequent chapters of this manual.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5517"></a>8.3.2.&nbsp;Low-level approach</h3></div></div></div><p>At a lower level exist classes such as
      <code class="literal">DataSourceUtils</code> (for JDBC),
      <code class="literal">SessionFactoryUtils</code> (for Hibernate),
      <code class="literal">PersistenceManagerFactoryUtils</code> (for JDO), and so on.
      When it is preferred for application code to deal directly with the
      resource types of the native persistence APIs, these classes ensure that
      proper Spring-managed instances are obtained, transactions are
      (optionally) synchronized to, and exceptions which happen in the process
      are properly mapped to a consistent API.</p><p>For example, for JDBC, instead of the traditional JDBC approach of
      calling the <code class="literal">getConnection()</code> method on the
      <code class="literal">DataSource</code>, you would instead use Spring's
      <code class="literal">org.springframework.jdbc.datasource.DataSourceUtils</code>
      class as follows:</p><pre class="programlisting">Connection conn = DataSourceUtils.getConnection(dataSource);</pre><p>If an existing transaction exists, and already has a connection
      synchronized (linked) to it, that instance will be returned. Otherwise,
      the method call will trigger the creation of a new connection, which
      will be (optionally) synchronized to any existing transaction, and
      available for subsequent reuse in that same transaction. As mentioned,
      this has the added advantage that any <code class="literal">SQLException</code>
      will be wrapped in a Spring
      <code class="literal">CannotGetJdbcConnectionException</code>--one of Spring's
      hierarchy of unchecked DataAccessExceptions. This gives you more
      information than can easily be obtained from the
      <code class="literal">SQLException</code>, and ensures portability across
      databases: even across different persistence technologies.</p><p>It should be noted that this will also work fine without Spring
      transaction management (transaction synchronization is optional), so you
      can use it whether or not you are using Spring for transaction
      management.</p><p>Of course, once you've used Spring's JDBC support or Hibernate
      support, you will generally prefer not to use
      <code class="literal">DataSourceUtils</code> or the other helper classes, because
      you'll be much happier working via the Spring abstraction than directly
      with the relevant APIs. For example, if you use the Spring JdbcTemplate
      or jdbc.object package to simplify your use of JDBC, correct connection
      retrieval happens behind the scenes and you won't need to write any
      special code.</p><p>All these lower level resource access classes are detailed in
      subsequent chapters of this manual.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5564"></a>8.3.3.&nbsp;TransactionAwareDataSourceProxy</h3></div></div></div><p>At the very lowest level exists the
      <code class="literal">TransactionAwareDataSourceProxy</code> class. This is a
      proxy for a target <code class="literal">DataSource</code>, which wraps that
      target <code class="literal">DataSource</code> to add awareness of Spring-managed
      transactions. In this respect it is similar to a transactional JNDI
      <code class="literal">DataSource</code> as provided by a J2EE server.</p><p>It should almost never be necessary or desireable to use this
      class, except when existing code exists which must be called and passed
      a standard JDBC <code class="literal">DataSource</code> interface implementation.
      In this case, it's possible to still have this code be usable, but
      participating in Spring managed transactions. It is preferable to write
      your own new code using the higher level abstractions mentioned
      above.</p><p>See the <code class="literal">TransactionAwareDataSourceProxy</code>
      Javadocs for more details.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5591"></a>8.4.&nbsp;Programmatic transaction management</h2></div></div></div><p>Spring provides two means of programmatic transaction
    management:</p><div class="itemizedlist"><ul type="disc"><li><p>Using the <code class="literal">TransactionTemplate</code></p></li><li><p>Using a <code class="literal">PlatformTransactionManager</code>
        implementation directly</p></li></ul></div><p>We generally recommend the first approach.</p><p>The second approach is similar to using the JTA
    <code class="literal">UserTransaction</code> API (although exception handling is
    less cumbersome).</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5615"></a>8.4.1.&nbsp;Using the <code class="literal">TransactionTemplate</code></h3></div></div></div><p>The <code class="literal">TransactionTemplate</code> adopts the same
      approach as other Spring <span class="emphasis"><em>templates</em></span> such as
      <code class="literal">JdbcTemplate</code> and
      <code class="literal">HibernateTemplate</code>. It uses a callback approach, to
      free application code from the working of acquiring and releasing
      resources. (No more try/catch/finally.) Like other templates, a
      <code class="literal">TransactionTemplate</code> is threadsafe.</p><p>Application code that must execute in a transaction context looks
      like this. Note that the <code class="literal">TransactionCallback</code> can be
      used to return a value:</p><pre class="programlisting">Object result = tt.execute(new TransactionCallback() {
    public Object doInTransaction(TransactionStatus status) {
        updateOperation1();
        return resultOfUpdateOperation2();
    }
});</pre><p>If there's no return value, use a
      <code class="literal">TransactionCallbackWithoutResult</code> like this:</p><pre class="programlisting">tt.execute(new TransactionCallbackWithoutResult() {
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        updateOperation1();
        updateOperation2();
    }
});</pre><p>Code within the callback can roll the transaction back by calling
      the <code class="literal">setRollbackOnly()</code> method on the
      <code class="literal">TransactionStatus</code> object.</p><p>Application classes wishing to use the
      <code class="literal">TransactionTemplate</code> must have access to a
      PlatformTransactionManager: usually exposed as a JavaBean property or as
      a constructor argument.</p><p>It's easy to unit test such classes with a mock or stub
      <code class="literal">PlatformTransactionManager</code>. There's no JNDI lookup or
      static magic here: it's a simple interface. As usual, you can use Spring
      to simplify your unit testing.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5671"></a>8.4.2.&nbsp;Using the <code class="literal">PlatformTransactionManager</code></h3></div></div></div><p>You can also use the
      <code class="literal">org.springframework.transaction.PlatformTransactionManager</code>
      directly to manage your transaction. Simply pass the implementation of
      the PlatformTransactionManager you're using to your bean via a bean
      reference. Then, using the <code class="literal">TransactionDefinition</code> and
      <code class="literal">TransactionStatus</code> objects you can initiate
      transactions, rollback and commit.</p><pre class="programlisting">DefaultTransactionDefinition def = new DefaultTransactionDefinition();
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
    // execute your business logic here
}
catch (MyException ex) {
    txManager.rollback(status);
    throw ex;
}
txManager.commit(status);</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5690"></a>8.5.&nbsp;Declarative transaction management</h2></div></div></div><p>Spring also offers declarative transaction management. This is
    enabled by Spring AOP, although, as the transactional aspects code comes
    with Spring and may be used in a boilerplate fashion, AOP concepts do not
    generally have to be understood to make effective use of this
    code..</p><p class="remark"><i><span class="remark">Most Spring users choose declarative transaction management. It is
    the option with the least impact on application code, and hence is most
    consistent with the ideals of a n<span class="emphasis"><em>on-invasive
    </em></span>lightweight container.</span></i></p><p>It may be helpful to begin by considering EJB CMT and explaining the
    similarities and differences with Spring declarative transaction
    management. The basic approach is similar: It's possible to specify
    transaction behavior (or lack of it) down to individual methods. It's
    possible to make a <code class="literal">setRollbackOnly() </code>call within a
    transaction context if necessary. The differences are:</p><div class="itemizedlist"><ul type="disc"><li><p>Unlike EJB CMT, which is tied to JTA, Spring declarative
        transaction management works in any environment. It can work with
        JDBC, JDO, Hibernate or other transactions under the covers, with
        configuration changes only.</p></li><li><p>Spring enables declarative transaction management to be applied
        to any POJO, not just special classes such as EJBs.</p></li><li><p>Spring offers declarative <span class="emphasis"><em>rollback rules</em></span>: a
        feature with no EJB equivalent, which we'll discuss below. Rollback
        can be controlled declaratively, not merely programmatically.</p></li><li><p>Spring gives you an opportunity to customize transactional
        behavior, using AOP. For example, if you want to insert custom
        behavior in the case of transaction rollback, you can. You can also
        add arbitrary advice, along with the transactional advice. With EJB
        CMT, you have no way to influence the container's transaction
        management other than <code class="literal">setRollbackOnly()</code>.</p></li><li><p>Spring does not support propagation of transaction contexts
        across remote calls, as do high-end application servers. If you need
        this feature, we recommend that you use EJB. However, don't use this
        feature lightly. Normally we don't want transactions to span remote
        calls.</p></li></ul></div><p>The concept of rollback rules is important: they enable us to
    specify which exceptions (and throwables) should cause automatic roll
    back. We specify this declaratively, in configuration, not in Java code.
    So, while we can still call <code class="literal">setRollbackOnly() </code>on the
    <code class="literal">TransactionStatus</code> object to roll the current
    transaction back programmatically, most often we can specify a rule that
    <code class="literal">MyApplicationException</code> should always result in roll
    back. This has the significant advantage that business objects don't need
    to depend on the transaction infrastructure. For example, they typically
    don't need to import any Spring APIs, transaction or other.</p><p>While the EJB default behavior is for the EJB container to
    automatically roll back the transaction on a <span class="emphasis"><em>system
    exception</em></span> (usually a runtime exception), EJB CMT does not roll
    back the transaction automatically on an <span class="emphasis"><em>application
    exception</em></span> (checked exception other than
    <code class="literal">java.rmi.RemoteException</code>). While the Spring default
    behavior for declarative transaction management follows EJB convention
    (roll back is automatic only on unchecked exceptions), it's often useful
    to customize this.</p><p>On our benchmarks, the performance of Spring declarative transaction
    management exceeds that of EJB CMT.</p><p>The usual way of setting up transactional proxying in Spring is via
    the the use of <code class="literal">TransactionProxyFactoryBean</code> to create
    the transactional proxy. This factory bean is simply a specialized version
    of Spring's generic <code class="literal">ProxyFactoryBean</code>, that, in addition
    to creating a proxy to wrap a target object, will also always
    automatically create and attach a
    <code class="literal">TransactionInterceptor</code> to that proxy, reducing
    boilerplate code. (Note that as with <code class="literal">ProxyFactoryBean</code>,
    you may still specify other interceptors or AOP advice to apply via the
    proxy).</p><p>When using <code class="literal">TransactionProxyFactoryBean</code>, you need
    to first of all specify the target object to wrap in the transactional
    proxy, via the <code class="literal">target</code> attribute.. The target object is
    normally a POJO bean definition. You must also specify a reference to the
    relevant <code class="literal">PlatformTransactionManager</code>. Finally, you must
    specify the <span class="bold"><strong>transaction attributes</strong></span>.
    Transaction attributes contain the definition of what transaction
    semantics we wish to use (as discussed above), as well as where they
    apply. Now let's consider the following sample:</p><pre class="programlisting">&lt;!-- this example is in verbose form, see note later about concise for multiple proxies! --&gt;
&lt;!-- the target bean to wrap transactionally --&gt;
&lt;bean id="petStoreTarget"&gt;
  ...
&lt;/bean&gt;

&lt;bean id="petStore" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
  &lt;property name="transactionManager" ref="txManager"/&gt;
  &lt;property name="target" ref="petStoreTarget"/&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="insert*"&gt;PROPAGATION_REQUIRED,-MyCheckedException&lt;/prop&gt;
      &lt;prop key="update*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
      &lt;prop key="*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The transactional proxy will implement the interfaces of the target:
    in this case, the bean with id <span class="emphasis"><em>petStoreTarget</em></span>. (Note
    that using CGLIB it's possible to transactionally proxy non-interface
    methods of the target class as well. Set the "proxyTargetClass" property
    to true to force this to always happen, although it will happen
    automatically if the target doesn't implement any interfaces. In general,
    of course, we want to program to interfaces rather than classes.) It's
    possible (and usually a good idea) to restrict the transactional proxy to
    proxying only specific target interfaces, using the
    <span class="emphasis"><em>proxyInterfaces</em></span> property. It's also possible to
    customize the behavior of a <code class="literal">TransactionProxyFactoryBean</code>
    via several properties inherited from
    <code class="literal">org.springframework.aop.framework.ProxyConfig</code>, and
    shared with all AOP proxy factories.</p><p>The transaction interceptor will ultimately use an object
    implementating Spring's <code class="literal">TransactionAttributeSource</code>
    interface to get at the transaction attributes (in the form of
    <code class="literal">TransactionAttribute</code> objects) defining the transaction
    semantics to be applied to specific methods of specific classes. The most
    basic way to specify this <code class="literal">TransactionAttributeSource</code>
    instance when creating the proxy is for you to create a bean implementing
    the <code class="literal">TransactionAttributeSource</code> interface (Spring has
    several implementations), and then directly set the the
    <code class="literal">transactionAttributeSource</code> property of the proxy
    factory bean to refer to it (or wrap it as an inner bean. Alternately, you
    may set a text string for this property, and rely on the fact that the
    pre-registered (by Spring)
    <code class="literal">TransactionAttributeSourceEditor</code> will automatically
    convert that text string to a
    <code class="literal">MethodMapTransactionAttributeSource</code> instance.</p><p>However, as shown in this example, most users will instead prefer to
    define the transaction attributes by setting the
    <code class="literal">transactionAttributes</code> property. This property has a
    type of <code class="literal">Java.util.Properties</code>, which will then
    internally be converted to a
    <code class="literal">NameMatchTransactionAttributeSource</code> object.</p><p>As can be seen in the above definition, a
    <code class="literal">NameMatchTransactionAttributeSource</code> object holds a list
    of name/value pairs. The key of each pair is a method or methods (a *
    wildcard ending is optional) to apply transactional semantics to. Note
    that the method name is <span class="emphasis"><em>not</em></span> qualified with a package
    name, but rather is considered relative to the class of the target object
    being wrapped. The value portion of the name/value pair is the
    <code class="literal">TransactionAttribute</code> itself that needs to be applied.
    When specifying it as the <code class="literal">Properties</code> value as in this
    example, it's in String format as defined by
    <code class="literal">TransactionAttributeEditor</code>. This format is:</p><pre class="programlisting">PROPAGATION_NAME,ISOLATION_NAME,readOnly,timeout_NNNN,+Exception1,-Exception2</pre><p>Note that the only mandatory portion of the string is the
    propagation setting. The default transactions semantics which apply are as
    follows:</p><div class="itemizedlist"><ul type="disc"><li><p>Exception Handling: RuntimeExceptions roll-back, normal
        (checked) Exceptions don&#8217;t</p></li><li><p>Transactions are read/write</p></li><li><p>Isolation Level: TransactionDefinition.ISOLATION_DEFAULT</p></li><li><p>Timeout: TransactionDefinition.TIMEOUT_DEFAULT</p></li></ul></div><p>See the JavaDocs for
    <code class="literal">org.springframework.transaction.TransactionDefinition</code>
    class for the format allowed for the propagation setting and isolation
    level setting. The String format is the same as the Integer constant names
    for the same values.</p><p>In this example, note that the value for the insert* mapping
    contains a rollback rule. Adding <code class="literal">-MyCheckedException</code>
    here specifies that if the method throws
    <code class="literal">MyCheckedException</code> or any subclasses, the transaction
    will automatically be rolled back. Multiple rollback rules can be
    specified here, comma-separated. A - prefix forces rollback; a + prefix
    specifies commit. (This allows commit even on unchecked exceptions, if you
    really know what you're doing!)</p><p>The <code class="literal">TransactionProxyFactoryBean</code> allows you to set
    optional "pre" and "post" advice, for additional interception behavior,
    using the "preInterceptors" and "postInterceptors" properties. Any number
    of pre and post advices can be set, and their type may be
    <code class="literal">Advisor</code> (in which case they can contain a pointcut),
    <code class="literal">MethodInterceptor</code> or any advice type supported by the
    current Spring configuration (such as <code class="literal">ThrowsAdvice</code>,
    <code class="literal">AfterReturningtAdvice</code> or
    <code class="literal">BeforeAdvice</code>, which are supported by default.) These
    advices must support a shared-instance model. If you need transactional
    proxying with advanced AOP features such as stateful mixins, it's normally
    best to use the generic
    <code class="literal">org.springframework.aop.framework.ProxyFactoryBean</code>,
    rather than the <code class="literal">TransactionProxyFactoryBean</code> convenience
    proxy creator.</p><p><span class="emphasis"><em>Note</em></span>: Using TransactionProxyFactoryBean
    definitions in the form above can seem overly verbose when many almost
    identical transaction proxies need to be created. You will almost always
    want to take advantage of parent and child bean definitions, along with
    inner bean definitions, to significantly reduce the verbosity of your
    transaction proxy definitions, as described in <a href="#aop-concise-proxy" title="6.7.&nbsp;Concise proxy definitions">Section&nbsp;6.7, &#8220;Concise proxy definitions&#8221;</a>.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5910"></a>8.5.1.&nbsp;Source Annotations for Transaction Demarcation</h3></div></div></div><p>XML-based transaction attribute sources definitions are
      convenient, and work in any environment, but if you are willing to
      commit to a dependency on Java 5+ (JDK 1.5+), you will almost certainly
      want to consider using Spring's support for transaction Annotations in
      JDK standard format, as the attribute source instead.</p><p>Declaring transaction semantics directly in the Java source code
      puts the declarations much closer to the affected code, and there is
      generally not much danger of undue coupling, since typically, code that
      is deployed as transactional is always deployed that way.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e5917"></a>8.5.1.1.&nbsp;The <code class="literal">Transactional</code> Annotation</h4></div></div></div><p>The
        <code class="literal">org.springframework.transaction.annotation.Transactional
        Annotation</code> is used to indicate that an interface, interface
        method, class, or class method should have transaction
        semantics.</p><pre class="programlisting">@Transactional
public interface OrderService {

void createOrder(Order order);
List queryByCriteria(Order criteria);</pre><p>Used in bare form, this
        Annotation specifies that an interface, class, or method must be
        transactional. Default transaction semantics are read/write,
        PROPAGATION_REQUIRED, ISOLATION_DEFAULT, TIMEOUT_DEFAULT, with
        rollback on a <code class="literal">RuntimeException</code>, but not
        <code class="literal">Exception</code>.</p><p>Optional properties of the annotation modify transaction
        settings.</p><div class="table"><a name="d0e5941"></a><p class="title"><b>Table&nbsp;8.1.&nbsp;Properties of the <code class="literal">Transactional</code>
            Annotation</b></p><div class="table-contents"><table summary="Properties of the Transactional&#xA;            Annotation" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">propagation</code></td><td>enum: Propagation</td><td>optional propagation setting (defaults to
                  PROPAGATION_REQUIRED)</td></tr><tr><td><code class="literal">isolation</code></td><td>enum: Isolation</td><td>optional isolation level (defaults to
                  ISOLATION_DEFAULT)</td></tr><tr><td><code class="literal">readOnly</code></td><td>boolean</td><td>read/write vs. read-only transaction (defaults to
                  false, or read/write)</td></tr><tr><td><code class="literal">rollbackFor</code></td><td>array of Class objects, must be derived from
                  Throwable</td><td>optional array of exception classes which should
                  cause rollback. By default, checked exceptions do not roll
                  back, unchecked (RuntimeException derived) roll back</td></tr><tr><td><code class="literal">rollbackForClassname</code></td><td>array of String class names. Classes must be derived
                  from Throwable</td><td>optional array of names of exception classes which
                  should cause rollback</td></tr><tr><td><code class="literal">noRollbackFor</code></td><td>array of Class objects, must be derived from
                  Throwable</td><td>optional array of exception classes which should not
                  cause rollback.</td></tr><tr><td><code class="literal">noRollbackForClassname</code></td><td>array of String class names, must be derived from
                  Throwable</td><td>optional array of names of exception classes which
                  should not rollback</td></tr></tbody></table></div></div><p><br class="table-break"></p><p>The annotation may be placed before an interface definition, a
        method on an interface, a class definition, or a method on a class. It
        may exist on both an element of an interface, and a class which
        implements that interface. The most derived location takes precedence
        when evaluating the transaction semantics of a method.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e6015"></a>8.5.1.1.1.&nbsp;<code class="literal">Transactional</code> annotation examples</h5></div></div></div><p>Annotating a class definition:</p><pre class="programlisting">public class OrderServiceImpl implements OrderService {

  @Transactional
  void createOrder(Order order);
  public List queryByCriteria(Order criteria);

}</pre><p>In the following example, the interface is annotated for
          read-only transactions, which will thus be the setting used for
          methods by default. The Annotation on the createOrder method
          overrides this, setting the transaction to read/write, and
          specifying that transactions should also (in addition to the defualt
          rollback rule for <code class="literal">RuntimeException</code>) rollback when
          the <code class="literal">DuplicateOrderIdException</code> (presumably a
          non-checked Exception) is thrown.</p><pre class="programlisting">@Transactional(readOnly=true)
interface TestService {

  @Transactional(readOnly=false,
               rollbackFor=DuplicateOrderIdException.class)
  void createOrder(Order order) throws DuplicateOrderIdException ;

  List queryByCriteria(Order criteria);
}</pre><p>Note that a class definition which implements this interface
          may still override these settings on its own class or method
          elements.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e6036"></a>8.5.1.1.2.&nbsp;Telling Spring to apply the <code class="literal">Transactional</code>
          annotation</h5></div></div></div><p>By itself, adding instances of this annotation to interface or
          class elements will not result in transactional wrapping of the
          implementation clases. Spring must still be told somehow to create
          transactional proxies around classes with these annotations.</p><p>The key is to take advantage of the
          <code class="literal">org.springframework.transaction.annotation.AnnotationTransactionAttributeSource</code>
          class, which reads Annotations format transaction attributes from
          class files. Taking the previous example which uses
          TransactionProxyFactoryBean, the
          <code class="literal">TransactionAttributes</code> property which specified
          transaction attributes in text form is replaced by the direct usage
          of the <code class="literal">TransactionAttributeSource</code> property,
          specifying an
          <code class="literal">AnnotationTransactionAttributeSource</code>.</p><pre class="programlisting">&lt;bean id="petStore" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
  &lt;property name="transactionManager" ref="txManager"/&gt;
  &lt;property name="target" ref="petStoreTarget"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Since the TransactionAttributeSource property
          does not need to change at all for each proxy instance, when using
          parent and child bean definitions to avoid code duplication, the
          property may just be set on the base, parent definition and
          forgotten, there is never a need to override it in the child since
          the attribute source will read the right settings from each class
          file.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e6062"></a>8.5.1.1.3.&nbsp;Using AOP to ensure the <code class="literal">Transactional</code>
          annotation is applied</h5></div></div></div><p>The previous example is still more work than would be ideal.
          There is in principle no need for XML for each proxy (to point to
          the target bean) when the annotations in the class files themselves
          can be used as an indication that a proxy needs to be created for
          the annotated classes.</p><p>A more AOP focused approach allows a small amount of
          boilerplate XML (used once only, not for each target bean) to
          automatically ensure that proxies are created for all classes with
          Transactional annotations in them. Spring AOP was fully detailed in
          a previous chapter, which you should consult for general AOP
          documentation, but the key is the use of
          <code class="literal">DefaultAdvisorAutoProxyCreator</code>, a
          <code class="literal">BeanPostProcessor</code>. Because it is a bean post
          processor, it gets a chance to look at every bean that is created as
          it is created. If the bean contains the
          <code class="literal">Transactional</code> annotation, a transactional proxy
          is automatically created to wrap it.</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="txInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="txInterceptor" class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="txManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>A number of classes are involved here:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">TransactionInterceptor</code>: the AOP Advice,
              actually intercepts method call and wraps it with a transaction</p></li><li><p><code class="literal">TransactionAttributeSourceAdvisor</code>: AOP
              Advisor (holds the TransactionInterceptor, which is the advice,
              and a pointcut (where to apply the advice), in the form of a
              TransactionAttributeSource)</p></li><li><p><code class="literal">AnnotationTransactionAttributeSource</code>:
              TransactionAttributeSource implementation which provides
              transaction attributes read from class files</p></li><li><p><code class="literal">DefaultAdvisorAutoProxyCreator</code>: looks
              for Advisors in the context, and automatically creates proxy
              objects which are the transactional wrappers</p></li></ul></div></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6107"></a>8.5.2.&nbsp;BeanNameAutoProxyCreator,
      another declarative approach</h3></div></div></div><p><code class="classname">TransactionProxyFactoryBean</code> is very useful,
      and gives you full control when wrapping objects with a transactional
      proxy. Used with parent/child bean definitions and inner beans holding
      the target, and when Java 5 Annotations are not available as an option,
      it is generally the best choice for transactional wrapping. In the case
      that you need to wrap a number of beans in a completely identical
      fashion (for example, a boilerplate, 'make all methods transactional',
      using a <code class="classname">BeanFactoryPostProcessor</code> called
      <code class="classname">BeanNameAutoProxyCreator</code> can offer an alternative
      approach which can end up being even less verbose for this simplified
      use case.</p><p>To recap, once the ApplicationContext has read its initialization
      information, it instantiates any beans within it which implement the
      <code class="classname">BeanPostProcessor</code> interface, and gives them a
      chance to post-process all other beans in the ApplicationContext. So
      using this mechanism, a properly configured
      <code class="classname">BeanNameAutoProxyCreator</code> can be used to
      postprocess any other beans in the ApplicationContext (recognizing them
      by name), and wrap them with a transactional proxy. The actual
      transaction proxy produced is essentially identical to that produced by
      the use of <code class="classname">TransactionProxyFactoryBean</code>, so will
      not be discussed further.</p><p>Let us consider a sample configuration:</p><pre class="programlisting">&lt;beans&gt;

	&lt;!-- Transaction Interceptor set up to do PROPAGATION_REQUIRED on all methods --&gt;
  &lt;bean id="matchAllWithPropReq" 
      class="org.springframework.transaction.interceptor.MatchAlwaysTransactionAttributeSource"&gt;
    &lt;property name="transactionAttribute" value="PROPAGATION_REQUIRED"/&gt;
  &lt;/bean&gt;

  &lt;bean id="matchAllTxInterceptor"
      class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
    &lt;property name="transactionManager" ref="txManager"/&gt;
    &lt;property name="transactionAttributeSource" ref="matchAllWithPropReq"/&gt;
  &lt;/bean&gt;

  &lt;!-- One BeanNameAutoProxyCreator handles all beans where we want all methods to use 
       PROPAGATION_REQUIRED --&gt;
  &lt;bean id="autoProxyCreator" 
      class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
    &lt;property name="interceptorNames"&gt;
      &lt;list&gt;
        &lt;idref local="matchAllTxInterceptor"/&gt;
        &lt;idref bean="hibInterceptor"/&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="beanNames"&gt;
      &lt;list&gt;
        &lt;idref local="core-services-applicationControllerSevice"/&gt;
        &lt;idref local="core-services-deviceService"/&gt;
        &lt;idref local="core-services-authenticationService"/&gt;
        &lt;idref local="core-services-packagingMessageHandler"/&gt;
        &lt;idref local="core-services-sendEmail"/&gt;
        &lt;idref local="core-services-userService"/&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Assuming that we already have a
      <code class="classname">TransactionManager</code> instance in our
      ApplicationContext, the first thing we need to do is create a
      <code class="classname">TransactionInterceptor</code> instance to use. The
      <code class="classname">TransactionInterceptor</code> decides which methods to
      intercept based on a <code class="classname">TransactionAttributeSource</code>
      implementing object passed to it as a property. In this case, we want to
      handle the very simple case of matching all methods. This is not
      necessarily the most efficient approach, but it's very quick to set up,
      because we can use the special pre-defined
      <code class="classname">MatchAlwaysTransactionAttributeSource</code>, which
      simply matches all methods. If we wanted to be more specific, we could
      use other variants such as
      <code class="classname">MethodMapTransactionAttributeSource</code>,
      <code class="classname">NameMatchTransactionAttributeSource</code>, or
      <code class="classname">AttributesTransactionAttributeSource</code>.</p><p>Now that we have the transaction interceptor, we simply feed it to
      a <code class="classname">BeanNameAutoProxyCreator</code> instance we define,
      along with the names of 6 beans in the ApplicationContext that we want
      to wrap in an identical fashion. As you can see, the net result is
      significantly less verbose than it would have been to wrap 6 beans
      identically with TransactionProxyFactoryBean. Wrapping a 7th bean would
      add only one more line of config.</p><p>You may notice that we are able to apply multiple interceptors. In
      this case, we are also applying a
      <code class="classname">HibernateInterceptor</code> we have previously defined
      (bean id=<span class="emphasis"><em>hibInterceptor</em></span>), which will manage
      Hibernate Sessions for us.</p><p>There is one thing to keep in mind, with regards to bean naming,
      when switching back and forth between the use of
      <code class="classname">TransactionProxyFactoryBean</code>, and
      <code class="classname">BeanNameAutoProxyCreator</code>. For the former, if the
      target bean is not defined as an inner bean, you normally give the
      target bean you want to wrap an id similar in form to
      <span class="emphasis"><em>myServiceTarget</em></span>, and then give the proxy object an
      id of <span class="emphasis"><em>myService</em></span>; then all users of the wrapped
      object simply refer to the proxy, i.e. <span class="emphasis"><em>myService</em></span>.
      (These are just sample naming conventions, the point is that the target
      object has a different name than the proxy, and both are available from
      the ApplicationContext). However, when using
      <code class="classname">BeanNameAutoProxyCreator</code>, you name the target
      object something like <span class="emphasis"><em>myService</em></span>. Then, when
      <code class="classname">BeanNameAutoProxyCreator</code> postprocesses the target
      object and create the proxy, it causes the proxy to be inserted into the
      Application context under the name of the original bean. From that point
      on, only the proxy (the wrapped object) is available from the
      ApplicationContext. When using TransactionProxyFactoryBean with the
      target specified as an inner bean, this naming issue is not a concern,
      since the inner bean is not normally given a name.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6201"></a>8.5.3.&nbsp;AOP and Transactions</h3></div></div></div><p class="remark"><i><span class="remark">As you've seen by reading this chapter, you don't really need to
      be an AOP expert--or indeed, to know much at all about AOP--to use
      Spring's declarative transaction management effectively. However, if you
      do want to become a "power user" of Spring AOP, you will find it easy to
      combine declarative transaction management with powerful AOP
      capabilities.</span></i></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6206"></a>8.6.&nbsp;Choosing between programmatic and declarative transaction
    management</h2></div></div></div><p>Programmatic transaction management is usually a good idea only if
    you have a small number of transactional operations. For example, if you
    have a web application that require transactions only for certain update
    operations, you may not want to set up transactional proxies using Spring
    or any other technology. Using the TransactionTemplate may be a good
    approach.</p><p>On the other hand, if your applications has numerous transactional
    operations, declarative transaction management is usually worthwhile. It
    keeps transaction management out of business logic, and is not difficult
    to configure in Spring. Using Spring, rather than EJB CMT, the
    configuration cost of declarative transaction management is greatly
    reduced.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6213"></a>8.7.&nbsp;Do you need an application server for transaction
    management?</h2></div></div></div><p>Spring's transaction management capabilities--and especially its
    declarative transaction management--significantly changes traditional
    thinking as to when a J2EE application requires an application
    server.</p><p>In particular, you don't need an application server just to have
    declarative transactions via EJB. In fact, even if you have an application
    server with powerful JTA capabilities, you may well decide that Spring
    declarative transactions offer more power and a much more productive
    programming model than EJB CMT.</p><p>You need an application server's JTA capability only if you need to
    enlist multiple transactional resources. Many applications don't face this
    requirement. For example, many high-end applications use a single, highly
    scalable, database such as Oracle 9i RAC.</p><p>Of course you may need other application server capabilities such as
    JMS and JCA. However, if you need only JTA, you could also consider an
    open source JTA add-on such as JOTM. (Spring integrates with JOTM out of
    the box.) However, as of early 2004, high-end application servers provide
    more robust support for XA transactions.</p><p></p><p>The most important point is that with Spring <span class="emphasis"><em>you can
    choose when to scale your application up to a full-blown application
    server</em></span>. Gone are the days when the only alternative to using
    EJB CMT or JTA was to write coding using local transactions such as those
    on JDBC connections, and face a hefty rework if you ever needed that code
    to run within global, container-managed transactions. With Spring only
    configuration needs to change: your code doesn't.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6230"></a>8.8.&nbsp;AppServer-specific integration</h2></div></div></div><p>Spring's transaction abstraction is generally AppServer agnostic.
    Additionally, Spring's <code class="literal">JtaTransactionManager</code> class,
    which can optionally perform a JNDI lookup for the JTA
    <code class="literal">UserTransaction</code> and
    <code class="literal">TransactionManager</code> objects, can be set to autodetect
    the location for the latter object, which varies by AppServer. Having
    access to the <code class="literal">TransactionManager</code> instance does allow
    enhanced transaction semantics. Please see the
    <code class="literal">JtaTransactionManager</code> Javadocs for more details.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6250"></a>8.8.1.&nbsp;BEA WebLogic</h3></div></div></div><p>In a WebLogic 7.0, 8.1 or higher environment, you will generally
      prefer to use <code class="literal">WebLogicJtaTransactionManager</code> instead
      of the stock <code class="literal">JtaTransactionManager</code> class. This
      special WebLogic specific subclass of the normal
      <code class="literal">JtaTransactionManager</code>. It supports the full power of
      Spring's transaction definitions in a WebLogic managed transaction
      environment, beyond standard JTA semantics: features include transaction
      names, per-transaction isolation levels, and proper resuming of
      transactions in all cases.</p><p>Please see the Javadocs for full details.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6266"></a>8.8.2.&nbsp;IBM WebSphere</h3></div></div></div><p>In a WebSphere 5.1, 5.0 and 4 environment, you may wish to use
      Spring's <code class="literal">WebSphereTransactionManagerFactoryBean</code>
      class. This is a factory bean which retrieves the JTA
      <code class="literal">TransactionManager</code> in a WebSphere environment, which
      is done via WebSphere's static access methods. These methods are
      different for each version of WebSphere.</p><p>Once the JTA <code class="literal">TransactionManager</code> instance has
      been obtained via this factory bean, Spring's
      <code class="literal">JtaTransactionManager</code> may be configured with a
      reference to it, for enhanced transaction semantics over the use of only
      the JTA <code class="literal">UserTransaction</code> object.</p><p>Please see the Javadocs for full details.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6290"></a>8.9.&nbsp;Common problems</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6293"></a>8.9.1.&nbsp;Use of the wrong transaction manager for a specific
      DataSource</h3></div></div></div><p>Developers should take care to use the correct
      <span class="emphasis"><em><code class="literal">PlatformTransactionManager</code></em></span>
      implementation for their requirements.</p><p>It's important to understand how the Spring transaction
      abstraction works with JTA global transactions. Used properly, there is
      no conflict here: Spring merely provides a simplifying, portable
      abstraction.</p><p>If you are using global transactions, you
      <span class="emphasis"><em>must</em></span> use the Spring
      <code class="literal">org.springframework.transaction.jta.JtaTransactionManager</code>
      for all your for all your transactional operations. Otherwise Spring
      will attempt to perform local transactions on resources such as
      container DataSources. Such local transactions don't make sense, and a
      good application server will treat them as errors.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6312"></a>8.9.2.&nbsp;Spurious AppServer warnings about the transaction or DataSource
      no longer being active</h3></div></div></div><p>In some JTA environments with very strict XADataSource
      implementations -- currently only some WebLogic and WebSphere versions
      -- when using Hibernate configured without any awareness of the JTA
      <code class="literal">TransactionManager</code> object for that environment, it is
      is possible for spurious warning or exceptions to show up in the
      application server log. These warnings or exceptions will say something
      to the effect that the connection being accessed is no longer valid, or
      JDBC access is no longer valid, possibly because the transaction is no
      longer active. As an example, here is an actual exception from
      WebLogic:</p><pre class="programlisting">java.sql.SQLException: The transaction is no longer active - status: 'Committed'.
   No further JDBC access is allowed within this transaction. </pre><p>This warning is easy to resolve as described in <a href="#orm-hibernate-invalid-jdbc-access-error" title="12.2.10.&nbsp;Spurious AppServer warnings about the transaction or DataSource&#xA;      no longer being active">Section&nbsp;12.2.10, &#8220;Spurious AppServer warnings about the transaction or DataSource
      no longer being active&#8221;</a>.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="metadata"></a>Chapter&nbsp;9.&nbsp;Source Level Metadata Support</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-concepts"></a>9.1.&nbsp;Source-level metadata</h2></div></div></div><p><span class="authorinitials">Source-level metadata</span> is the
    addition of <span class="emphasis"><em>attributes</em></span> or
    <span class="emphasis"><em>annotations</em></span> to program elements: usually, classes
    and/or methods.</p><p>For example, we might add metadata to a class as follows:</p><pre class="programlisting">/**
 * Normal comments
 * @@org.springframework.transaction.interceptor.DefaultTransactionAttribute()
 */
public class PetStoreImpl implements PetStoreFacade, OrderService {</pre><p>We could add metadata to a method as follows:</p><pre class="programlisting">/**
 * Normal comments
 * @@org.springframework.transaction.interceptor.RuleBasedTransactionAttribute()
 * @@org.springframework.transaction.interceptor.RollbackRuleAttribute(Exception.class)
 * @@org.springframework.transaction.interceptor.NoRollbackRuleAttribute("ServletException")
 */
public void echoException(Exception ex) throws Exception {
    ....
}</pre><p>Both of these examples use Jakarta Commons Attributes syntax.</p><p>Source-level metadata was introduced to the mainstream by XDoclet
    (in the Java world) and by the release of Microsoft's .NET platform, which
    uses source-level attributes to control transactions, pooling and other
    behavior.</p><p>The value in this approach has been recognized in the J2EE
    community. For example, it's much less verbose than the traditional XML
    deployment descriptors exclusively used by EJB. While it is desirable to
    externalize some things from program source code, some important
    enterprise settings--notably transaction characteristics--arguably belong
    in program source. Contrary to the assumptions of the EJB spec, it seldom
    makes sense to modify the transactional characteristics of a method
    (although parameters like transaction timeouts might change!).</p><p>Although metadata attributes are typically used mainly by framework
    infrastructure to describe the services application classes require, it
    should also be possible for metadata attributes to be queried at runtime.
    This is a key distinction from solutions such as XDoclet, which primarily
    view metadata as a way of generating code such as EJB artefacts.</p><p>There are a number of solutions in this space, including:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>Standard Java Annotations</strong></span>: the
        standard Java metadata implementation (developed as JSR-175 and
        available in Java 5. Spring already supports specific Java 5
        Annotations for transactional demarcation, and for JMX. But we need a
        solution for Java 1.4 and even 1.3 too.</p></li><li><p><span class="bold"><strong>XDoclet</strong></span>: well-established
        solution, primarily intended for code generation</p></li><li><p>Various <span class="bold"><strong>open source attribute
        implementations</strong></span>, for Java 1.3 and 1.4, of which Commons
        Attributes appears to be the most promising. All these require a
        special pre- or post-compilation step.</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-spring"></a>9.2.&nbsp;Spring's metadata support</h2></div></div></div><p>In keeping with its provision of abstractions over important
    concepts, Spring provides a facade to metadata implementations, in the
    form of the <code class="literal">org.springframework.metadata.Attributes</code>
    interface.</p><p>Such a facade adds value for several reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>Java 5 provides metadata support at language level, there will
          still be value in providing such an abstraction:</p><div class="itemizedlist"><ul type="circle"><li><p>Java 5 metadata is static. It is associated with a class
              at compile time, and cannot be changed in a deployed
              environment. There is a need for hierarchical metadata,
              providing the ability to override certain attribute values in
              deployment--for example, in an XML file.</p></li><li><p>Java 5 metadata is returned through the Java reflection
              API. This makes it impossible to mock during test time. Spring
              provides a simple interface to allow this.</p></li><li><p>There will be a need for metadata support in 1.3 and 1.4
              applications for at least two years. Spring aims to provide
              working solutions <span class="emphasis"><em>now</em></span>; forcing the use of
              Java 5 is not an option in such an important area.</p></li></ul></div></li><li><p>Current metadata APIs, such as Commons Attributes (used by
          Spring 1.0-1.2) are hard to test. Spring provides a simple metadata
          interface that is much easier to mock.</p></li></ul></div><p>The Spring <code class="literal">Attributes</code> interface looks like
    this:</p><pre class="programlisting">public interface Attributes {

    Collection getAttributes(Class targetClass);

    Collection getAttributes(Class targetClass, Class filter);

    Collection getAttributes(Method targetMethod);

    Collection getAttributes(Method targetMethod, Class filter);

    Collection getAttributes(Field targetField);

    Collection getAttributes(Field targetField, Class filter);
}</pre><p>This is a lowest common denominator interface. JSR-175 offers more
    capabilities than this, such as attributes on method arguments. As of
    Spring 1.0, Spring aims to provide the subset of metadata required to
    provide effective declarative enterprise services a la EJB or .NET, on
    Java 1.3+. As of Spring 1.2, analogous JSR-175 annotations are supported
    on JDK 1.5, as direct alternative to Commons Attributes.</p><p>Note that this interface offers <code class="literal">Object</code>
    attributes, like .NET. This distinguishes it from attribute systems such
    as that of Nanning Aspects and JBoss 4 (as of DR2), which offer only
    <code class="literal">String</code> attributes. There is a significant advantage in
    supporting <code class="literal">Object</code> attributes. It enables attributes to
    participate in class hierarchies and enables attributes to react
    intelligently to their configuration parameters.</p><p>In most attribute providers, attribute classes will be configured
    via constructor arguments or JavaBean properties. Commons Attributes
    supports both.</p><p>As with all Spring abstraction APIs, <code class="literal">Attributes</code>
    is an interface. This makes it easy to mock attribute implementations for
    unit tests.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-commons"></a>9.3.&nbsp;Integration with Jakarta Commons Attributes</h2></div></div></div><p>Presently Spring supports only Jakarta Commons Attributes out of the
    box, although it is easy to provide implementations of the
    <code class="literal">org.springframework.metadata.Attributes</code> interface for
    other metadata providers.</p><p><span class="bold"><strong>Commons Attributes 2.1</strong></span> (<a href="http://jakarta.apache.org/commons/attributes/" target="_top">http://jakarta.apache.org/commons/attributes/</a>)
    is a capable attributes solution. It supports attribute configuration via
    constructor arguments and JavaBean properties, which offers better
    self-documentation in attribute definitions. (Support for JavaBean
    properties was added at the request of the Spring team.)</p><p>We've already seen two examples of Commons Attributes attributes
    definitions. In general, we will need to express:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>The name of the attribute class</em></span>. This can
        be an FQN, as shown above. If the relevant attribute class has already
        been imported, the FQN isn't required. It's also possible to specify
        "attribute packages" in attribute compiler configuration.</p></li><li><p><span class="emphasis"><em>Any necessary parameterization,</em></span> via
        constructor arguments or JavaBean properties</p></li></ul></div><p>Bean properties look as follows:</p><pre class="programlisting">/**
 * @@MyAttribute(myBooleanJavaBeanProperty=true)
 */</pre><p>It's possible to combine constructor arguments and JavaBean
    properties (as in Spring IoC).</p><p>Because, unlike Java 1.5 attributes, Commons Attributes is not
    integrated with the Java language, it is necessary to run a special
    <span class="emphasis"><em>attribute compilation</em></span> step as part of the build
    process.</p><p>To run Commons Attributes as part of the build process, you will
    need to do the following.</p><p>1. Copy the necessary library Jars to
    <code class="literal">$ANT_HOME/lib</code>. Four Jars are required, and all are
    distributed with Spring:</p><div class="itemizedlist"><ul type="disc"><li><p>The Commons Attributes compiler Jar and API Jar</p></li><li><p>xjavadoc.jar, from XDoclet</p></li><li><p>commons-collections.jar, from Jakarta Commons</p></li></ul></div><p>2. Import the Commons Attributes ant tasks into your project build
    script, as follows:</p><pre class="programlisting">&lt;taskdef resource="org/apache/commons/attributes/anttasks.properties"/&gt;</pre><p>3. Next, define an attribute compilation task, which will use the
    Commons Attributes attribute-compiler task to "compile" the attributes in
    the source. This process results in the generation of additional sources,
    to a location specified by the destdir attribute. Here we show the use of
    a temporary directory:</p><pre class="programlisting">&lt;target name="compileAttributes"&gt;

  &lt;attribute-compiler destdir="${commons.attributes.tempdir}"&gt;
    &lt;fileset dir="${src.dir}" includes="**/*.java"/&gt;
  &lt;/attribute-compiler&gt;

&lt;/target&gt;</pre><p>The compile target that runs Javac over the sources should depend on
    this attribute compilation task, and must also compile the generated
    sources, which we output to our destination temporary directory. If there
    are syntax errors in your attribute definitions, they will normally be
    caught by the attribute compiler. However, if the attribute definitions
    are syntactically plausible, but specify invalid types or class names, the
    compilation of the generated attribute classes may fail. In this case, you
    can look at the generated classes to establish the cause of the
    problem.</p><p class="remark"><i><span class="remark">Commons Attributes also provides Maven support. Please refer to
    Commons Attributes documentation for further information.</span></i></p><p>While this attribute compilation process may look complex, in fact
    it's a one-off cost. Once set up, attribute compilation is incremental, so
    it doesn't usually noticeably slow the build process. And once the
    compilation process is set up, you may find that use of attributes as
    described in this chapter can save you a lot of time in other
    areas.</p><p>If you require attribute indexing support (only currently required
    by Spring for attribute-targeted web controllers, discussed below), you
    will need an additional step, which must be performed on a Jar file of
    your compiled classes. In this, optional, step, Commons Attributes will
    create an index of all the attributes defined on your sources, for
    efficient lookup at runtime. This step looks as follows:</p><pre class="programlisting">&lt;attribute-indexer jarFile="myCompiledSources.jar"&gt;
    
  &lt;classpath refid="master-classpath"/&gt;

&lt;/attribute-indexer&gt;</pre><p class="remark"><i><span class="remark">See the /attributes directory of the Spring jPetStore sample
    application for an example of this build process. You can take the build
    script it contains and modify it for your own projects.</span></i></p><p>If your unit tests depend on attributes, try to express the
    dependency on the Spring Attributes abstraction, rather than Commons
    Attributes. Not only is this more portable--for example, your tests will
    still work if you switch to Java 1.5 attributes in future--it simplifies
    testing. Commons Attributes is a static API, while Spring provides a
    metadata interface that you can easily mock.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-uses"></a>9.4.&nbsp;Metadata and Spring AOP autoproxying</h2></div></div></div><p>The most important uses of metadata attributes are in conjunction
    with Spring AOP. This provides a .NET-like programming model, where
    declarative services are automatically provided to application objects
    that declare metadata attributes. Such metadata attributes can be
    supported out of the box by the framework, as in the case of declarative
    transaction management, or can be custom.</p><p>There is widely held to be a synergy between AOP and metadata
    attributes.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6526"></a>9.4.1.&nbsp;Fundamentals</h3></div></div></div><p>This builds on the Spring AOP autoproxy functionality.
      Configuration might look like this:</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="txInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="txInterceptor" class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.interceptor.AttributesTransactionAttributeSource"&gt;
      &lt;property name="attributes" ref="attributes"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="attributes" class="org.springframework.metadata.commons.CommonsAttributes"/&gt;</pre><p>The basic concepts here should be familiar from the discussion of
      autoproxying in the AOP chapter.</p><p>The most important bean definitions are those the auto-proxy creator
      and the advisor. Note that the actual bean names are not important;
			what matters is their class.</p><p>The bean definition of class
      <code class="literal">org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</code>
      will automatically advise ("auto-proxy") all bean instances in the
      current factory based on matching Advisor implementations. This class
      knows nothing about attributes, but relies on Advisors' pointcuts
      matching. The pointcuts do know about attributes.</p><p>Thus we simply need an AOP advisor that will provide declarative
      transaction management based on attributes.</p><p>It's possible to add arbitrary custom Advisor implementations as
      well, and they will also be evaluated and applied automatically. (You
      can use Advisors whose pointcuts match on criteria besides attributes in
      the same autoproxy configuration, if necessary.)</p><p>Finally, the <code class="literal">attributes</code> bean is the Commons
      Attributes Attributes implementation. Replace with another
      implementation of <code class="literal">org.springframework.metadata.Attributes
      </code>to source attributes from a different source.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-tx"></a>9.4.2.&nbsp;Declarative transaction management</h3></div></div></div><p>The commonest use of source-level attributes it to provide
      declarative transaction management a la .NET. Once the bean definitions
      shown above are in place, you can define any number of application
      objects requiring declarative transactions. Only those classes or
      methods with transaction attributes will be given transaction advice.
      You need to do nothing except define the required transaction
      attributes.</p><p><span class="emphasis"><em>Unlike</em></span> in .NET, you can specify transaction
      attributes at either class or method level. Class-level attributes, if
      specified, will be "inherited" by all methods. Method attributes will
      wholly override any class-level attributes.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-pool"></a>9.4.3.&nbsp;Pooling</h3></div></div></div><p>Again, as with .NET, you can enable pooling behavior via
      class-level attributes. Spring can apply this behavior to any POJO. You
      simply need to specify a pooling attribute, as follows, in the business
      object to be pooled:</p><pre class="programlisting"> /** 
 * @@org.springframework.aop.framework.autoproxy.target.PoolingAttribute(10)
 * @author Rod Johnson
 */
public class MyClass {</pre><p>You'll need the usual autoproxy
      infrastructure configuration. You then need to specify a pooling
      <code class="literal">TargetSourceCreator</code>, as follows. Because pooling
      affects the creation of the target, we can't use a regular advice. Note
      that pooling will apply even if there are no advisors applicable to the
      class, if that class has a pooling attribute.</p><pre class="programlisting">&lt;bean id="poolingTargetSourceCreator"
  class="org.springframework.aop.framework.autoproxy.metadata.AttributesPoolingTargetSourceCreator"&gt;
  &lt;property name="attributes" ref="attributes"/&gt;
&lt;/bean&gt;</pre><p>The relevant autoproxy bean definition needs to specify a list of
      "custom target source creators", including the Pooling target source
      creator. We could modify the example shown above to include this
      property as follows:</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"&gt;
  &lt;property name="customTargetSourceCreators"&gt;
    &lt;list&gt;
      &lt;ref bean="poolingTargetSourceCreator"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>As with the use of metadata in Spring in general, this is a
      one-off cost: once setup is out of the way, it's very easy to use
      pooling for additional business objects.</p><p class="remark"><i><span class="remark">It's arguable that the need for pooling is rare, so there's
      seldom a need to apply pooling to a large number of business objects.
      Hence this feature does not appear to be used often.</span></i></p><p>Please see the Javadoc for the
      <code class="literal">org.springframework.aop.framework.autoproxy</code> package
      for more details. It's possible to use a different pooling
      implementation than Commons Pool with minimal custom coding.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-arbitrary"></a>9.4.4.&nbsp;Custom metadata</h3></div></div></div><p>We can even go beyond the capabilities of .NET metadata
      attributes, because of the flexibility of the underlying autoproxying
      infrastructure.</p><p>We can define custom attributes, to provide any kind of
      declarative behavior. To do this, you need to:</p><div class="itemizedlist"><ul type="disc"><li><p>Define your custom attribute class</p></li><li><p>Define a Spring AOP Advisor with a pointcut that fires on the
          presence of this custom attribute.</p></li><li><p>Add that Advisor as a bean definition to an application
          context with the generic autoproxy infrastructure in place.</p></li><li><p>Add attributes to your POJOs.</p></li></ul></div><p>There are several potential areas you might want to do this, such
      as custom declarative security, or possibly caching.</p><p class="remark"><i><span class="remark">This is a powerful mechanism which can significantly reduce
      configuration effort in some projects. However, remember that it does
      rely on AOP under the covers. The more Advisors you have in play, the
      more complex your runtime configuration will be.</span></i></p><p class="remark"><i><span class="remark">(If you want to see what advice applies to any object, try
      casting a reference to org.springframework.aop.framework.Advised. This
      will enable you to examine the Advisors.)</span></i></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6619"></a>9.5.&nbsp;Using attributes to minimize MVC web tier configuration</h2></div></div></div><p>The other main use of Spring metadata as of 1.0 is to provide an
    option to simplify Spring MVC web configuration.</p><p>Spring MVC offers flexible <span class="emphasis"><em>handler mappings</em></span>:
    mappings from incoming request to controller (or other handler) instance.
    Normally handler mappings are configured in the
    <code class="literal">xxxx-servlet.xml</code> file for the relevant Spring
    DispatcherServlet.</p><p>Holding these mappings in the DispatcherServlet configuration file
    is normally A Good Thing. It provides maximum flexibility. In
    particular:</p><div class="itemizedlist"><ul type="disc"><li><p>The controller instance is explicitly managed by Spring IoC,
          through an XML bean definition</p></li><li><p>The mapping is external to the controller, so the same
          controller instance could be given multiple mappings in the same
          DispatcherServlet context or reused in a different
          configuration.</p></li><li><p>Spring MVC is able to support mappings based on any criteria,
          rather than merely the request URL-to-controller mappings available
          in most other frameworks.</p></li></ul></div><p>However, this does mean that for each controller we typically need
    both a handler mapping (normally in a handler mapping XML bean definition)
    and an XML mapping for the controller itself.</p><p>Spring offers a simpler approach based on source-level attributes,
    which is an attractive option in simpler scenarios.</p><p class="remark"><i><span class="remark">The approach described in this section is best suited to
    relatively simple MVC scenarios. It sacrifices some of the power of Spring
    MVC, such as the ability to use the same controller with different
    mappings, and the ability to base mappings on something other than request
    URL.</span></i></p><p>In this approach, controllers are marked with one or more
    class-level metadata attributes, each specifying one URL they should be
    mapped to.</p><p>The following examples show the approach. In each case, we have a
    controller that depends on a business object of type Cruncher. As usual,
    this dependency will be resolved by Dependency Injection. The Cruncher
    must be available through a bean definition in the relevant
    DispatcherServlet XML file, or a parent context.</p><p>We attach an attribute to the controller class specifying the URL
    that should map to it. We can express the dependency through a JavaBean
    property or a constructor argument. This dependency must be resolvable by
    autowiring: that is, there must be exactly one business object of type
    Cruncher available in the context.</p><pre class="programlisting">/**
 * Normal comments here
 * @author Rod Johnson
 * @@org.springframework.web.servlet.handler.metadata.PathMap("/bar.cgi")
 */
public class BarController extends AbstractController {

    private Cruncher cruncher;

    public void setCruncher(Cruncher cruncher) {
        this.cruncher = cruncher;
    }

    protected ModelAndView handleRequestInternal(
            HttpServletRequest request, HttpServletResponse response)
            throws Exception {
        System.out.println("Bar Crunching c and d =" + 
            cruncher.concatenate("c", "d"));
        return new ModelAndView("test");
    }

}</pre><p>For this auto-mapping to work, we need to add the following to the
    relevant <code class="literal">xxxx-servlet.xml</code> file, specifying the
    attributes handler mapping. This special handler mapping can handle any
    number of controllers with attributes as shown above. The bean id
    ("commonsAttributesHandlerMapping") is not important. The type is what
    matters:</p><pre class="programlisting">&lt;bean id="commonsAttributesHandlerMapping"      
    class="org.springframework.web.servlet.handler.metadata.CommonsPathMapHandlerMapping"/&gt;</pre><p>We <span class="emphasis"><em>do not </em></span>currently need an Attributes bean
    definition, as in the above example, because this class works directly
    with the Commons Attributes API, not via the Spring metadata
    abstraction.</p><p>We now need no XML configuration for each controller. Controllers
    are automatically mapped to the specified URL(s). Controllers benefit from
    IoC, using Spring's autowiring capability. For example, the dependency
    expressed in the "cruncher" bean property of the simple controller shown
    above is automatically resolved in the current web application context.
    Both Setter and Constructor Dependency Injection are available, each with
    zero configuration.</p><p>An example of Constructor Injection, also showing multiple URL
    paths:</p><pre class="programlisting">/**
* Normal comments here
* @author Rod Johnson
* 
* @@org.springframework.web.servlet.handler.metadata.PathMap("/foo.cgi")
* @@org.springframework.web.servlet.handler.metadata.PathMap("/baz.cgi")
*/
public class FooController extends AbstractController {

    private Cruncher cruncher;

    public FooController(Cruncher cruncher) {
        this.cruncher = cruncher;
    }

    protected ModelAndView handleRequestInternal(
            HttpServletRequest request, HttpServletResponse response)
            throws Exception {
        return new ModelAndView("test");
    }

}</pre><p>This approach has the following benefits:</p><div class="itemizedlist"><ul type="disc"><li><p>Significantly reduced volume of configuration. Each time we add
        a controller we need add <span class="emphasis"><em>no</em></span> XML configuration. As
        with attribute-driven transaction management, once the basic
        infrastructure is in place, it is very easy to add more application
        classes.</p></li><li><p>We retain much of the power of Spring IoC to configure
        controllers.</p></li></ul></div><p>This approach has the following limitations:</p><div class="itemizedlist"><ul type="disc"><li><p>One-off cost in more complex build process. We need an attribute
        compilation step and an attribute indexing step. However, once in
        place, this should not be an issue.</p></li><li><p>Currently Commons Attributes only, although support for other
        attribute providers may be added in future.</p></li><li><p>Only "autowiring by type" dependency injection is supported for
        such controllers. However, this still leaves them far in advance of
        Struts Actions (with no IoC support from the framework) and, arguably,
        WebWork Actions (with only rudimentary IoC support) where IoC is
        concerned.</p></li><li><p>Reliance on automagical IoC resolution may be confusing.</p></li></ul></div><p>Because autowiring by type means there must be exactly one
    dependency of the specified type, we need to be careful if we use AOP. In
    the common case using TransactionProxyFactoryBean, for example, we end up
    with <span class="emphasis"><em>two</em></span> implementations of a business interface such
    as Cruncher: the original POJO definition, and the transactional AOP
    proxy. This won't work, as the owning application context can't resolve
    the type dependency unambiguously. The solution is to use AOP
    autoproxying, setting up the autoproxy infrastructure so that there is
    only one implementation of Cruncher defined, and that implementation is
    automatically advised. Thus this approach works well with
    attribute-targeted declarative services as described above. As the
    attributes compilation process must be in place to handle the web
    controller targeting, this is easy to set up.</p><p>Unlike other metadata functionality, there is currently only a
    Commons Attributes implementation available:
    org.springframework.web.servlet.handler.metadata.CommonsPathMapHandlerMapping.
    This limitation is due to the fact that not only do we need attribute
    compilation, we need attribute <span class="emphasis"><em>indexing</em></span>: the ability
    to ask the attributes API for all classes with the PathMap attribute.
    Indexing is not currently offered on the
    <code class="literal">org.springframework.metadata.Attributes</code> abstraction
    interface, although it may be in future. (If you want to add support for
    another attributes implementation--which must support indexing--you can
    easily extend the <code class="literal">AbstractPathMapHandlerMapping</code>
    superclass of <code class="literal">CommonsPathMapHandlerMapping</code>,
    implementing the two protected abstract methods to use your preferred
    attributes API.)</p><p>Thus we need two additional steps in the build process: attribute
    compilation and attribute indexing. Use of the attribute indexer task was
    shown above. Note that Commons Attributes presently requires a Jar file as
    input to indexing.</p><p class="remark"><i><span class="remark">If you begin with a handler metadata mapping approach, it is
    possible to switch at any point to a classic Spring XML mapping approach.
    So you don't close off this option. For this reason, I find that I often
    start a web application using metadata mapping.</span></i></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6729"></a>9.6.&nbsp;Other uses of metadata attributes</h2></div></div></div><p>Other uses of metadata attributes appear to be growing in
    popularity. As of Spring 1.2, metadata attributes for JMX exposure are
    supported, through both Commons Attributes (on JDK 1.3+) and JSR-175
    annotations (on JDK 1.5).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6734"></a>9.7.&nbsp;Adding support for additional metadata APIs</h2></div></div></div><p>Should you wish to provide support for another metadata API it is
    easy to do so.</p><p>Simply implement the
    <code class="literal">org.springframework.metadata.Attributes</code> interface as a
    facade for your metadata API. You can then include this object in your
    bean definitions as shown above.</p><p>All framework services that use metadata, such as AOP
    metadata-driven autoproxying, will then automatically be able to use your
    new metadata provider.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="dao"></a>Chapter&nbsp;10.&nbsp;DAO support</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dao-introduction"></a>10.1.&nbsp;Introduction</h2></div></div></div><p>The DAO (Data Access Object) support in Spring is primarily aimed at
    making it easy to work with data access technologies like JDBC, Hibernate
    or JDO in a standardized way. This allows you to switch between them
    fairly easily and it also allows you to code without worrying about
    catching exceptions that are specific to each technology.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dao-exceptions"></a>10.2.&nbsp;Consistent Exception Hierarchy</h2></div></div></div><p>Spring provides a convenient translation from technology specific
    exceptions like <code class="literal">SQLException</code> to its own exception
    hierarchy with the <code class="literal">DataAccessException</code> as the root
    exception. These exceptions wrap the original exception so there is never
    any risk that you would lose any information as to what might have gone
    wrong.</p><p>In addition to JDBC exceptions, Spring can also wrap Hibernate
    exceptions, converting them from proprietary, checked exceptions, to a set
    of abstracted runtime exceptions. The same is true for JDO exceptions.
    This allows you to handle most persistence exceptions, which are
    non-recoverable, only in the appropriate layers, without annoying
    boilerplate catches/throws, and exception declarations. You can still trap
    and handle exceptions anywhere you need to. As we mentioned above, JDBC
    exceptions (including DB specific dialects) are also converted to the same
    hierarchy, meaning that you can perform some operations with JDBC within a
    consistent programming model.</p><p>The above is true for the Template versions of the ORM access
    framework. If you use the Interceptor based classes then the application
    must care about handling HibernateExceptions and JDOExceptions itself,
    preferably via delegating to <code class="literal">SessionFactoryUtils</code>'
    <code class="literal">convertHibernateAccessException</code> or
    <code class="literal">convertJdoAccessException</code> methods respectively. These
    methods converts the exceptions to ones that are compatible with the
    org.springframework.dao exception hierarchy. As JDOExceptions are
    unchecked, they can simply get thrown too, sacrificing generic DAO
    abstraction in terms of exceptions though.</p><p>The exception hierarchy that Spring uses is outlined in the
    following graph:</p><div class="mediaobject"><img src="images/DataAccessException.gif"></div><p></p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e6784"></a>10.3.&nbsp;Consistent Abstract Classes for DAO Support</h2></div></div></div><p>To make it easier to work with a variety of data access technologies
    like JDBC, JDO and Hibernate in a consistent way, Spring provides a set of
    abstract DAO classes that you can extend. These abstract classes has
    methods for setting the data source and any other configuration settings
    that are specific to the technology you currently are using.</p><p>Dao Support classes:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">JdbcDaoSupport</code> - super class for JDBC data
        access objects. Requires a DataSource to be set, providing a
        JdbcTemplate based on it to subclasses.</p></li><li><p><code class="literal">HibernateDaoSupport</code> - super class for
        Hibernate data access objects. Requires a SessionFactory to be set,
        providing a HibernateTemplate based on it to subclasses. Can
        alternatively be initialized directly via a HibernateTemplate, to
        reuse the latter's settings like SessionFactory, flush mode, exception
        translator, etc.</p></li><li><p><code class="literal">JdoDaoSupport</code> - super class for JDO data
        access objects. Requires a PersistenceManagerFactory to be set,
        providing a JdoTemplate based on it to subclasses.</p></li></ul></div><p></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jdbc"></a>Chapter&nbsp;11.&nbsp;Data Access using JDBC</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-introduction"></a>11.1.&nbsp;Introduction</h2></div></div></div><p>The JDBC abstraction framework provided by Spring consists of four
    different packages <code class="literal">core</code>, <code class="literal">datasource</code>,
    <code class="literal">object</code>, and <code class="literal">support</code>.</p><p>The <code class="literal">org.springframework.jdbc.core</code> package
    contains the JdbcTemplate class and its various callback interfaces, plus
    a variety of related classes.</p><p>The <code class="literal">org.springframework.jdbc.datasource</code> package
    contains a utility class for easy DataSource access, and various simple
    DataSource implementations that can be used for testing and running
    unmodified JDBC code outside of a J2EE container. The utility class
    provides static methods to obtain connections from JNDI and to close
    connections if necessary. It has support for thread-bound connections,
    e.g. for use with DataSourceTransactionManager.</p><p>Next, the <code class="literal">org.springframework.jdbc.object</code> package
    contains classes that represent RDBMS queries, updates, and stored
    procedures as thread safe, reusable objects. This approach is modeled by
    JDO, although of course objects returned by queries are
    &#8220;<span class="quote">disconnected</span>&#8221; from the database. This higher level of JDBC
    abstraction depends on the lower-level abstraction in the
    <code class="literal">org.springframework.jdbc.core</code> package.</p><p>Finally the <code class="literal">org.springframework.jdbc.support</code>
    package is where you find the <code class="literal">SQLException</code> translation
    functionality and some utility classes.</p><p>Exceptions thrown during JDBC processing are translated to
    exceptions defined in the <code class="literal">org.springframework.dao</code>
    package. This means that code using the Spring JDBC abstraction layer does
    not need to implement JDBC or RDBMS-specific error handling. All
    translated exceptions are unchecked giving you the option of catching the
    exceptions that you can recover from while allowing other exceptions to be
    propagated to the caller.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-core"></a>11.2.&nbsp;Using the JDBC Core classes to control basic JDBC processing and
    error handling</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-JdbcTemplate"></a>11.2.1.&nbsp;JdbcTemplate</h3></div></div></div><p>This is the central class in the JDBC core package. It simplifies
      the use of JDBC since it handles the creation and release of resources.
      This helps to avoid common errors like forgetting to always close the
      connection. It executes the core JDBC workflow like statement creation
      and execution, leaving application code to provide SQL and extract
      results. This class executes SQL queries, update statements or stored
      procedure calls, imitating iteration over ResultSets and extraction of
      returned parameter values. It also catches JDBC exceptions and
      translates them to the generic, more informative, exception hierarchy
      defined in the <code class="literal">org.springframework.dao</code>
      package.</p><p>Code using this class only need to implement callback interfaces,
      giving them a clearly defined contract. The
      <code class="literal">PreparedStatementCreator</code> callback interface creates a
      prepared statement given a Connection provided by this class, providing
      SQL and any necessary parameters. The same is true for the
      <code class="literal">CallableStatementCreator</code> interface which creates
      callable statement. The <code class="literal">RowCallbackHandler</code> interface
      extracts values from each row of a ResultSet.</p><p>This class can be used within a service implementation via direct
      instantiation with a DataSource reference, or get prepared in an
      application context and given to services as bean reference. Note: The
      DataSource should always be configured as a bean in the application
      context, in the first case given to the service directly, in the second
      case to the prepared template. Because this class is parameterizable by
      the callback interfaces and the SQLExceptionTranslator interface, it
      isn't necessary to subclass it. All SQL issued by this class is
      logged.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6886"></a>11.2.2.&nbsp;DataSource</h3></div></div></div><p>In order to work with data from a database, we need to obtain a
      connection to the database. The way Spring does this is through a
      <code class="literal">DataSource</code>. A <code class="literal">DataSource</code> is part
      of the JDBC specification and can be seen as a generalized connection
      factory. It allows a container or a framework to hide connection pooling
      and transaction management issues from the application code. As a
      developer, you don't need to know any details about how to connect to
      the database, that is the responsibility for the administrator that sets
      up the datasource. You will most likely have to fulfill both roles while
      you are developing and testing you code though, but you will not
      necessarily have to know how the production data source is
      configured.</p><p>When using Spring's JDBC layer, you can either obtain a data
      source from JNDI or you can configure your own, using an implementation
      that is provided in the Spring distribution. The latter comes in handy
      for unit testing outside of a web container. We will use the
      <code class="literal">DriverManagerDataSource</code> implementation for this
      section but there are several additional implementations that will be
      covered later on. The <code class="literal">DriverManagerDataSource</code> works
      the same way that you probably are used to work when you obtain a JDBC
      connection. You have to specify the fully qualified class name of the
      JDBC driver that you are using so that the
      <code class="literal">DriverManager</code> can load the driver class. Then you
      have to provide a url that varies between JDBC drivers. You have to
      consult the documentation for your driver for the correct value to use
      here. Finally you must provide a username and a password that will be
      used to connect to the database. Here is an example of how to configure
      a <code class="literal">DriverManagerDataSource:</code></p><pre class="programlisting">DriverManagerDataSource dataSource = new DriverManagerDataSource();
dataSource.setDriverClassName( "org.hsqldb.jdbcDriver");
dataSource.setUrl( "jdbc:hsqldb:hsql://localhost:");
dataSource.setUsername( "sa");
dataSource.setPassword( ""); </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SQLExceptionTranslator"></a>11.2.3.&nbsp;SQLExceptionTranslator</h3></div></div></div><p><code class="literal">SQLExceptionTranslator</code> is an interface to be
      implemented by classes that can translate between SQLExceptions and our
      data access strategy-agnostic
      <code class="literal">org.springframework.dao.DataAccessException</code>.</p><p>Implementations can be generic (for example, using SQLState codes
      for JDBC) or proprietary (for example, using Oracle error codes) for
      greater precision.</p><p><code class="literal">SQLErrorCodeSQLExceptionTranslator</code> is the
      implementation of SQLExceptionTranslator that is used by default. This
      implementation uses specific vendor codes. More precise than
      <code class="literal">SQLState</code> implementation, but vendor specific. The
      error code translations are based on codes held in a JavaBean type class
      named <code class="literal">SQLErrorCodes</code>. This class is created and
      populated by an <code class="literal">SQLErrorCodesFactory</code> which as the
      name suggests is a factory for creating <code class="literal">SQLErrorCodes</code>
      based on the contents of a configuration file named
      "sql-error-codes.xml". This file is populated with vendor codes and
      based on the DatabaseProductName taken from the DatabaseMetaData, the
      codes for the current database are used.</p><p>The <code class="literal">SQLErrorCodeSQLExceptionTranslator</code> applies
      the following matching rules:</p><div class="itemizedlist"><ul type="disc" compact><li><p>Try custom translation implemented by any subclass. Note
            that this class is concrete and is typically used itself, in which
            case this rule doesn't apply.</p></li><li><p>Apply error code matching. Error codes are obtained from the
            SQLErrorCodesFactory by default. This looks up error codes from
            the classpath and keys into them from the database name from the
            database metadata.</p></li><li><p>Use the fallback translator. SQLStateSQLExceptionTranslator
            is the default fallback translator.</p></li></ul></div><p><code class="literal">SQLErrorCodeSQLExceptionTranslator</code> can be
      extended the following way: </p><pre class="programlisting">public class MySQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {
    protected DataAccessException customTranslate(String task, String sql, SQLException sqlex) {
        if (sqlex.getErrorCode() == -12345)
            return new DeadlockLoserDataAccessException(task, sqlex);
        return null;
    }
}</pre><p>In this example the specific error code '-12345' is
      translated and any other errors are simply left to be translated by the
      default translator implementation. To use this custom translator, it is
      necessary to pass it to the <code class="literal">JdbcTemplate</code> using the
      method <code class="literal">setExceptionTranslator</code> and to use this
      <code class="literal">JdbcTemplate</code> for all of the data access processing
      where this translator is needed. Here is an example of how this custom
      translator can be used: </p><pre class="programlisting">// create a JdbcTemplate and set data source 
JdbcTemplate jt = new JdbcTemplate(); 
jt.setDataSource(dataSource); 
// create a custom translator and set the datasource for the default translation lookup 
MySQLErrorCodesTransalator tr = new MySQLErrorCodesTransalator(); 
tr.setDataSource(dataSource); 
jt.setExceptionTranslator(tr); 
// use the JdbcTemplate for this SqlUpdate 
SqlUpdate su = new SqlUpdate(); 
su.setJdbcTemplate(jt); 
su.setSql("update orders set shipping_charge = shipping_charge * 1.05"); 
su.compile(); 
su.update();</pre><p>The custom translator is passed a data source
      because we still want the default translation to look up the error codes
      in <code class="literal">sql-error-codes.xml</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6977"></a>11.2.4.&nbsp;Executing Statements</h3></div></div></div><p>To execute an SQL statement, there is very little code needed. All
      you need is a <code class="literal">DataSource</code> and a
      <code class="literal">JdbcTemplate</code>. Once you have that, you can use a
      number of convenience methods that are provided with the
      <code class="literal">JdbcTemplate</code>. Here is a short example showing what
      you need to include for a minimal but fully functional class that
      creates a new table.</p><pre class="programlisting">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAStatement {

    private JdbcTemplate jt;
    private DataSource dataSource;

    public void doExecute() {
        jt = new JdbcTemplate(dataSource);
        jt.execute("create table mytable (id integer, name varchar(100))"); 
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e6993"></a>11.2.5.&nbsp;Running Queries</h3></div></div></div><p>In addition to the execute methods, there is a large number of
      query methods. Some of these methods are intended to be used for queries
      that return a single value. Maybe you want to retrieve a count or a
      specific value from one row. If that is the case then you can use
      <code class="literal">queryForInt</code>,<code class="literal">queryForLong</code> or
      <code class="literal">queryForObject</code>. The latter will convert the returned
      JDBC Type to the Java class that is passed in as an argument. If the
      type conversion is invalid, then an
      <code class="literal">InvalidDataAccessApiUsageException</code> will be thrown.
      Here is an example that contains two query methods, one for an
      <code class="literal">int</code> and one that queries for a
      <code class="literal">String</code>.</p><pre class="programlisting">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class RunAQuery {

    private JdbcTemplate jt;
    private DataSource dataSource;
  
    public int getCount() {
        jt = new JdbcTemplate(dataSource);
        int count = jt.queryForInt("select count(*) from mytable");
        return count;
    }

    public String getName() {
        jt = new JdbcTemplate(dataSource);
        String name = (String) jt.queryForObject("select name from mytable", String.class);
        return name;
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}</pre><p>In addition to the single results query methods there are several
      methods that return a List with an entry for each row that the query
      returned. The most generic one is <code class="literal">queryForList</code> which
      returns a <code class="literal">List</code> where each entry is a
      <code class="literal">Map</code> with each entry in the map representing the
      column value for that row. If we add a method to the above example to
      retrieve a list of all the rows, it would look like this:</p><pre class="programlisting">    public List getList() {
        jt = new JdbcTemplate(dataSource);
        List rows = jt.queryForList("select * from mytable");
        return rows;
    }</pre><p>The list returned would look something like this:
      <code class="literal">[{name=Bob, id=1}, {name=Mary, id=2}].</code></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7035"></a>11.2.6.&nbsp;Updating the database</h3></div></div></div><p>There are also a number of update methods that you can use. I will
      show an example where we update a column for a certain primary key. In
      this example I am using an SQL statement that has place holders for row
      parameters. Most of the query and update methods have this
      functionality. The parameter values are passed in as an array of
      objects.</p><pre class="programlisting">import javax.sql.DataSource;

import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAnUpdate {

    private JdbcTemplate jt;
    private DataSource dataSource;

    public void setName(int id, String name) {
        jt = new JdbcTemplate(dataSource);
        jt.update("update mytable set name = ? where id = ?", new Object[] {name, new Integer(id)});
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}</pre><p></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-datasource"></a>11.3.&nbsp;Controlling how we connect to the database</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-DataSourceUtils"></a>11.3.1.&nbsp;DataSourceUtils</h3></div></div></div><p>Helper class that provides static methods to obtain connections
      from JNDI and close connections if necessary. Has support for
      thread-bound connections, e.g. for use with
      <code class="literal">DataSourceTransactionManager</code>.</p><p>Note: The <code class="literal">getDataSourceFromJndi</code> methods are
      targeted at applications that do not use a bean factory or application
      context. With the latter, it is preferable to preconfigure your beans or
      even <code class="literal"><code class="literal">JdbcTemplate</code></code> instances in the
      factory: <code class="literal">JndiObjectFactoryBean</code> can be used to fetch a
      <code class="literal"><code class="literal">DataSource</code></code> from JNDI and give the
      <code class="literal"><code class="literal">DataSource</code></code> bean reference to other
      beans. Switching to another
      <code class="literal"><code class="literal">DataSource</code></code> is just a matter of
      configuration then: You can even replace the definition of the
      <code class="literal">FactoryBean</code> with a non-JNDI
      <code class="literal"><code class="literal">DataSource</code></code>!</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SmartDataSource"></a>11.3.2.&nbsp;SmartDataSource</h3></div></div></div><p>Interface to be implemented by classes that can provide a
      connection to a relational database. Extends the
      <code class="literal">javax.sql.DataSource</code> interface to allow classes using
      it to query whether or not the connection should be closed after a given
      operation. This can sometimes be useful for efficiency, if we know that
      we want to reuse a connection.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-AbstractDataSource"></a>11.3.3.&nbsp;AbstractDataSource</h3></div></div></div><p>Abstract base class for Spring's <code class="literal">DataSource</code>
      implementations, taking care of the "uninteresting" glue. This is the
      class you would extend if you are writing your own
      <code class="literal">DataSource</code> implementation.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SingleConnectionDataSource"></a>11.3.4.&nbsp;SingleConnectionDataSource</h3></div></div></div><p>Implementation of <code class="literal">SmartDataSource</code> that wraps a
      single connection which is not closed after use. Obviously, this is not
      multi-threading capable.</p><p>If client code will call close in the assumption of a pooled
      connection, like when using persistence tools, set
      <code class="literal">suppressClose</code> to true. This will return a
      close-suppressing proxy instead of the physical connection. Be aware
      that you will not be able to cast this to a native Oracle Connection or
      the like anymore.</p><p>This is primarily a test class. For example, it enables easy
      testing of code outside an application server, in conjunction with a
      simple JNDI environment. In contrast to
      <code class="literal">DriverManagerDataSource</code>, it reuses the same
      connection all the time, avoiding excessive creation of physical
      connections.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-DriverManagerDataSource"></a>11.3.5.&nbsp;DriverManagerDataSource</h3></div></div></div><p>Implementation of <code class="literal">SmartDataSource</code> that
      configures a plain old JDBC Driver via bean properties, and returns a
      new connection every time.</p><p>This is Potentially useful for test or standalone environments
      outside of a J2EE container, either as a <code class="literal">DataSource</code>
      bean in a respective ApplicationContext, or in conjunction with a simple
      JNDI environment. Pool-assuming <code class="literal">Connection.close()</code>
      calls will simply close the connection, so any DataSource-aware
      persistence code should work. However, using JavaBean style connection
      pools such as commons-dbcp is so easy, even in a test environment, that
      it is almost always preferable to use such a connection pool over
      <code class="literal">DriverManagerDataSource</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-TransactionAwareDataSourceProxy"></a>11.3.6.&nbsp;TransactionAwareDataSourceProxy</h3></div></div></div><p>This is a proxy for a target <code class="literal">DataSource</code>, which
      wraps that target <code class="literal">DataSource</code> to add awareness of
      Spring-managed transactions. In this respect it is similar to a
      transactional JNDI <code class="literal">DataSource</code> as provided by a J2EE
      server.</p><p>It should almost never be necessary or desireable to use this
      class, except when existing code exists which must be called and passed
      a standard JDBC <code class="literal">DataSource</code> interface implementation.
      In this case, it's possible to still have this code be usable, but
      participating in Spring managed transactions. It is generally preferable
      to write your own new code using the higher level abstractions for
      resource management, such as <code class="literal">JdbcTemplate</code> or
      <code class="literal">DataSourceUtils</code>.</p><p>See the <code class="literal">TransactionAwareDataSourceProxy</code>
      Javadocs for more details.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-DataSourceTransactionManager"></a>11.3.7.&nbsp;DataSourceTransactionManager</h3></div></div></div><p>PlatformTransactionManager implementation for single JDBC data
      sources. Binds a JDBC connection from the specified data source to the
      thread, potentially allowing for one thread connection per data
      source.</p><p>Application code is required to retrieve the JDBC connection via
      <code class="literal">DataSourceUtils.getConnection(DataSource)</code> instead of
      J2EE's standard <code class="literal">DataSource.getConnection</code>. This is
      recommended anyway, as it throws unchecked
      <code class="literal">org.springframework.dao</code> exceptions instead of checked
      <code class="literal">SQLException</code>. All framework classes like
      <code class="literal">JdbcTemplate</code> use this strategy implicitly. If not
      used with this transaction manager, the lookup strategy behaves exactly
      like the common one - it can thus be used in any case.</p><p>Supports custom isolation levels, and timeouts that get applied as
      appropriate JDBC statement query timeouts. To support the latter,
      application code must either use <code class="literal">JdbcTemplate</code> or call
      <code class="literal">DataSourceUtils.applyTransactionTimeout</code> method for
      each created statement.</p><p>This implementation can be used instead of
      <code class="literal">JtaTransactionManager</code> in the single resource case, as
      it does not require the container to support JTA. Switching between both
      is just a matter of configuration, if you stick to the required
      connection lookup pattern. Note that JTA does not support custom
      isolation levels!</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-object"></a>11.4.&nbsp;Modeling JDBC operations as Java objects</h2></div></div></div><p>The <code class="literal">org.springframework.jdbc.object</code> package
    contains the classes that allow you to access the database in a more
    object oriented manner. You can execute queries and get the results back
    as a list containing business objects with the relational column data
    mapped to the properties of the business object. You can also execute
    stored procedures and run update, delete and insert statements.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SqlQuery"></a>11.4.1.&nbsp;SqlQuery</h3></div></div></div><p>Reusable thread safe object to represent an SQL query. Subclasses
      must implement the newResultReader() method to provide an object that
      can save the results while iterating over the ResultSet. This class is
      rarely used directly since the <code class="literal">MappingSqlQuery</code>, that
      extends this class, provides a much more convenient implementation for
      mapping rows to Java classes. Other implementations that extend
      <code class="literal">SqlQuery</code> are
      <code class="literal">MappingSqlQueryWithParameters</code> and
      <code class="literal">UpdatableSqlQuery</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-MappingSqlQuery"></a>11.4.2.&nbsp;MappingSqlQuery</h3></div></div></div><p><code class="literal">MappingSqlQuery</code> is a reusable query in which
      concrete subclasses must implement the abstract
      <code class="literal">mapRow(ResultSet, int)</code> method to convert each row of
      the JDBC <code class="literal">ResultSet</code> into an object.</p><p>Of all the <code class="literal">SqlQuery</code> implementations, this is
      the one used most often and it is also the one that is the easiest to
      use.</p><p>Here is a brief example of a custom query that maps the data from
      the customer table to a Java object called Customer.</p><pre class="programlisting">private class CustomerMappingQuery extends MappingSqlQuery {

    public CustomerMappingQuery(DataSource ds) {
        super(ds, "SELECT id, name FROM customer WHERE id = ?");
        super.declareParameter(new SqlParameter("id", Types.INTEGER));
        compile();
    }

    public Object mapRow(ResultSet rs, int rowNumber) throws SQLException {
        Customer cust = new Customer();
        cust.setId((Integer) rs.getObject("id"));
        cust.setName(rs.getString("name"));
        return cust;
    } 
  }</pre><p>We provide a constructor for this customer query that takes the
      <code class="literal">DataSource</code> as the only parameter. In this constructor
      we call the constructor on the superclass with the
      <code class="literal">DataSource</code> and the SQL that should be executed to
      retrieve the rows for this query. This SQL will be used to create a
      <code class="literal">PreparedStatement</code> so it may contain place holders for
      any parameters to be passed in during execution. Each parameter must be
      declared using the <code class="literal">declareParameter</code> method passing in
      an <code class="literal">SqlParameter</code>. The <code class="literal">SqlParameter</code>
      takes a name and the JDBC type as defined in
      <code class="literal">java.sql.Types</code>. After all parameters have been
      defined we call the <code class="literal">compile</code> method so the statement
      can be prepared and later be executed.</p><p>Let's take a look at the code where this custom query is
      instantiated and executed:</p><pre class="programlisting">    public Customer getCustomer(Integer id) {
        CustomerMappingQuery custQry = new CustomerMappingQuery(dataSource); 
        Object[] parms = new Object[1];
        parms[0] = id;
        List customers = custQry.execute(parms);
        if (customers.size() &gt; 0)
            return (Customer) customers.get(0);
        else
            return null;
    }</pre><p>The method in this example retrieves the customer with the id that
      is passed in as the only parameter. After creating an instance of the
      <code class="literal">CustomerMappingQuery</code> class we create an array of
      objects that will contain all parameters that are passed in. In this
      case there is only one parameter and it is passed in as an
      <code class="literal">Integer</code>. Now we are ready to execute the query using
      this array of parameters and we get a <code class="literal">List</code> that
      contains a <code class="literal">Customer</code> object for each row that was
      returned for our query. In this case it will only be one entry if there
      was a match.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SqlUpdate"></a>11.4.3.&nbsp;SqlUpdate</h3></div></div></div><p>RdbmsOperation subclass representing a SQL update. Like a query,
      an update object is reusable. Like all RdbmsOperation objects, an update
      can have parameters and is defined in SQL.</p><p>This class provides a number of update() methods analogous to the
      execute() methods of query objects.</p><p>This class is concrete. Although it can be subclassed (for example
      to add a custom update method) it can easily be parameterized by setting
      SQL and declaring parameters.</p><pre class="programlisting">import java.sql.Types;

import javax.sql.DataSource;

import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.SqlUpdate;

public class UpdateCreditRating extends SqlUpdate {

    public UpdateCreditRating(DataSource ds) {
        setDataSource(ds);
        setSql("update customer set credit_rating = ? where id = ?");
        declareParameter(new SqlParameter(Types.NUMERIC));
        declareParameter(new SqlParameter(Types.NUMERIC));
        compile();
    }

    /**
     * @param id for the Customer to be updated
     * @param rating the new value for credit rating
     * @return number of rows updated
     */
    public int run(int id, int rating) {
        Object[] params =
            new Object[] {
                new Integer(rating),
                new Integer(id)};
        return update(params);
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-StoredProcedure"></a>11.4.4.&nbsp;StoredProcedure</h3></div></div></div><p>Superclass for object abstractions of RDBMS stored procedures.
      This class is abstract and its execute methods are protected, preventing
      use other than through a subclass that offers tighter typing.</p><p>The inherited sql property is the name of the stored procedure in
      the RDBMS. Note that JDBC 3.0 introduces named parameters, although the
      other features provided by this class are still necessary in JDBC
      3.0.</p><p>Here is an example of a program that calls a function sysdate()
      that comes with any Oracle database. To use the stored procedure
      functionality you have to create a class that extends
      <code class="literal">StoredProcedure</code>. There are no input parameters, but
      there is an output parameter that is declared as a date using the class
      <code class="literal">SqlOutParameter</code>. The <code class="literal">execute()</code>
      method returns a map with an entry for each declared output parameter
      using the parameter name as the key.</p><pre class="programlisting">import java.sql.Types;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.datasource.*;
import org.springframework.jdbc.object.StoredProcedure;

public class TestStoredProcedure {

    public static void main(String[] args)  {
        TestStoredProcedure t = new TestStoredProcedure();
        t.test();
        System.out.println("Done!");
    }
    
    void test() {
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName("oracle.jdbc.OracleDriver");
        ds.setUrl("jdbc:oracle:thin:@localhost:1521:mydb");
        ds.setUsername("scott");
        ds.setPassword("tiger");

        MyStoredProcedure sproc = new MyStoredProcedure(ds);
        Map res = sproc.execute();
        printMap(res);
    }

    private class MyStoredProcedure extends StoredProcedure {
        public static final String SQL = "sysdate";

        public MyStoredProcedure(DataSource ds) {
            setDataSource(ds);
            setFunction(true);
            setSql(SQL);
            declareParameter(new SqlOutParameter("date", Types.DATE));
            compile();
        }

        public Map execute() {
            Map out = execute(new HashMap());
            return out;
        }

    }

    private static void printMap(Map r) {
        Iterator i = r.entrySet().iterator();
        while (i.hasNext()) {
            System.out.println((String) i.next().toString());  
        }
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SqlFunction"></a>11.4.5.&nbsp;SqlFunction</h3></div></div></div><p>SQL "function" wrapper for a query that returns a single row of
      results. The default behavior is to return an int, but that can be
      overridden by using the methods with an extra return type parameter.
      This is similar to using the <code class="literal">queryForXxx</code> methods of
      the <code class="literal">JdbcTemplate</code>. The advantage with
      <code class="literal">SqlFunction</code> is that you don't have to create the
      <code class="literal">JdbcTemplate</code>, it is done behind the scenes.</p><p>This class is intended to use to call SQL functions that return a
      single result using a query like "select user()" or "select sysdate from
      dual". It is not intended for calling more complex stored functions or
      for using a <code class="literal">CallableStatement</code> to invoke a stored
      procedure or stored function. Use <code class="literal">StoredProcedure</code> or
      <code class="literal">SqlCall</code> for this type of processing.</p><p>This is a concrete class, which there is normally no need to
      subclass. Code using this package can create an object of this type,
      declaring SQL and parameters, and then invoke the appropriate run method
      repeatedly to execute the function. Here is an example of retrieving the
      count of rows from a table:</p><pre class="programlisting">    public int countRows() {
        SqlFunction sf = new SqlFunction(dataSource, "select count(*) from mytable");
        sf.compile();
        return sf.run();
    }</pre><p></p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="orm"></a>Chapter&nbsp;12.&nbsp;Data Access using O/R Mappers</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-introduction"></a>12.1.&nbsp;Introduction</h2></div></div></div><p>Spring provides integration with <span class="emphasis"><em>Hibernate, JDO, Oracle
    TopLink, Apache OJB</em></span> and <span class="emphasis"><em>iBATIS SQL Maps</em></span>:
    in terms of resource management, DAO implementation support, and
    transaction strategies. For example for Hibernate, there is first-class
    support with lots of IoC convenience features, addressing many typical
    Hibernate integration issues. All of these support packages for O/R
    mappers comply with Spring's generic transaction and DAO exception
    hierarchies. There are usually two integration styles: either using
    Spring's DAO 'templates' or coding DAOs against plain
    Hibernate/JDO/TopLink/etc APIs. In both cases, DAOs can be configured
    through Dependency Injection and participate in Spring's resource and
    transaction management.</p><p>Spring's adds significant support when using the O/R mapping layer
    of your choice to create data access applications. First of all, you
    should know that once you started using Spring's support for O/R mapping,
    you don't have to go all the way. No matter to what extent, you're invited
    to review and leverage the Spring approach, before deciding to take the
    effort and risk of building a similar infrastructure in-house. Much of the
    O/R mapping support, no matter what technology you're using may be used in
    a library style, as everything is designed as a set of reusable JavaBeans.
    Usage inside an ApplicationContext does provide additional benefits in
    terms of ease of configuration and deployment; as such, most examples in
    this section show configuration inside an ApplicationContext.</p><p>Some of the the benefits of using Spring to create your O/R mapping
    DAOs include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Ease of testing.</em></span> Spring's inversion of
        control approach makes it easy to swap the implementations and config
        locations of Hibernate SessionFactory instances, JDBC DataSources,
        transaction managers, and mapper object implementations (if needed).
        This makes it much easier to isolate and test each piece of
        persistence-related code in isolation.</p></li><li><p><span class="emphasis"><em>Common data access exceptions.</em></span>Spring can
        wrap exceptions from you O/R mapping tool of choice, converting them
        from proprietary (potentially checked) exceptions to a common runtime
        DataAccessException hierarchy. This allows you to handle most
        persistence exceptions, which are non-recoverable, only in the
        appropriate layers, without annoying boilerplate catches/throws, and
        exception declarations. You can still trap and handle exceptions
        anywhere you need to. Remember that JDBC exceptions (including DB
        specific dialects) are also converted to the same hierarchy, meaning
        that you can perform some operations with JDBC within a consistent
        programming model.</p></li><li><p><span class="emphasis"><em>General resource management.</em></span> Spring
        application contexts can handle the location and configuration of
        Hibernate SessionFactory instances, JDBC DataSources, iBATIS SQL Maps
        configuration objects, and other related resources. This makes these
        values easy to manage and change. Spring offers efficient, easy and
        safe handling of persistence resources. For example: Related code
        using Hibernate generally needs to use the same Hibernate Session for
        efficiency and proper transaction handling. Spring makes it easy to
        transparently create and bind a Session to the current thread, either
        by using an explicit 'template' wrapper class at the Java code level
        or by exposing a current Session through the Hibernate SessionFactory
        (for DAOs based on plain Hibernate3 API). Thus Spring solves many of
        the issues that repeatedly arise from typical Hibernate usage, for any
        transaction environment (local or JTA).</p></li><li><p><span class="emphasis"><em>Integrated transaction management.</em></span> Spring
        allows you to wrap your O/R mapping code with either a declarative,
        AOP style method interceptor, or an explicit 'template' wrapper class
        at the Java code level. In either case, transaction semantics are
        handled for you, and proper transaction handling (rollback, etc) in
        case of exceptions is taken care of. As discussed below, you also get
        the benefit of being able to use and swap various transaction
        managers, without your Hibernate/JDO related code being affected: for
        example, between local transactions and JTA, with the same full
        services (such as declarative transactions) available in both
        scenarios. As an additional benefit, JDBC-related code can fully
        integrate transactionally with the code you use to do O/R mapping.
        This is useful for data access that's not suitable for O/R mapping,
        such as batch processing or streaming of BLOBs, which still needs to
        share common transactions with O/R mapping operations.</p></li><li><p><span class="emphasis"><em>To avoid vendor lock-in, and allow mix-and-match
        implementation strategies.</em></span> While Hibernate is powerful,
        flexible, open source and free, it still uses a proprietary API.
        Furthermore one could argue that iBATIS is a bit lightweight, although
        it's excellent for use in application that don't require complex O/R
        mapping strategies. Given the choice, it's usually desirable to
        implement major application functionality using standard or abstracted
        APIs, in case you need to switch to another implementation for reasons
        of functionality, performance, or any other concerns. For example,
        Spring's abstraction of Hibernate transactions and exceptions, along
        with its IoC approach which allows you to easily swap in mapper/DAO
        objects implementing data access functionality, makes it easy to
        isolate all Hibernate-specific code in one area of your application,
        without sacrificing any of the power of Hibernate. Higher level
        service code dealing with the DAOs has no need to know anything about
        their implementation. This approach has the additional benefit of
        making it easy to intentionally implement data access with a
        mix-and-match approach (i.e. some data access performed using
        Hibernate, and some using JDBC, others using iBATIS) in a
        non-intrusive fashion, potentially providing great benefits in terms
        of continuing to use legacy code or leveraging the strength of each
        technology.</p></li></ul></div><p>The PetClinic sample in the Spring distribution offers alternative
    DAO implementations and application context configurations for JDBC,
    Hibernate, Oracle TopLink, and Apache OJB. PetClinic can therefore serve
    as working sample app that illustrates the use of Hibernate, TopLink and
    OJB in a Spring web application. It also leverages declarative transaction
    demarcation with different transaction strategies.</p><p>The JPetStore sample illustrates the use of iBATIS SQL Maps in a
    Spring environment. It also features two web tier versions: one based on
    Spring Web MVC, one based on Struts.</p><p>Beyond the samples shipped with Spring, there is a variety of
    Spring-based O/R mapping samples provided by specific vendors: for
    example, the JDO implementations JPOX (<a href="http://www.jpox.org" target="_top">http://www.jpox.org</a>) and Kodo (<a href="http://www.solarmetric.com" target="_top">http://www.solarmetric.com</a>).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-hibernate"></a>12.2.&nbsp;Hibernate</h2></div></div></div><p>We will start with a coverage of Hibernate (<a href="http://www.hibernate.org" target="_top">http://www.hibernate.org</a>) in a Spring environment, using it
    to demonstrate the approach that Spring takes towards integrating O/R
    mappers. This section will cover many issues in detail and show different
    variations of DAO implementations and transaction demarcations. Most of
    these patterns can be directly translated to all other supported O/R
    mapping tools. The following sections in this chapter will then cover the
    other O/R mappers, showing briefer examples there.</p><p>The following discussion focuses on "classic" Hibernate: that is,
    Hibernate 2.1, which has been supported in Spring since its inception. All
    of this can be applied to Hibernate 3.0 as-is, using the analogous
    Hibernate 3 support package introduced in Spring 1.2 final:
    <code class="literal">org.springframework.orm.hibernate3</code>, mirroring
    <code class="literal">org.springframework.orm.hibernate</code> with analogous
    support classes for Hibernate 3. Furthermore, all references to the
    <code class="literal">net.sf.hibernate</code> package need to be replaced with
    <code class="literal">org.hibernate</code>, following the root package change in
    Hibernate 3. Simply adapt the package names (as used in the examples)
    accordingly.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7437"></a>12.2.1.&nbsp;Resource management</h3></div></div></div><p>Typical business applications are often cluttered with repetitive
      resource management code. Many projects try to invent their own
      solutions for this issue, sometimes sacrificing proper handling of
      failures for programming convenience. Spring advocates strikingly simple
      solutions for proper resource handling: Inversion of control via
      templating, i.e. infrastructure classes with callback interfaces, or
      applying AOP interceptors. The infrastructure cares for proper resource
      handling, and for appropriate conversion of specific API exceptions to
      an unchecked infrastructure exception hierarchy. Spring introduces a DAO
      exception hierarchy, applicable to any data access strategy. For direct
      JDBC, the <code class="classname">JdbcTemplate</code> class mentioned in a
      previous section cares for connection handling, and for proper
      conversion of <code class="classname">SQLException</code> to the
      <code class="classname">DataAccessException</code> hierarchy, including
      translation of database-specific SQL error codes to meaningful exception
      classes. It supports both JTA and JDBC transactions, via respective
      Spring transaction managers.</p><p>Spring also offers Hibernate and JDO support, consisting of a
      <code class="classname">HibernateTemplate</code> /
      <code class="classname">JdoTemplate</code> analogous to
      <code class="classname">JdbcTemplate</code>, a
      <code class="classname">HibernateInterceptor</code> /
      <code class="classname">JdoInterceptor</code>, and a Hibernate / JDO transaction
      manager. The major goal is to allow for clear application layering, with
      any data access and transaction technology, and for loose coupling of
      application objects. No more business service dependencies on the data
      access or transaction strategy, no more hard-coded resource lookups, no
      more hard-to-replace singletons, no more custom service registries. One
      simple and consistent approach to wiring up application objects, keeping
      them as reusable and free from container dependencies as possible. All
      the individual data access features are usable on their own but
      integrate nicely with Spring's application context concept, providing
      XML-based configuration and cross-referencing of plain JavaBean
      instances that don't need to be Spring-aware. In a typical Spring app,
      many important objects are JavaBeans: data access templates, data access
      objects (that use the templates), transaction managers, business
      services (that use the data access objects and transaction managers),
      web view resolvers, web controllers (that use the business services),
      etc.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7468"></a>12.2.2.&nbsp;SessionFactory setup in a Spring application context</h3></div></div></div><p>To avoid tying application objects to hard-coded resource lookups,
      Spring allows you to define resources like a JDBC DataSource or a
      Hibernate SessionFactory as beans in an application context. Application
      objects that need to access resources just receive references to such
      pre-defined instances via bean references (the DAO definition in the
      next section illustrates this). The following excerpt from an XML
      application context definition shows how to set up a JDBC
      <code class="classname">DataSource</code> and a Hibernate
      <code class="classname">SessionFactory</code> on top of it:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver"/&gt;
    &lt;property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
    &lt;property name="username" value="sa"/&gt;
    &lt;property name="password" value=""/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;props&gt;
        &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

   ...
&lt;/beans&gt;</pre><p>Note that switching from a local Jakarta Commons DBCP
      <code class="classname">BasicDataSource</code> to a JNDI-located
      <code class="classname">DataSource</code> (usually managed by the J2EE server)
      is just a matter of configuration:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>You can also access a JNDI-located
      <code class="classname">SessionFactory</code>, using Spring's
      JndiObjectFactoryBean to retrieve and expose it. However, that's
      typically not necessary outside an EJB context. See the "container
      resources versus local resources" section for a discussion.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7496"></a>12.2.3.&nbsp;Inversion of Control: HibernateTemplate and
      HibernateCallback</h3></div></div></div><p>The basic programming model for templating looks as follows, for
      methods that can be part of any custom data access object or business
      service. There are no restrictions on the implementation of the
      surrounding object at all, it just needs to provide a Hibernate
      <code class="classname">SessionFactory</code>. It can get the latter from
      anywhere, but preferably as bean reference from a Spring application
      context - via a simple <code class="literal">setSessionFactory</code> bean
      property setter. The following snippets show a DAO definition in a
      Spring application context, referencing the above defined
      <code class="classname">SessionFactory,</code> and an example for a DAO method
      implementation.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        HibernateTemplate ht = new HibernateTemplate(this.sessionFactory);
        return (Collection) ht.execute(new HibernateCallback() {
            public Object doInHibernate(Session session) throws HibernateException {
                Query query = session.createQuery(
                    "from test.Product product where product.category=?");
                query.setString(0, category);
                return query.list();
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any
      Hibernate data access. <code class="classname">HibernateTemplate</code> will
      ensure that <code class="classname">Session</code>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single step
      actions like a single find, load, saveOrUpdate, or delete call,
      <code class="classname">HibernateTemplate</code> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <code class="classname">HibernateDaoSupport</code> base class that provides a
      <code class="literal">setSessionFactory</code> method for receiving a
      <code class="classname">SessionFactory</code>, and
      <code class="literal">getSessionFactory</code> and
      <code class="literal">getHibernateTemplate</code> for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return getHibernateTemplate().find(
            "from test.Product product where product.category=?", category);
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7542"></a>12.2.4.&nbsp;Implementing Spring-based DAOs without callbacks</h3></div></div></div><p>As alternative to using Spring's
      <code class="classname">HibernateTemplate</code> to implement DAOs, data access
      code can also be written in a more traditional fashion, without wrapping
      the Hibernate access code in a callback, while still complying to
      Spring's generic <code class="literal">DataAccessException</code> hierarchy.
      Spring's <code class="literal">HibernateDaoSupport</code> base class offers
      methods to access the current transactional Session and to convert
      exceptions in such a scenario; similar methods are also available as
      static helpers on the <code class="literal">SessionFactoryUtils</code> class. Note
      that such code will usually pass "false" into
      <code class="literal">getSession</code>'s the "allowCreate" flag, to enforce
      running within a transaction (which avoids the need to close the
      returned Session, as it its lifecycle is managed by the
      transaction).</p><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category)
            throws DataAccessException, MyException {

        Session session = getSession(getSessionFactory(), false);
        try {
            List result = session.find(
                "from test.Product product where product.category=?",
                category, Hibernate.STRING);
            if (result == null) {
                throw new MyException("invalid search result");
            }
            return result;
        }
        catch (HibernateException ex) {
            throw convertHibernateAccessException(ex);
        }
    }
}</pre><p>The major advantage of such direct Hibernate access code is that
      it allows any checked application exception to be thrown within the data
      access code, while <code class="literal">HibernateTemplate</code> is restricted to
      unchecked exceptions within the callback. Note that one can often defer
      the corresponding checks and the throwing of application exceptions to
      after the callback, which still allows working with
      <code class="literal">HibernateTemplate</code>. In general,
      <code class="classname">HibernateTemplate</code>'s convenience methods are
      simpler and more convenient for many scenarios.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7576"></a>12.2.5.&nbsp;Implementing DAOs based on plain Hibernate3 API</h3></div></div></div><p>Hibernate 3.0.1 introduced a feature called "contextual Sessions",
      where Hibernate itself manages one current Session per transaction. This
      is roughly equivalent to Spring's synchronization of one Hibernate
      Session per transaction. A corresponding DAO implementation looks like
      as follows, based on plain Hibernate API:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(String category) {
        return this.sessionFactory.getCurrentSession()
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list();
    }
}</pre><p>This Hibernate access style is very similar to what you will find
      in the Hibernate documentation and examples, except for holding the
      <code class="literal">SessionFactory</code> in an instance variable. We strongly
      recommend such an instance-based setup over the old-school static
      <code class="literal">HibernateUtil</code> class from Hibernate's CaveatEmptor
      sample application! (In general, do not keep any resources in static
      variables unless absolutely necessary!)</p><p>Our DAO above follows the Dependency Injection pattern: It still
      fits nicely into a Spring application context, just like it would if
      coded against Spring's <code class="literal">HibernateTemplate</code>. Concretely,
      it uses Setter Injection; if desired, it could use Constructor Injection
      instead. Of course, such a DAO can also be set up in plain Java (for
      example, in unit tests): simply instantiate it and call
      <code class="literal">setSessionFactory</code> with the desired factory reference.
      As a Spring bean definition, it would look as follows:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on
      Hibernate API only; no import of any Spring class is required. This is
      of course appealing from a non-invasiveness perspective, and might feel
      more natural to Hibernate developers.</p><p>However, the DAO throws plain
      <code class="literal">HibernateException</code> (which is unchecked, so does not
      have to be declared or caught), which means that callers can only treat
      exceptions as generally fatal - unless they want to depend on
      Hibernate's own exception hierarchy. Catching specific causes such as an
      optimistic locking failure is not possible without tying the caller to
      the implementation strategy. This tradeoff might be acceptable to
      applications that are strongly Hibernate-based and/or do not need any
      special exception treatment.</p><p>A further disadvantage of that DAO style is that Hibernate's
      <code class="literal">getCurrentSession()</code> feature just works within JTA
      transactions. It does not work with any other transaction strategy
      out-of-the-box, in particular not with local Hibernate
      transactions.</p><p>Fortunately, Spring's <code class="literal">LocalSessionFactoryBean</code>
      supports Hibernate's
      <code class="literal">SessionFactory.getCurrentSession()</code> method for any
      Spring transaction strategy, returning the current Spring-managed
      transactional <code class="literal">Session</code> even with
      <code class="literal">HibernateTransactionManager</code>. Of course, the standard
      behavior of that method remains: returning the current
      <code class="literal">Session</code> associated with the ongoing JTA transaction,
      if any (no matter whether driven by Spring's
      <code class="literal">JtaTransactionManager</code>, by EJB CMT, or by plain
      JTA).</p><p>In summary: DAOs can be implemented based on plain Hibernate3 API,
      while still being able to participate in Spring-managed transactions.
      This might in particular appeal to people already familar with
      Hibernate, feeling more natural to them. However, such DAOs will throw
      plain <code class="literal">HibernateException</code>; conversion to Spring's
      <code class="literal">DataAccessException</code> would have to happen explicitly
      (if desired).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7641"></a>12.2.6.&nbsp;Programmatic transaction demarcation</h3></div></div></div><p>On top of such lower-level data access services, transactions can
      be demarcated in a higher level of the application, spanning any number
      of operations. There are no restrictions on the implementation of the
      surrounding business service here as well, it just needs a Spring
      <code class="classname">PlatformTransactionManager</code>. Again, the latter can
      come from anywhere, but preferably as bean reference via a
      <code class="methodname">setTransactionManager</code> method - just like the
      <code class="classname">productDAO</code> should be set via a
      <code class="methodname">setProductDao</code> method. The following snippets
      show a transaction manager and a business service definition in a Spring
      application context, and an example for a business method
      implementation.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private PlatformTransactionManager transactionManager;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionManager = transactionManager;
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        TransactionTemplate transactionTemplate = new TransactionTemplate(this.transactionManager);
        transactionTemplate.execute(
            new TransactionCallbackWithoutResult() {
                public void doInTransactionWithoutResult(TransactionStatus status) {
                    List productsToChange = productDAO.loadProductsByCategory(category);
                    ...
                }
            }
        );
    }
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7662"></a>12.2.7.&nbsp;Declarative transaction demarcation</h3></div></div></div><p>Alternatively, one can use Spring's AOP TransactionInterceptor,
      replacing the transaction demarcation code with an interceptor
      configuration in the application context. This allows you to keep
      business services free of repetitive transaction demarcation code in
      each business method. Furthermore, transaction semantics like
      propagation behavior and isolation level can be changed in a
      configuration file and do not affect the business service
      implementations.</p><pre class="programlisting">&lt;beans&gt;
    ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myTxInterceptor"
      class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="transactionAttributeSource"&gt;
      &lt;value&gt;
        product.ProductService.increasePrice*=PROPAGATION_REQUIRED
        product.ProductService.someOtherBusinessMethod=PROPAGATION_MANDATORY
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces"&gt;
      &lt;value&gt;product.ProductService&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
      &lt;list&gt;
        &lt;value&gt;myTxInterceptor&lt;/value&gt;
        &lt;value&gt;myProductServiceTarget&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDAO.loadProductsByCategory(category);
        ...
    }

    ...
}</pre><p>Spring's <code class="classname">TransactionInterceptor</code> allows any
      checked application exception to be thrown with the callback code, while
      <code class="classname">TransactionTemplate</code> is restricted to unchecked
      exceptions within the callback.
      <code class="classname">TransactionTemplate</code> will trigger a rollback in
      case of an unchecked application exception, or if the transaction has
      been marked rollback-only by the application (via
      <code class="classname">TransactionStatus</code>).
      <code class="classname">TransactionInterceptor</code> behaves the same way by
      default but allows configurable rollback policies per method. A
      convenient alternative way of setting up declarative transactions is
      <code class="classname">TransactionProxyFactoryBean</code>, particularly if
      there are no other AOP interceptors involved.
      <code class="classname">TransactionProxyFactoryBean</code> combines the proxy
      definition itself with transaction configuration for a particular target
      bean. This reduces the configuration effort to one target bean plus one
      proxy bean. Furthermore, you do not need to specify which interfaces or
      classes the transactional methods are defined in.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7696"></a>12.2.8.&nbsp;Transaction management strategies</h3></div></div></div><p>Both <code class="classname">TransactionTemplate</code> and
      <code class="classname">TransactionInterceptor</code> delegate the actual
      transaction handling to a
      <code class="classname">PlatformTransactionManager</code> instance, which can be
      a <code class="classname">HibernateTransactionManager</code> (for a single
      Hibernate SessionFactory, using a ThreadLocal Session under the hood) or
      a <code class="classname">JtaTransactionManager</code> (delegating to the JTA
      subsystem of the container) for Hibernate applications. You could even
      use a custom <code class="classname">PlatformTransactionManager</code>
      implementation. So switching from native Hibernate transaction
      management to JTA, i.e. when facing distributed transaction requirements
      for certain deployments of your application, is just a matter of
      configuration. Simply replace the Hibernate transaction manager with
      Spring's JTA transaction implementation. Both transaction demarcation
      and data access code will work without changes, as they just use the
      generic transaction management APIs.</p><p>For distributed transactions across multiple Hibernate session
      factories, simply combine <code class="classname">JtaTransactionManager</code>
      as a transaction strategy with multiple
      <code class="classname">LocalSessionFactoryBean</code> definitions. Each of your
      DAOs then gets one specific SessionFactory reference passed into its
      respective bean property. If all underlying JDBC data sources are
      transactional container ones, a business service can demarcate
      transactions across any number of DAOs and any number of session
      factories without special regard, as long as it is using
      <code class="classname">JtaTransactionManager</code> as the strategy.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource1" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName value="java:comp/env/jdbc/myds1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myDataSource2" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds2"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory1" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource1"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;props&gt;
        &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.MySQLDialect&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory2" class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource2"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;inventory.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;props&gt;
        &lt;prop key="hibernate.dialect"&gt;net.sf.hibernate.dialect.OracleDialect&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="myTxManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory2"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
    &lt;property name="inventoryDao" ref="myInventoryDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Both <code class="classname">HibernateTransactionManager</code> and
      <code class="classname">JtaTransactionManager</code> allow for proper JVM-level
      cache handling with Hibernate - without container-specific transaction
      manager lookup or JCA connector (as long as not using EJB to initiate
      transactions).</p><p><code class="classname">HibernateTransactionManager</code> can export the
      JDBC Connection used by Hibernate to plain JDBC access code, for a
      specific DataSource. This allows for high-level transaction demarcation
      with mixed Hibernate/JDBC data access completely without JTA, as long as
      just accessing one database! HibernateTransactionManager will
      automatically expose the Hibernate transaction as JDBC transaction if
      the passed-in SessionFactory has been set up with a DataSource (through
      LocalSessionFactoryBean's "dataSource" property). Alternatively, the
      DataSource that the transactions are supposed to be exposed for can also
      be specified explicitly, through HibernateTransactionManager's
      "dataSource" property.</p><p>Note, for an alternative approach to using
      <code class="classname">TransactionProxyFactoryBean</code> to declaratively
      demarcate transactions, please see <a href="#beannameautoproxycreator-for-transactions">Section&nbsp;8.5.2, &#8220;BeanNameAutoProxyCreator,
      another declarative approach&#8221;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7751"></a>12.2.9.&nbsp;Container resources versus local resources</h3></div></div></div><p>Spring's resource management allows for simple switching between a
      JNDI SessionFactory and a local one, same for a JNDI DataSource, without
      having to change a single line of application code. Whether to keep the
      resource definitions in the container or locally within the application,
      is mainly a matter of the transaction strategy being used. Compared to a
      Spring-defined local SessionFactory, a manually registered JNDI
      SessionFactory does not provide any benefits. Deploying a SessionFactory
      through Hibernate's JCA connector provides the added value of
      participating in the J2EE server's management infrastructure, but does
      not add actual value beyond that.</p><p>An important benefit of Spring's transaction support is that it
      isn't bound to a container at all. Configured to any other strategy than
      JTA, it will work in a standalone or test environment too. Especially
      for the typical case of single-database transactions, this is a very
      lightweight and powerful alternative to JTA. When using local EJB
      Stateless Session Beans to drive transactions, you depend both on an EJB
      container and JTA - even if you just access a single database anyway,
      and just use SLSBs for declarative transactions via CMT. The alternative
      of using JTA programmatically requires a J2EE environment as well. JTA
      does not just involve container dependencies in terms of JTA itself and
      of JNDI DataSources. For non-Spring JTA-driven Hibernate transactions,
      you have to use the Hibernate JCA connector, or extra Hibernate
      transaction code with the TransactionManagerLookup being configured -
      for proper JVM-level caching.</p><p>Spring-driven transactions can work with a locally defined
      Hibernate SessionFactory nicely, just like with a local JDBC DataSource
      - if accessing a single database, of course. Therefore you just have to
      fall back to Spring's JTA transaction strategy when actually facing
      distributed transaction requirements. Note that a JCA connector needs
      container-specific deployment steps, and obviously JCA support in the
      first place. This is far more hassle than deploying a simple web app
      with local resource definitions and Spring-driven transactions. And you
      often need the Enterprise Edition of your container, as e.g. WebLogic
      Express does not provide JCA. A Spring app with local resources and
      transactions spanning one single database will work in any J2EE web
      container (without JTA, JCA, or EJB) - like Tomcat, Resin, or even plain
      Jetty. Additionally, such a middle tier can be reused in desktop
      applications or test suites easily.</p><p>All things considered: If you do not use EJB, stick with local
      SessionFactory setup and Spring's
      <code class="classname">HibernateTransactionManager</code> or
      <code class="classname">JtaTransactionManager</code>. You will get all benefits
      including proper transactional JVM-level caching and distributed
      transactions, without any container deployment hassle. JNDI registration
      of a Hibernate SessionFactory via the JCA connector only adds value for
      use within EJBs.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-invalid-jdbc-access-error"></a>12.2.10.&nbsp;Spurious AppServer warnings about the transaction or DataSource
      no longer being active</h3></div></div></div><p>In some JTA environments with very strict XADataSource
      implementations -- currently only some WebLogic and WebSphere versions
      -- when using Hibernate configured without any awareness of the JTA
      <code class="literal">TransactionManager</code> object for that environment, it is
      is possible for spurious warning or exceptions to show up in the
      application server log. These warnings or exceptions will say something
      to the effect that the connection being accessed is no longer valid, or
      JDBC access is no longer valid, possibly because the transaction is no
      longer active. As an example, here is an actual exception from
      WebLogic:</p><pre class="programlisting">java.sql.SQLException: The transaction is no longer active - status: 'Committed'.
   No further JDBC access is allowed within this transaction. </pre><p>This warning is easy to resolve by simply making Hibernate
      aware of the JTA <code class="literal">TransactionManager</code> instance, to
      which it will also synchronize (along with Spring). This may be done in
      two ways:</p><div class="itemizedlist"><ul type="disc"><li><p>If in your application context you are already directly
          obtaining the JTA <code class="literal">TransactionManager</code> object
          (presumably from JNDI via <code class="literal">JndiObjectFactoryBean</code>)
          and feeding it for example to Spring's
          <code class="literal">JtaTransactionManager</code>, then the easiest way is to
          simply specify a reference to this as the value of
          <code class="literal">LocalSessionFactoryBean</code>'s
          <span class="emphasis"><em>jtaTransactionManager</em></span> property. Spring will
          then make the object available to Hibernate.</p></li><li><p>More likely you do not already have the JTA
          <code class="literal">TransactionManager</code> instance (since Spring's
          <code class="literal">JtaTransactionManager</code> can find it itself) so you
          need to instead configure Hibernate to also look it up directly.
          This is done by configuring an AppServer specific
          <code class="literal">TransactionManagerLookup</code> class in the Hibernate
          configuration, as described in the Hibernate manual.</p></li></ul></div><p>It is not necessary to read any more for proper usage, bu the full
      sequence of events with and without Hibernate being aware of the JTA
      <code class="literal">TransactionManager</code> will now be described.</p><p>When Hibernate is not configured with any awareness of the JTA
      <code class="literal">TransactionManager</code>, the sequence of events when a JTA
      transaction commits is as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction commits</p></li><li><p>Spring's <code class="literal">JtaTransactionManager</code> is
          synchronized to the JTA transaction, so it is called back via an
          <span class="emphasis"><em>afterCompletion</em></span> callback by the JTA transaction
          manager.</p></li><li><p>Among other activities, this can trigger a callback by Spring
          to Hibernate, via Hibernate's <code class="literal">afterTransactionCompletion</code>
          callback (used to clear the Hibernate cache), followed by an explicit
					<code class="literal">close()</code> call on the Hibernate Session, which
          results in Hibernate trying to <code class="literal">close()</code> the JDBC
          Connection.</p></li><li><p>In some environments, this <code class="literal">Connection.close()</code>
          call then triggers the warning or error, as the application server
          no longer considers the Connection usable at all, since the
          transaction has already been committed.</p></li></ul></div><p>When Hibernate is configured with awareness of the JTA
      <code class="literal">TransactionManager</code>, the sequence of events when a JTA
      transaction commits is instead as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction is ready to commit</p></li><li><p>Spring's <code class="literal">JtaTransactionManager</code> is
          synchronized to the JTA transaction, so it is called back via a
          <span class="emphasis"><em>beforeCompletion</em></span> callback by the JTA
          transaction manager.</p></li><li><p>Spring is aware that Hibernate itself is synchronized to the
          JTA Transaction, and behaves differently than in the previous
          senario. Assuming the Hibernate Session needs to be closed at all,
          Spring will close it now.</p></li><li><p>JTA Transaction commits</p></li><li><p>Hibernate is synchronized to the JTA transaction, so it is
          called back via an <span class="emphasis"><em>afterCompletion</em></span> callback by
          the JTA transaction manager, and can properly clear its
          cache.</p></li></ul></div><p></p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jdo"></a>12.3.&nbsp;JDO</h2></div></div></div><p>Spring supports the standard JDO 1.0/2.0 API as data access
    strategy, following the same style as the Hibernate support. The
    corresponding integration classes reside in the
    <code class="literal">org.springframework.orm.jdo</code> package.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7895"></a>12.3.1.&nbsp;PersistenceManagerFactory setup</h3></div></div></div><p>Spring provides a
      <code class="classname">LocalPersistenceManagerFactoryBean</code> class that
      allows for defining a local JDO PersistenceManagerFactory within a
      Spring application context:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myPmf" class="org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean"&gt;
    &lt;property name="configLocation" value="classpath:kodo.properties"/&gt;
  &lt;/bean&gt;
    
  ...
&lt;/beans&gt;</pre><p>Alternatively, a <code class="literal">PersistenceManagerFactory</code> can
      also be set up through direct instantiation of a
      <code class="literal">PersistenceManagerFactory</code> implementation class. A JDO
      <code class="literal">PersistenceManagerFactory</code> implementation class is
      supposed to follow the JavaBeans pattern, just like a JDBC
      <code class="literal">DataSource</code> implementation class, which is a natural
      fit for a Spring bean definition. This setup style usually supports a
      Spring-defined JDBC <code class="literal">DataSource</code>, passed into the
      "connectionFactory" property. For example, for the open source JDO
      implementation JPOX (<a href="http://www.jpox.org" target="_top">http://www.jpox.org</a>):</p><pre class="programlisting">&lt;beans&gt;

 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
   &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
   &lt;property name="url" value="${jdbc.url}"/&gt;
   &lt;property name="username" value="${jdbc.username}"/&gt;
   &lt;property name="password" value="${jdbc.password}"/&gt;
 &lt;/bean&gt;

 &lt;bean id="myPmf" class="org.jpox.PersistenceManagerFactoryImpl" destroy-method="close"&gt;
   &lt;property name="connectionFactory" ref="dataSource"/&gt;
   &lt;property name="nontransactionalRead" value="true"/&gt;
 &lt;/bean&gt;
   
 ...
&lt;/beans&gt;</pre><p>A JDO <code class="literal">PersistenceManagerFactory</code> can also be set
      up in the JNDI environment of a J2EE application server, usually through
      the JCA connector provided by the particular JDO implementation.
      Spring's standard <code class="literal">JndiObjectFactoryBean</code> can be used
      to retrieve and expose such a
      <code class="literal">PersistenceManagerFactory</code>. However, outside an EJB
      context, there is often no compelling benefit in holding the
      <code class="literal">PersistenceManagerFactory</code> in JNDI: only choose such
      setup for a good reason. See "container resources versus local
      resources" in the Hibernate section for a discussion; the arguments
      there apply to JDO as well.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e7942"></a>12.3.2.&nbsp;JdoTemplate and JdoDaoSupport</h3></div></div></div><p>Each JDO-based DAO will then receive the
      <code class="literal">PersistenceManagerFactory</code> through dependency
      injection, i.e. through a bean property setter or through a constructor
      argument. Such a DAO could be coded against plain JDO API, working with
      the given <code class="literal">PersistenceManagerFactory</code>, but will usually
      rather be used with Spring's <code class="literal">JdoTemplate</code>:</p><pre class="programlisting">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        JdoTemplate jdoTemplate = new JdoTemplate(this.persistenceManagerFactory);
        return (Collection) jdoTemplate.execute(new JdoCallback() {
            public Object doInJdo(PersistenceManager pm) throws JDOException {
                Query query = pm.newQuery(Product.class, "category = pCategory");
                query.declareParameters("String pCategory"); 
                List result = query.execute(category);
                // do some further stuff with the result list
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any JDO data
      access. <code class="classname">JdoTemplate</code> will ensure that
      <code class="classname">PersistenceManager</code>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single-step
      actions such as a single <code class="literal">find</code>,
      <code class="literal">load</code>, <code class="literal">makePersistent</code>, or
      <code class="literal">delete</code> call, <code class="classname">JdoTemplate</code>
      offers alternative convenience methods that can replace such one line
      callback implementations. Furthermore, Spring provides a convenient
      <code class="classname">JdoDaoSupport</code> base class that provides a
      <code class="literal">setPersistenceManagerFactory</code> method for receiving a
      <code class="classname">PersistenceManagerFactory</code>, and
      <code class="literal">getPersistenceManagerFactory</code> and
      <code class="literal">getJdoTemplate</code> for use by subclasses. In combination,
      this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends JdoDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return getJdoTemplate().find(
            Product.class, "category = pCategory", "String category", new Object[] {category});
    }
}</pre><p>As alternative to working with Spring's
      <code class="literal">JdoTemplate</code>, you can also code Spring-based DAOs at
      the JDO API level, explictly opening and closing a
      <code class="literal">PersistenceManager</code>. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <code class="literal">JdoDaoSupport</code> offers a variety of support methods for
      this scenario, for fetching and releasing a transactional
      <code class="literal">PersistenceManager</code> as well as for converting
      exceptions.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8015"></a>12.3.3.&nbsp;Implementing DAOs based on plain JDO API</h3></div></div></div><p>DAOs can also be written against plain JDO API, without any Spring
      dependencies, directly using an injected
      <code class="literal">PersistenceManagerFactory</code>. A corresponding DAO
      implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        try {
            Query query = pm.newQuery(Product.class, "category = pCategory");
            query.declareParameters("String pCategory"); 
            return query.execute(category);
        }
        finally {
          pm.close();
        }
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring application context, just like it
      would if coded against Spring's <code class="literal">JdoTemplate</code>:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main issue with such DAOs is that they always get a new
      <code class="literal">PersistenceManager</code> from the factory. To still access
      a Spring-managed transactional <code class="literal">PersistenceManager</code>,
      consider defining a
      <code class="literal">TransactionAwarePersistenceManagerFactoryProxy</code> (as
      included in Spring) in front of your target
      <code class="literal">PersistenceManagerFactory</code>, passing the proxy into
      your DAOs.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>Your data access code will then receive a transactional
      <code class="literal">PersistenceManager</code> (if any) from the
      <code class="literal">PersistenceManagerFactory.getPersistenceManager()</code>
      method that it calls. The latter method call goes through the proxy,
      which will first check for a current transactional
      <code class="literal">PersistenceManager</code> before getting a new one from the
      factory. <code class="literal">close</code> calls on the
      <code class="literal">PersistenceManager</code> will be ignored in case of a
      transaction <code class="literal">PersistenceManager</code>.</p><p>If your data access code will always run within an active
      transaction (or at least within active transaction synchronization), it
      is safe to omit the <code class="literal">PersistenceManager.close()</code> call
      and thus the entire <code class="literal">finally</code> block, which you might
      prefer to keep your DAO implementations concise:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        Query query = pm.newQuery(Product.class, "category = pCategory");
        query.declareParameters("String pCategory"); 
        return query.execute(category);
    }
}</pre><p>With such DAOs that rely on active transactions, it is recommended
      to enforce active transactions through turning
      <code class="literal">TransactionAwarePersistenceManagerFactoryProxy</code>'s
      "allowCreate" flag off:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
    &lt;property name="allowCreate" value="false"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on JDO API
      only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to JDO developers.</p><p>However, the DAO throws plain <code class="literal">JDOException</code>
      (which is unchecked, so does not have to be declared or caught), which
      means that callers can only treat exceptions as generally fatal - unless
      they want to depend on JDO's own exception structure. Catching specific
      causes such as an optimistic locking failure is not possible without
      tying the caller to the implementation strategy. This tradeoff might be
      acceptable to applications that are strongly JDO-based and/or do not
      need any special exception treatment.</p><p>In summary: DAOs can be implemented based on plain JDO API, while
      still being able to participate in Spring-managed transactions. This
      might in particular appeal to people already familar with JDO, feeling
      more natural to them. However, such DAOs will throw plain
      <code class="literal">JDOException</code>; conversion to Spring's
      <code class="literal">DataAccessException</code> would have to happen explicitly
      (if desired).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8100"></a>12.3.4.&nbsp;Transaction management</h3></div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example, you
      could define a <code class="literal">TransactionProxyFactoryBean</code> for a
      ProductService, which in turn delegates to the JDO-based ProductDao.
      Each specified method would then automatically get executed within a
      transaction, with all affected DAO operations automatically
      participating in it.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.jdo.JdoTransactionManager"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that JDO requires an active transaction when modifying a
      persistent object. There is no concept like a non-transactional flush in
      JDO, in contrast to Hibernate. For this reason, the chosen JDO
      implementation needs to be set up for a specific environment: in
      particular, it needs to be explicitly set up for JTA synchronization, to
      detect an active JTA transaction itself. This is not necessary for local
      transactions as performed by Spring's
      <code class="literal">JdoTransactionManager</code>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <code class="literal">JtaTransactionManager</code> or by EJB CMT / plain
      JTA).</p><p><code class="literal">JdoTransactionManager</code> is capable of exposing a
      JDO transaction to JDBC access code that accesses the same JDBC
      <code class="literal">DataSource</code>, provided that the registered
      <code class="literal">JdoDialect</code> supports retrieval of the underlying JDBC
      <code class="literal">Connection</code>. This is by default the case for
      JDBC-based JDO 2.0 implementations; for JDO 1.0 implementations, a
      custom <code class="literal">JdoDialect</code> needs to be used. See next section
      for details on the <code class="literal">JdoDialect</code> mechanism.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8138"></a>12.3.5.&nbsp;JdoDialect</h3></div></div></div><p>As an advanced feature, both <code class="literal">JdoTemplate</code> and
      <code class="literal">JdoTransactionManager</code> support a custom
      <code class="literal">JdoDialect</code>, to be passed into the "jdoDialect" bean
      property. In such a scenario, the DAOs won't receive a
      <code class="literal">PersistenceManagerFactory</code> reference but rather a full
      <code class="literal">JdoTemplate</code> instance instead (for example, passed
      into <code class="literal">JdoDaoSupport</code>'s "jdoTemplate" property). A
      <code class="literal">JdoDialect</code> implementation can enable some advanced
      features supported by Spring, usually in a vendor-specific
      manner:</p><div class="itemizedlist"><ul type="disc"><li><p>applying specific transaction semantics (such as custom
          isolation level or transaction timeout)</p></li><li><p>retrieving the transactional JDBC
          <code class="literal">Connection</code> (for exposure to JDBC-based
          DAOs)</p></li><li><p>applying query timeouts (automatically calculated from
          Spring-managed transaction timeout)</p></li><li><p>eagerly flushing a <code class="literal">PersistenceManager</code> (to
          make transactional changes visible to JDBC-based data access
          code)</p></li><li><p>advanced translation of <code class="literal">JDOExceptions</code> to
          Spring <code class="literal">DataAccessExceptions</code></p></li></ul></div><p>This is particularly valuable for JDO 1.0 implementations, where
      none of those features are covered by the standard API. On JDO 2.0, most
      of those features are supported in a standard manner: Hence, Spring's
      <code class="literal">DefaultJdoDialect</code> uses the corresponding JDO 2.0 API
      methods by default (as of Spring 1.2). For special transaction semantics
      and for advanced translation of exception, it is still valuable to
      derive vendor-specific <code class="literal">JdoDialect</code> subclasses.</p><p>See the <code class="literal">JdoDialect</code> javadoc for more details on
      its operations and how they are used within Spring's JDO support.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-toplink"></a>12.4.&nbsp;Oracle TopLink</h2></div></div></div><p>Since Spring 1.2, Spring supports Oracle TopLink (<a href="http://www.oracle.com/technology/products/ias/toplink" target="_top">http://www.oracle.com/technology/products/ias/toplink</a>) as
    data access strategy, following the same style as the Hibernate support.
    Both TopLink 9.0.4 (the production version as of Spring 1.2) and 10.1.3
    (still in beta as of Spring 1.2) are supported. The corresponding
    integration classes reside in the
    <code class="literal">org.springframework.orm.toplink</code> package.</p><p>Spring's TopLink support has been co-developed with the Oracle
    TopLink team. Many thanks to the TopLink team, in particular to Jim Clark
    who helped to clarify details in all areas!</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8216"></a>12.4.1.&nbsp;SessionFactory abstraction</h3></div></div></div><p>TopLink itself does not ship with a SessionFactory abstraction.
      Instead, multi-threaded access is based on the concept of a central
      <code class="literal">ServerSession</code>, which in turn is able to spawn
      <code class="literal">ClientSession</code>s for single-threaded usage. For
      flexible setup options, Spring defines a
      <code class="literal">SessionFactory</code> abstraction for TopLink, enabling to
      switch between different <code class="literal">Session</code> creation
      strategies.</p><p>As a one-stop shop, Spring provides a
      <code class="classname">LocalSessionFactoryBean</code> class that allows for
      defining a TopLink <code class="literal">SessionFactory</code> with bean-style
      configuration. It needs to be configured with the location of the
      TopLink session configuration file, and usually also receives a
      Spring-managed JDBC <code class="literal">DataSource</code> to use.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.toplink.LocalSessionFactoryBean"&gt;
    &lt;property name="configLocation" value="toplink-sessions.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
    
  ...
&lt;/beans&gt;</pre><pre class="programlisting">&lt;toplink-configuration&gt;

  &lt;session&gt;
    &lt;name&gt;Session&lt;/name&gt;
    &lt;project-xml&gt;toplink-mappings.xml&lt;/project-xml&gt;
    &lt;session-type&gt;
      &lt;server-session/&gt;
    &lt;/session-type&gt;
    &lt;enable-logging&gt;true&lt;/enable-logging&gt;
    &lt;logging-options/&gt;
  &lt;/session&gt;

&lt;/toplink-configuration&gt;</pre><p>Usually,
      <code class="literal">LocalSessionFactoryBean</code> will hold a multi-threaded
      TopLink <code class="literal">ServerSession</code> underneath and create
      appropriate client <code class="literal">Session</code>s for it: either a plain
      <code class="literal">Session</code> (typical), a managed
      <code class="literal">ClientSession</code>, or a transaction-aware
      <code class="literal">Session</code> (the latter are mainly used internally by
      Spring's TopLink support). It might also hold a single-threaded TopLink
      <code class="literal">DatabaseSession</code>; this is rather unusual,
      though.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8272"></a>12.4.2.&nbsp;TopLinkTemplate and TopLinkDaoSupport</h3></div></div></div><p>Each TopLink-based DAO will then receive the
      <code class="literal">SessionFactory</code> through dependency injection, i.e.
      through a bean property setter or through a constructor argument. Such a
      DAO could be coded against plain TopLink API, fetching a
      <code class="literal">Session</code> from the given
      <code class="literal">SessionFactory</code>, but will usually rather be used with
      Spring's <code class="literal">TopLinkTemplate</code>:</p><pre class="programlisting">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        TopLinkTemplate tlTemplate = new TopLinkTemplate(this.sessionFactory);
        return (Collection) tlTemplate.execute(new TopLinkCallback() {
            public Object doInTopLink(Session session) throws TopLinkException {
                ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
                findOwnersQuery.addArgument("Category");
                ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
                findOwnersQuery.setSelectionCriteria(
                    builder.get("category").like(builder.getParameter("Category")));

                Vector args = new Vector();
                args.add(category);
                List result = session.executeQuery(findOwnersQuery, args);
                // do some further stuff with the result list
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any TopLink
      data access. <code class="classname">TopLinkTemplate</code> will ensure that
      <code class="classname">Session</code>s are properly opened and closed, and
      automatically participate in transactions. The template instances are
      thread-safe and reusable, they can thus be kept as instance variables of
      the surrounding class. For simple single-step actions such as a single
      <code class="literal">executeQuery</code>, <code class="literal">readAll</code>,
      <code class="literal">readById</code>, or <code class="literal">merge</code> call,
      <code class="classname">JdoTemplate</code> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <code class="classname">TopLinkDaoSupport</code> base class that provides a
      <code class="literal">setSessionFactory</code> method for receiving a
      <code class="classname">SessionFactory</code>, and
      <code class="literal">getSessionFactory</code> and
      <code class="literal">getTopLinkTemplate</code> for use by subclasses. In
      combination, this allows for simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends TopLinkDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        return getTopLinkTemplate().executeQuery(findOwnersQuery, new Object[] {category});
    }
}</pre><p>Side note: TopLink query objects are thread-safe and can be cached
      within the DAO, i.e. created on startup and kept in instance
      variables.</p><p>As alternative to working with Spring's
      <code class="literal">TopLinkTemplate</code>, you can also code your TopLink data
      access based on the raw TopLink API, explictly opening and closing a
      <code class="literal">Session</code>. As elaborated in the corresponding Hibernate
      section, the main advantage of this approach is that your data access
      code is able to throw checked exceptions.
      <code class="literal">TopLinkDaoSupport</code> offers a variety of support methods
      for this scenario, for fetching and releasing a transactional
      <code class="literal">Session</code> as well as for converting exceptions.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8350"></a>12.4.3.&nbsp;Implementing DAOs based on plain TopLink API</h3></div></div></div><p>DAOs can also be written against plain TopLink API, without any
      Spring dependencies, directly using an injected TopLink
      <code class="literal">Session</code>. The latter will usually be based on a
      <code class="literal">SessionFactory</code> defined by a
      <code class="literal">LocalSessionFactoryBean</code>, exposed for bean references
      of type <code class="literal">Session</code> through Spring's
      <code class="literal">TransactionAwareSessionAdapter</code>.</p><p>The <code class="literal">getActiveSession()</code> method defined on
      TopLink's <code class="literal">Session</code> interface will return the current
      transactional <code class="literal">Session</code> in such a scenario. If there is
      no active transaction, it will return the shared TopLink
      <code class="literal">ServerSession</code> as-is, which is only supposed to be
      used directly for read-only access. There is also an analogous
      <code class="literal">getActiveUnitOfWork()</code> method, returning the TopLink
      <code class="literal">UnitOfWork</code> associated with the current transaction,
      if any (returning null else).</p><p>A corresponding DAO implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private Session session;

    public void setSession(Session session) {
        this.session = session;
    }

    public Collection loadProductsByCategory(String category) {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        Vector args = new Vector();
        args.add(category);
        return session.getActiveSession().executeQuery(findOwnersQuery, args);
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring application context, analogous to
      like it would if coded against Spring's
      <code class="literal">TopLinkTemplate</code>. Spring's
      <code class="literal">TransactionAwareSessionAdapter</code> is used to expose a
      bean reference of type <code class="literal">Session</code>, to be passed into the
      DAO:</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="mySessionAdapter"
      class="org.springframework.orm.toplink.support.TransactionAwareSessionAdapter"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="session" ref="mySessionAdapter"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on TopLink
      API only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to TopLink developers.</p><p>However, the DAO throws plain <code class="literal">TopLinkException</code>
      (which is unchecked, so does not have to be declared or caught), which
      means that callers can only treat exceptions as generally fatal - unless
      they want to depend on TopLink's own exception structure. Catching
      specific causes such as an optimistic locking failure is not possible
      without tying the caller to the implementation strategy. This tradeoff
      might be acceptable to applications that are strongly TopLink-based
      and/or do not need any special exception treatment.</p><p>A further disadvantage of that DAO style is that TopLink's
      standard <code class="literal">getActiveSession()</code> feature just works within
      JTA transactions. It does not work with any other transaction strategy
      out-of-the-box, in particular not with local TopLink
      transactions.</p><p>Fortunately, Spring's
      <code class="literal">TransactionAwareSessionAdapter</code> exposes a
      corresponding proxy for the TopLink <code class="literal">ServerSession</code>
      which supports TopLink's <code class="literal">Session.getActiveSession()</code>
      and <code class="literal">Session.getActiveUnitOfWork()</code> methods for any
      Spring transaction strategy, returning the current Spring-managed
      transactional <code class="literal">Session</code> even with
      <code class="literal">TopLinkTransactionManager</code>. Of course, the standard
      behavior of that method remains: returning the current
      <code class="literal">Session</code> associated with the ongoing JTA transaction,
      if any (no matter whether driven by Spring's
      <code class="literal">JtaTransactionManager</code>, by EJB CMT, or by plain
      JTA).</p><p>In summary: DAOs can be implemented based on plain TopLink API,
      while still being able to participate in Spring-managed transactions.
      This might in particular appeal to people already familar with TopLink,
      feeling more natural to them. However, such DAOs will throw plain
      <code class="literal">TopLinkException</code>; conversion to Spring's
      <code class="literal">DataAccessException</code> would have to happen explicitly
      (if desired).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8453"></a>12.4.4.&nbsp;Transaction management</h3></div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example, you
      could define a <code class="literal">TransactionProxyFactoryBean</code> for a
      ProductService, which in turn delegates to the TopLink-based ProductDao.
      Each specified method would then automatically get executed within a
      transaction, with all affected DAO operations automatically
      participating in it.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.toplink.TopLinkTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that TopLink requires an active <code class="literal">UnitOfWork</code>
      for modifying a persistent object. (You should never modify objects
      returned by a plain TopLink <code class="literal">Session</code> - those are
      usually read-only objects, directly taken from the second-level cache!)
      There is no concept like a non-transactional flush in TopLink, in
      contrast to Hibernate. For this reason, TopLink needs to be set up for a
      specific environment: in particular, it needs to be explicitly set up
      for JTA synchronization, to detect an active JTA transaction itself and
      expose a corresponding active <code class="literal">Session</code> and
      <code class="literal">UnitOfWork</code>. This is not necessary for local
      transactions as performed by Spring's
      <code class="literal">TopLinkTransactionManager</code>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <code class="literal">JtaTransactionManager</code> or by EJB CMT / plain
      JTA).</p><p>Within your TopLink-based DAO code, use the
      <code class="literal">Session.getActiveUnitOfWork()</code> method to access the
      current <code class="literal">UnitOfWork</code> and perform write operations
      through it. This will only work within an active transaction (both
      within Spring-managed transactions and plain JTA transactions). For
      special needs, you can also acquire separate
      <code class="literal">UnitOfWork</code> instances that won't participate in the
      current transaction; this is hardly needed, though.</p><p><code class="literal">TopLinkTransactionManager</code> is capable of
      exposing a TopLink transaction to JDBC access code that accesses the
      same JDBC <code class="literal">DataSource</code>, provided that TopLink works
      with JDBC in the backend and is thus able to expose the underlying JDBC
      <code class="literal">Connection</code>. The <code class="literal">DataSource</code> to
      expose the transactions for needs to be specified explicitly; it won't
      be autodetected.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-ojb"></a>12.5.&nbsp;Apache OJB</h2></div></div></div><p>Apache OJB (<a href="http://db.apache.org/ojb" target="_top">http://db.apache.org/ojb</a>) offers
    multiple API levels, such as ODMG and JDO. Aside from supporting OJB
    through JDO, Spring also supports OJB's lowe-level PersistenceBroker API
    as data access strategy. The corresponding integration classes reside in
    the <code class="literal">org.springframework.orm.ojb</code> package.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8518"></a>12.5.1.&nbsp;OJB setup in a Spring environment</h3></div></div></div><p>In contrast to Hibernate or JDO, OJB does not follow a factory
      object pattern for its resources. Instead, an OJB PersistenceBroker has
      to be obtained from the static PersistenceBrokerFactory class. That
      factory initializes itself from an OJB.properties file, residing in the
      root of the class path.</p><p>In addition to supporting OJB's default initialization style,
      Spring also provides a <code class="classname">Local</code>OjbConfigurer class
      that allows for using Spring-managed <code class="literal">DataSource</code>
      instances as OJB connection providers. The <code class="literal">DataSource</code>
      instances are referenced in the OJB repository descriptor (the mapping
      file), through the "jcd-alias" defined there: each such alias is matched
      against the Spring-managed bean of the same name.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="ojbConfigurer" class="org.springframework.orm.ojb.support.LocalOjbConfigurer"/&gt;
   
  ...
&lt;/beans&gt;</pre><pre class="programlisting">&lt;descriptor-repository version="1.0"&gt;

  &lt;jdbc-connection-descriptor jcd-alias="dataSource" default-connection="true" ...&gt;
        ...
  &lt;/jdbc-connection-descriptor&gt;

  ...
&lt;/descriptor-repository&gt;</pre><p>A PersistenceBroker can then be opened through standard OJB API,
      specifying a corresponding "PBKey", usually through the corresponding
      "jcd-alias" (or relying on the default connection).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8542"></a>12.5.2.&nbsp;PersistenceBrokerTemplate and PersistenceBrokerDaoSupport</h3></div></div></div><p>Each OJB-based DAO will be configured with a "PBKey" through
      bean-style configuration, i.e. through a bean property setter. Such a
      DAO could be coded against plain OJB API, working with OJB's static
      <code class="literal">PersistenceBrokerFactory</code>, but will usually rather be
      used with Spring's <code class="literal">PersistenceBrokerTemplate</code>:</p><pre class="programlisting">&lt;beans&gt;
  ...
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="jcdAlias" value="dataSource"/&gt;  &lt;!-- can be omitted (default) --&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private String jcdAlias;

    public void setJcdAlias(String jcdAlias) {
        this.jcdAlias = jcdAlias;
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        PersistenceBrokerTemplate pbTemplate =
                new PersistenceBrokerTemplate(new PBKey(this.jcdAlias);
        return (Collection) pbTemplate.execute(new PersistenceBrokerCallback() {
            public Object doInPersistenceBroker(PersistenceBroker pb)
                    throws PersistenceBrokerException {

                Criteria criteria = new Criteria();
                criteria.addLike("category", category + "%");
                Query query = new QueryByCriteria(Product.class, criteria);

                List result = pb.getCollectionByQuery(query);
                // do some further stuff with the result list
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any OJB data
      access. <code class="classname">PersistenceBrokerTemplate</code> will ensure
      that <code class="classname">PersistenceBroker</code>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single-step
      actions such as a single <code class="literal">getObjectById</code>,
      <code class="literal">getObjectByQuery</code>, <code class="literal">store</code>, or
      <code class="literal">delete</code> call,
      <code class="classname">PersistenceBrokerTemplate</code> offers alternative
      convenience methods that can replace such one line callback
      implementations. Furthermore, Spring provides a convenient
      <code class="classname">PersistenceBrokerDaoSupport</code> base class that
      provides a <code class="literal">setJcdAlias</code> method for receiving an OJB
      JCD alias, and <code class="literal">getPersistenceBrokerTemplate</code> for use
      by subclasses. In combination, this allows for very simple DAO
      implementations for typical requirements:</p><pre class="programlisting">public class ProductDaoImpl extends PersistenceBrokerDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        Criteria criteria = new Criteria();
        criteria.addLike("category", category + "%");
        Query query = new QueryByCriteria(Product.class, criteria);

        return getPersistenceBrokerTemplate().getCollectionByQuery(query);
    }
}</pre><p>As alternative to working with Spring's
      <code class="literal">PersistenceBrokerTemplate</code>, you can also code your OJB
      data access against plain OJB API, explictly opening and closing a
      <code class="literal">PersistenceBroker</code>. As elaborated in the corresponding
      Hibernate section, the main advantage of this approach is that your data
      access code is able to throw checked exceptions.
      <code class="literal">PersistenceBrokerDaoSupport</code> offers a variety of
      support methods for this scenario, for fetching and releasing a
      transactional <code class="literal">PersistenceBroker</code> as well as for
      converting exceptions.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8606"></a>12.5.3.&nbsp;Transaction management</h3></div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example, you
      could define a <code class="literal">TransactionProxyFactoryBean</code> for a
      ProductService, which in turn delegates to the OJB-based ProductDao.
      Each specified method would then automatically get executed within a
      transaction, with all affected DAO operations automatically
      participating in it.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="myTxManager" class="org.springframework.orm.ojb.PersistenceBrokerTransactionManager"&gt;
    &lt;property name="jcdAlias" value="dataSource"/&gt;  &lt;!-- can be omitted (default) --&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductServiceTarget" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target" ref="myProductServiceTarget"/&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that OJB's PersistenceBroker level does not track changes of
      loaded objects. Therefore, a PersistenceBroker transaction is
      essentially simply a database transaction at the PersistenceBroker
      level, just with an additional first-level cache for persistent objects.
      Lazy loading will work both with and without the PersistenceBroker being
      open, in contrast to Hibernate and JDO (where the original Session or
      PersistenceManager, respectively, needs to remain open).</p><p><code class="literal">PersistenceBrokerTransactionManager</code> is capable
      of exposing an OJB transaction to JDBC access code that accesses the
      same JDBC <code class="literal">DataSource</code>. The
      <code class="literal">DataSource</code> to expose the transactions for needs to be
      specified explicitly; it won't be autodetected.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-ibatis"></a>12.6.&nbsp;iBATIS SQL Maps</h2></div></div></div><p>Through the <code class="literal">org.springframework.orm.ibatis</code>
    package, Spring supports iBATIS SQL Maps 1.x and 2.x (<a href="http://www.ibatis.com" target="_top">http://www.ibatis.com</a>). The iBATIS support much resembles
    the JDBC / Hibernate support in that it supports the same template style
    programming and just as with JDBC or Hibernate, the iBATIS support works
    with Spring's exception hierarchy and let's you enjoy the all IoC features
    Spring has.</p><p>Transaction management can be handled through Spring's standard
    facilities, for example through
    <code class="literal">TransactionProxyFactoryBean</code>. There are no special
    transaction strategies for iBATIS, as there is no special transactional
    resource involved other than a JDBC <code class="literal">Connection</code>. Hence,
    Spring's standard JDBC <code class="literal">DataSourceTransactionManager</code> or
    <code class="literal">JtaTransactionManager</code> are perfectly sufficient.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8653"></a>12.6.1.&nbsp;Overview and differences between iBATIS 1.x and 2.x</h3></div></div></div><p>Spring supports both iBATIS SQL Maps 1.x and 2.x. First let's have
      a look at the differences between the two.</p><p>The XML config files have changed a bit, node and attribute names.
      Also the Spring classes you need to extend are different, as are some
      method names.</p><div class="table"><a name="d0e8660"></a><p class="title"><b>Table&nbsp;12.1.&nbsp;iBATIS SQL Maps supporting classes for 1.x and 2.x</b></p><div class="table-contents"><table summary="iBATIS SQL Maps supporting classes for 1.x and 2.x" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Feature</th><th>1.x</th><th>2.x</th></tr></thead><tbody><tr><td>Creation of SqlMap(Client)</td><td><code class="literal">SqlMapFactoryBean</code></td><td><code class="literal">SqlMapClientFactoryBean</code></td></tr><tr><td>Template-style helper class</td><td><code class="literal">SqlMapTemplate</code></td><td><code class="literal">SqlMapClientTemplate</code></td></tr><tr><td>Callback to use MappedStatement</td><td><code class="literal">SqlMapCallback</code></td><td><code class="literal">SqlMapClientCallback</code></td></tr><tr><td>Super class for DAOs</td><td><code class="literal">SqlMapDaoSupport</code></td><td><code class="literal">SqlMapClientDaoSupport</code></td></tr></tbody></table></div></div><p><br class="table-break"></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8712"></a>12.6.2.&nbsp;iBATIS SQL Maps 1.x</h3></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8715"></a>12.6.2.1.&nbsp;Setting up the SqlMap</h4></div></div></div><p>Using iBATIS SQL Maps involves creating SqlMap configuration
        files containing statements and result maps. Spring takes care of
        loading those using the <code class="literal">SqlMapFactoryBean</code>.</p><pre class="programlisting">public class Account {

    private String name;
    private String email;
    
    public String getName() {
        return this.name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getEmail() {
        return this.email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
}</pre><p>Suppose we would want to map this class. We'd have to create
        the following <code class="literal">SqlMap</code>. Using the query, we can later
        on retrieve users through their email addresses.
        <code class="literal">Account.xml</code>:</p><pre class="programlisting">&lt;sql-map name="Account"&gt;

  &lt;result-map name="result" class="examples.Account"&gt;
    &lt;property name="name" column="NAME" columnIndex="1"/&gt;
    &lt;property name="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/result-map&gt;
    
  &lt;mapped-statement name="getAccountByEmail" result-map="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/mapped-statement&gt;
    
  &lt;mapped-statement name="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/mapped-statement&gt;

&lt;/sql-map&gt;</pre><p> After having defined the Sql Map, we have to
        create a configuration file for iBATIS
        (<code class="literal">sqlmap-config.xml</code>): </p><pre class="programlisting">&lt;sql-map-config&gt;

  &lt;sql-map resource="example/Account.xml"/&gt;

&lt;/sql-map-config&gt;</pre><p> iBATIS loads resources from the class
        path, so be sure to add the <code class="literal">Account.xml</code> file to the
        class path.</p><p>Using Spring, we can now very easily set up the
        <code class="literal">SqlMap</code>, using the
        <code class="literal">SqlMapFactoryBean</code>: </p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMap" class="org.springframework.orm.ibatis.SqlMapFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8755"></a>12.6.2.2.&nbsp;Using <code class="literal">SqlMapTemplate</code> and
        <code class="literal">SqlMapDaoSupport</code></h4></div></div></div><p>The <code class="literal">SqlMapDaoSupport</code> class offers a
        supporting class similar to the <code class="literal">HibernateDaoSupport</code>
        and the <code class="literal">JdoDaoSupport</code> classes. Let's implement a
        DAO: </p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapTemplate().executeQueryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapTemplate().executeUpdate("insertAccount", account);
    }
}</pre><p> As you can see, we're using the pre-configured
        <code class="literal">SqlMapTemplate</code> to execute the query. Spring has
        initialized the <code class="literal">SqlMap</code> for us using the
        <code class="literal">SqlMapFactoryBean</code>, and when setting up the
        <code class="literal">SqlMapAccountDao</code> as follows, you're all set to go.
        Note that with iBATIS SQL Maps 1.x, the JDBC
        <code class="literal">DataSource</code> is usually specified on the
        DAO.</p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;property name="sqlMap" ref="sqlMap"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that a <code class="literal">SqlMapTemplate</code> instance could
        also be created manually, passing in the <code class="literal">DataSource</code>
        and the <code class="literal">SqlMap</code> as constructor arguments. The
        <code class="literal">SqlMapDaoSupport</code> base class simply pre-initializes
        a <code class="literal">SqlMapTemplate</code> instance for us.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e8811"></a>12.6.3.&nbsp;iBATIS SQL Maps 2.x</h3></div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8814"></a>12.6.3.1.&nbsp;Setting up the SqlMapClient</h4></div></div></div><p>If we want to map the previous Account class with iBATIS 2.x we
        need to create the following SQL map <code class="literal">Account.xml</code>:
        </p><pre class="programlisting">&lt;sqlMap namespace="Account"&gt;

  &lt;resultMap id="result" class="examples.Account"&gt;
    &lt;result property="name" column="NAME" columnIndex="1"/&gt;
    &lt;result property="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/resultMap&gt;

  &lt;select id="getAccountByEmail" resultMap="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/select&gt;

  &lt;insert id="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/insert&gt;

&lt;/sqlMap&gt;</pre><p>The configuration file for iBATIS 2 changes a
        bit (<code class="literal">sqlmap-config.xml</code>): </p><pre class="programlisting">&lt;sqlMapConfig&gt;

  &lt;sqlMap resource="example/Account.xml"/&gt;

&lt;/sqlMapConfig&gt;</pre><p>Remember that iBATIS loads resources
        from the class path, so be sure to add the
        <code class="literal">Account.xml</code> file to the class path.</p><p>We can use the <code class="literal">SqlMapClientFactoryBean</code> in the
        Spring application context. Note that with iBATIS SQL Maps 2.x, the
        JDBC <code class="literal">DataSource</code> is usually specified on the
        <code class="literal">SqlMapClientFactoryBean</code>, which enables lazy
        loading.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMapClient" class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;

  ...
&lt;/beans&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8847"></a>12.6.3.2.&nbsp;Using <code class="literal">SqlMapClientTemplate</code> and
        <code class="literal">SqlMapClientDaoSupport</code></h4></div></div></div><p>The <code class="literal">SqlMapClientDaoSupport</code> class offers a
        supporting class similar to the <code class="literal">SqlMapDaoSupport</code>.
        We extend it to implement our DAO: </p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapClientTemplate().queryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().update("insertAccount", account);
    }
}</pre><p>In the DAO, we use the pre-configured
        <code class="literal">SqlMapClientTemplate</code> to execute the queries, after
        setting up the <code class="literal">SqlMapAccountDao</code> in the application
        context and wiring it with our <code class="literal">SqlMapClient</code>
        instance: </p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that a <code class="literal">SqlMapTemplate</code> instance could
        also be created manually, passing in the
        <code class="literal">SqlMapClient</code> as constructor argument. The
        <code class="literal">SqlMapClientDaoSupport</code> base class simply
        pre-initializes a <code class="literal">SqlMapClientTemplate</code> instance for
        us.</p><p>The <code class="literal">SqlMapClientTemplate</code> also offers a
        generic <code class="literal">execute</code> method, taking a custom
        <code class="literal">SqlMapClientCallback</code> implementation as argument.
        This can, for example, be used for batching: </p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {
    ...

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().execute(new SqlMapClientCallback() {
            public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
                executor.startBatch();
                executor.update("insertAccount", account);
                executor.update("insertAddress", account.getAddress());
                executor.executeBatch();
            }
        });
    }
}</pre><p>In general, any combination of operations offered by the
        native <code class="literal">SqlMapExecutor</code> API can be used in such a
        callback. Any <code class="literal">SQLException</code> thrown will
        automatically get converted to Spring's generic
        <code class="literal">DataAccessException</code> hierarchy.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e8914"></a>12.6.3.3.&nbsp;Implementing DAOs based on plain iBATIS API</h4></div></div></div><p>DAOs can also be written against plain iBATIS API, without any
        Spring dependencies, directly using an injected
        <code class="literal">SqlMapClient</code>. A corresponding DAO implementation
        looks like as follows:</p><pre class="programlisting">public class SqlMapAccountDao implements AccountDao {
        
    private SqlMapClient sqlMapClient;
    
    public void setSqlMapClient(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }

    public Account getAccount(String email) {
        try {
            return (Account) this.sqlMapClient.queryForObject("getAccountByEmail", email);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }

    public void insertAccount(Account account) throws DataAccessException {
        try {
            this.sqlMapClient.update("insertAccount", account);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }
}</pre><p>In such a scenario, the <code class="literal">SQLException</code>
        thrown by the iBATIS API needs to be handled in a custom fashion:
        usually, wrapping it in your own application-specific DAO exception.
        Wiring in the application context would still look like before, due to
        the fact that the plain iBATIS-based DAO still follows the Dependency
        Injection pattern: </p><pre class="programlisting">&lt;beans&gt;
  ...

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mvc"></a>Chapter&nbsp;13.&nbsp;Web MVC framework</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-introduction"></a>13.1.&nbsp;Introduction to the web MVC framework</h2></div></div></div><p>Spring's web MVC framework is designed around a DispatcherServlet
    that dispatches requests to handlers, with configurable handler mappings,
    view resolution, locale and theme resolution as well as support for upload
    files. The default handler is a very simple Controller interface, just
    offering a <code class="literal">ModelAndView handleRequest(request,response)</code>
    method. This can already be used for application controllers, but you will
    prefer the included implementation hierarchy, consisting of, for example
    <code class="literal">AbstractController</code>,
    <code class="literal">AbstractCommandController</code> and
    <code class="literal">SimpleFormController</code>. Application controllers will
    typically be subclasses of those. Note that you can choose an appropriate
    base class: If you don't have a form, you don't need a FormController.
    This is a major difference to Struts.</p><p>You can use any object as a command or form object - there's no need
    to implement an interface or derive from a base class. Spring's data
    binding is highly flexible, for example, it treats type mismatches as
    validation errors that can be evaluated by the application, not as system
    errors. So you don't need to duplicate your business objects' properties
    as Strings in your form objects, just to be able to handle invalid
    submissions, or to convert the Strings properly. Instead, it is often
    preferable to bind directly to your business objects. This is another
    major difference to Struts which is built around required base classes
    like <code class="literal">Action</code> and <code class="literal">ActionForm</code> - for
    every type of action.</p><p>Compared to WebWork, Spring has more differentiated object roles. It
    supports the notion of a Controller, an optional command or form object,
    and a model that gets passed to the view. The model will normally include
    the command or form object but also arbitrary reference data. Instead, a
    WebWork Action combines all those roles into one single object. WebWork
    does allow you to use existing business objects as part of your form, but
    only by making them bean properties of the respective Action class.
    Finally, the same Action instance that handles the request is used for
    evaluation and form population in the view. Thus, reference data needs to
    be modeled as bean properties of the Action too. These are arguably too
    many roles for one object.</p><p>Spring's view resolution is extremely flexible. A Controller
    implementation can even write a view directly to the response, returning
    null as ModelAndView. In the normal case, a ModelAndView instance consists
    of a view name and a model Map, containing bean names and corresponding
    objects (like a command or form, containing reference data). View name
    resolution is highly configurable, either via bean names, via a properties
    file, or via your own ViewResolver implementation. The abstract model Map
    allows for complete abstraction of the view technology, without any
    hassle. Any renderer can be integrated directly, whether JSP, Velocity, or
    any other rendering technology. The model Map is simply transformed into
    an appropriate format, such as JSP request attributes or a Velocity
    template model.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-introduction-pluggability"></a>13.1.1.&nbsp;Pluggability of other MVC implementations</h3></div></div></div><p>There are several reasons why some projects will prefer to use
      other MVC implementations. Many teams expect to leverage their existing
      investment in skills and tools. In addition, there is a large body of
      knowledge and experience avalailable for the Struts framework. Thus, if
      you can live with Struts' architectural flaws, it can still be a viable
      choice for the web layer. The same applies to WebWork and other web MVC
      frameworks.</p><p>If you don't want to use Spring's web MVC, but intend to leverage
      other solutions that Spring offers, you can integrate the web MVC
      framework of your choice with Spring easily. Simply start up a Spring
      root application context via its ContextLoaderListener, and access it
      via its ServletContext attribute (or Spring's respective helper method)
      from within a Struts or WebWork action. Note that there aren't any
      "plugins" involved, so no dedicated integration is necessary. From the
      web layer's point of view, you'll simply use Spring as a library, with
      the root application context instance as the entry point.</p><p>All your registered beans and all of Spring's services can be at
      your fingertips even without Spring's web MVC. Spring doesn't compete
      with Struts or WebWork in this scenario, it just addresses the many
      areas that the pure web MVC frameworks don't, from bean configuration to
      data access and transaction handling. So you are able to enrich your
      application with a Spring middle tier and/or data access tier, even if
      you just want to use, for example, the transaction abstraction with JDBC
      or Hibernate.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-features"></a>13.1.2.&nbsp;Features of Spring MVC</h3></div></div></div><p>Spring's web module provides a wealth of unique web support
      features, including:</p><div class="itemizedlist"><ul type="disc" compact><li><p>Clear separation of roles - controller, validator, command
          object, form object, model object, DispatcherServlet, handler
          mapping, view resolver, etc. Each role can be fulfilled by a
          specialized object.</p></li><li><p>Powerful and straightforward configuration of both framework
          and application classes as JavaBeans, including easy referencing
          across contexts, such as from web controllers to business objects
          and validators.</p></li><li><p>Adaptability, non-intrusiveness. Use whatever controller
          subclass you need (plain, command, form, wizard, multi-action, or a
          custom one) for a given scenario instead of deriving from a single
          controller for everything.</p></li><li><p>Reusable business code - no need for duplication. You can use
          existing business objects as command or form objects instead of
          mirroring them in order to extend a particular framework base
          class.</p></li><li><p>Customizable binding and validation - type mismatches as
          application-level validation errors that keep the offending value,
          localized date and number binding, etc instead of String-only form
          objects with manual parsing and conversion to business
          objects.</p></li><li><p>Customizable handler mapping and view resolution - handler
          mapping and view resolution strategies range from simple URL-based
          configuration, to sophisticated, purpose-built resolution
          strategies. This is more flexible than some web MVC frameworks which
          mandate a particular technique.</p></li><li><p>Flexible model transfer - model transfer via a name/value Map
          supports easy integration with any view technology.</p></li><li><p>Customizable locale and theme resolution, support for JSPs
          with or without Spring tag library, support for JSTL, support for
          Velocity without the need for extra bridges, etc.</p></li><li><p>A simple but powerful tag library that avoids HTML generation
          at any cost, allowing for maximum flexibility in terms of markup
          code.</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-servlet"></a>13.2.&nbsp;The <code class="literal">DispatcherServlet</code></h2></div></div></div><p>Spring's web MVC framework is, like many other web MVC frameworks, a
    request-driven web MVC framework, designed around a servlet that
    dispatches requests to controllers and offers other functionality
    facilitating the development of web applications. Spring's
    <code class="literal">DispatcherServlet</code> however, does more than just that. It
    is completely integrated with the Spring ApplicationContext and allows you
    to use every other feature Spring has.</p><p>Like ordinary servlets, the DispatcherServlet is declared in the
    <code class="literal">web.xml</code> of your web application. Requests that you want
    the DispatcherServlet to handle, will have to be mapped, using a URL
    mapping in the same <code class="literal">web.xml</code> file.</p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</pre><p>In the example above, all requests ending with
    <code class="literal">.form</code> will be handled by the DispatcherServlet. The
    DispatcherServlet now needs to be configured.</p><p>As illustrated in <a href="#context-introduction" title="3.11.&nbsp;Introduction to the ApplicationContext">Section&nbsp;3.11, &#8220;Introduction to the <code class="literal">ApplicationContext</code>&#8221;</a>,
    ApplicationContexts in Spring can be scoped. In the web MVC framework,
		each DispatcherServlet has its own <code class="literal">WebApplicationContext</code>,
    which inherits all the beans already defined in in the Root WebApplicationContext.
		These inherited beans defined can be overridden in the servlet-specific scope,
    and new scope-specific beans can be defined local to a given servlet instance.</p><p>The framework will, on initialization of a DispatcherServlet,
    <span class="emphasis"><em>look for a file named <code class="literal">[servlet-name]-servlet.xml</code></em></span>
    in the <code class="literal">WEB-INF</code> directory of your web application and
    create the beans defined there (overriding the definitions of any beans
    defined with the same name in the global scope).</p><p>The config location used by the DispatcherServlet can be modified
    through a servlet initialization parameter (see below for details).</p><p>The <code class="literal">WebApplicationContext</code> is just an ordinary
    ApplicationContext that has some extra features necessary for web
    applications. It differs from a normal ApplicationContext in that it is
    capable of resolving themes (see <a href="#mvc-themeresolver" title="13.7.&nbsp;Using themes">Section&nbsp;13.7, &#8220;Using themes&#8221;</a>),
    and that is knows which servlet it is associated with (by having a link to
    the <code class="literal">ServletContext</code>). The WebApplicationContext is bound
    in the ServletContext, and using <code class="literal">RequestContextUtils</code>
    you can always lookup the WebApplicationContext in case you need
    it.</p><p>The Spring DispatcherServlet has a couple of special beans it uses,
    in order to be able to process requests and render the appropriate views.
    These beans are included in the Spring framework and can be configured in
    the WebApplicationContext, just as any other bean would be configured.
    Each of those beans, is described in more detail below. Right now, we'll
    just mention them, just to let you know they exist and to enable us to go
    on talking about the DispatcherServlet. For most of the beans, defaults
    are provided so you don't have to worry about configuring them.</p><div class="table"><a name="d0e9063"></a><p class="title"><b>Table&nbsp;13.1.&nbsp;Special beans in the WebApplicationContext</b></p><div class="table-contents"><table summary="Special beans in the WebApplicationContext" border="1"><colgroup><col><col></colgroup><thead><tr><th>Expression</th><th>Explanation</th></tr></thead><tbody><tr><td>handler mapping(s)</td><td>(<a href="#mvc-handlermapping" title="13.4.&nbsp;Handler mappings">Section&nbsp;13.4, &#8220;Handler mappings&#8221;</a>) a list of pre- and
            postprocessors and controllers that will be executed if they match
            certain criteria (for instance a matching URL specified with the
            controller)</td></tr><tr><td>controller(s)</td><td>(<a href="#mvc-controller" title="13.3.&nbsp;Controllers">Section&nbsp;13.3, &#8220;Controllers&#8221;</a>) the beans providing the
            actual functionality (or at least, access to the functionality) as
            part of the MVC triad</td></tr><tr><td>view resolver</td><td>(<a href="#mvc-viewresolver" title="13.5.&nbsp;Views and resolving them">Section&nbsp;13.5, &#8220;Views and resolving them&#8221;</a>) capable of resolving
            view names to views, used by the DispatcherServlet</td></tr><tr><td>locale resolver</td><td>(<a href="#mvc-localeresolver" title="13.6.&nbsp;Using locales">Section&nbsp;13.6, &#8220;Using locales&#8221;</a>) capable of
            resolving the locale a client is using, in order to be able to
            offer internationalized views</td></tr><tr><td>theme resolver</td><td>(<a href="#mvc-themeresolver" title="13.7.&nbsp;Using themes">Section&nbsp;13.7, &#8220;Using themes&#8221;</a>) capable of resolving
            themes your web application can use, for example, to offer
            personalized layouts</td></tr><tr><td>multipart resolver</td><td>(<a href="#mvc-multipart" title="13.8.&nbsp;Spring's multipart (fileupload) support">Section&nbsp;13.8, &#8220;Spring's multipart (fileupload) support&#8221;</a>) offers functionality to
            process file uploads from HTML forms</td></tr><tr><td>handlerexception resolver</td><td>(<a href="#mvc-exceptionhandlers" title="13.9.&nbsp;Handling exceptions">Section&nbsp;13.9, &#8220;Handling exceptions&#8221;</a>) offers
            functionality to map exceptions to views or implement other more
            complex exception handling code</td></tr></tbody></table></div></div><br class="table-break"><p>When a DispatcherServlet is setup for use and a request comes in for
    that specific DispatcherServlet it starts processing it. The list below
    describes the complete process a request goes through if handled by a
    DispatcherServlet: </p><div class="orderedlist"><ol type="1" compact><li><p>The WebApplicationContext is searched for and bound in the
          request as an attribute in order for the controller and other
          elements in the process to use. It is bound by default under the key
          <code class="literal">DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code>.</p></li><li><p>The locale resolver is bound to the request to let elements in
          the process resolve the locale to use when processing the request
          (rendering the view, preparing data, etc.) If you don't use the
          resolver, it won't affect anything, so if you don't need locale
          resolving, you don't have to use it.</p></li><li><p>The theme resolver is bound to the request to let elements
          such as views determine which theme to use. The theme resolver does
          not affect anything if you don't use it, so if you don't need themes
          you can just ignore it.</p></li><li><p>If a multipart resolver is specified, the request is inspected
          for multiparts and if they are found, it is wrapped in a
          <code class="literal">MultipartHttpServletRequest</code> for further
          processing by other elements in the process. (See <a href="#mvc-multipart-resolver" title="13.8.2.&nbsp;Using the MultipartResolver">Section&nbsp;13.8.2, &#8220;Using the <code class="literal">MultipartResolver</code>&#8221;</a> for further information about
          multipart handling).</p></li><li><p>An appropriate handler is searched for. If a handler is found,
          the execution chain associated with the handler (preprocessors,
          postprocessors, controllers) will be executed in order to prepare a
          model.</p></li><li><p>If a model is returned, the view is rendered, using the view
          resolver that has been configured with the WebApplicationContext. If
          no model is returned (which could be due to a pre- or postprocessor
          intercepting the request, for example, for security reasons), no
          view is rendered, since the request could already have been
          fulfilled.</p></li></ol></div><p>Exceptions that might be thrown during processing of the request get
    picked up by any of the handlerexception resolvers that are declared in
    the WebApplicationContext. Using these exception resolvers you can define
    custom behavior in case such exceptions get thrown.</p><p>The Spring DispatcherServlet also has support for returning the
    <span class="emphasis"><em>last-modification-date</em></span>, as specified by the Servlet
    API. The process of determining the last modification date for a specific
    request, is simple. The DispatcherServlet will first lookup an appropriate
    handler mapping and test if the handler that is found <span class="emphasis"><em>implements
    the interface <code class="literal">LastModified</code></em></span> and if so, the
    value of <code class="literal">long getLastModified(request)</code> is returned to
    the client.</p><p>You can customize Spring's DispatcherServlet by adding context
    parameters in the <code class="literal">web.xml</code> file or servlet init
    parameters. The possibilities are listed below.</p><div class="table"><a name="d0e9174"></a><p class="title"><b>Table&nbsp;13.2.&nbsp;DispatcherServlet initialization parameters</b></p><div class="table-contents"><table summary="DispatcherServlet initialization parameters" border="1"><colgroup><col><col></colgroup><thead><tr><th>Parameter</th><th>Explanation</th></tr></thead><tbody><tr><td><code class="literal">contextClass</code></td><td>Class that implements
            <code class="literal">WebApplicationContext</code>, which will be used to
            instantiate the context used by this servlet. If this parameter
            isn't specified, the <code class="literal">XmlWebApplicationContext</code>
            will be used.</td></tr><tr><td><code class="literal">contextConfigLocation</code></td><td>String which is passed to the context instance (specified
            by <code class="literal">contextClass</code>) to indicate where context(s)
            can be found. The String is potentially split up into multiple
            strings (using a comma as a delimiter) to support multiple
            contexts (in case of multiple context locations, of beans that are
            defined twice, the latest takes precedence).</td></tr><tr><td>namespace</td><td>the namespace of the
            <code class="literal">WebApplicationContext</code>. Defaults to
            <code class="literal">[server-name]-servlet</code>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-controller"></a>13.3.&nbsp;Controllers</h2></div></div></div><p>The notion of a controller is part of the MVC design pattern.
    Controllers define application behavior, or at least provide access to the
    application behavior. Controllers interpret user input and transform the
    user input into a sensible model which will be represented to the user by
    the view. Spring has implemented the notion of a controller in a very
    abstract way enabling a wide variety of different kinds of controllers to
    be created. Spring contains formcontroller, commandcontroller, controllers
    that execute wizard-style logic, and more.</p><p>Spring's basis for the controller architecture is the
    <code class="literal">org.springframework.web.servlet.mvc.Controller</code>
    interface, which is listed below. </p><pre class="programlisting">public interface Controller {

    /**
     * Process the request and return a ModelAndView object which the DispatcherServlet
     * will render.
     */
    ModelAndView handleRequest(
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception;
}</pre><p> As you can see, the <code class="literal">Controller</code> interface
    requires a single method that should be capable of handling a request and
    returning an appropriate model and view. These three concepts are the
    basis for the Spring MVC implementation -
    <span class="emphasis"><em>ModelAndView</em></span> and <span class="emphasis"><em>Controller</em></span>.
    While the <code class="literal">Controller</code> interface is quite abstract,
    Spring offers a lot of controllers that already contain a lot of the
    functionality you might need. The <code class="literal">Controller</code> interface
    just defines the most common functionality required of every controller -
    handling a request and returning a model and a view.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-abstractcontroller"></a>13.3.1.&nbsp;AbstractController and WebContentGenerator</h3></div></div></div><p>Of course, just a controller interface isn't enough. To provide a
      basic infrastructure, all of Spring's Controllers inherit from
      AbstractController, a class offering caching support and, for example,
      the setting of the mimetype.</p><div class="table"><a name="mvc-controller-abstract-features"></a><p class="title"><b>Table&nbsp;13.3.&nbsp;Features offered by the
        <code class="literal">AbstractController</code></b></p><div class="table-contents"><table summary="Features offered by the&#xA;        AbstractController" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explanation</th></tr></thead><tbody><tr><td><code class="literal">supportedMethods</code></td><td>indicates what methods this controller should accept.
              Usually this is set to both <code class="literal">GET</code> and
              <code class="literal">POST</code>, but you can modify this to reflect the
              method you want to support. If a request is received with a
              method that is not supported by the controller, the client will
              be informed of this (using a
              <code class="literal">ServletException)</code>).</td></tr><tr><td><code class="literal">requiresSession</code></td><td>indicates whether or not this controller requires a
              session to do its work. This feature is offered to all
              controllers. If a session is not present when such a controller
              receives a request, the user is informed using a
              <code class="literal">ServletException</code>.</td></tr><tr><td><code class="literal">synchronizeSession</code></td><td>use this if you want handling by this controller to be
              synchronized on the user's session. To be more specific,
              extending controller will override the
              <code class="literal">handleRequestInternal</code> method, which will be
              synchronized if you specify this variable.</td></tr><tr><td><code class="literal">cacheSeconds</code></td><td>when you want a controller to generate a caching
              directive in the HTTP response, specify a positive integer here.
              By default it is set to <span class="emphasis"><em>-1</em></span> so no caching
              directives will be included.</td></tr><tr><td><code class="literal">useExpiresHeader</code></td><td>tweaks your controllers to specify the HTTP 1.0
              compatible <span class="emphasis"><em>"Expires"</em></span> header. By default
              it's set to true, so you won't have to change it.</td></tr><tr><td><code class="literal">useCacheHeader</code></td><td>tweaks your controllers to specify the HTTP 1.1
              compatible <span class="emphasis"><em>"Cache-Control"</em></span> header. By
              default this is set to true so you won't have to change
              it.</td></tr></tbody></table></div></div><br class="table-break"><p><span class="emphasis"><em>The last two properties are actually part of the
      <code class="literal">WebContentGenerator</code> which is the superclass of
      <code class="literal">AbstractController</code> but are included here for
      completeness.</em></span></p><p>When using the AbstractController as a baseclass for your
      controllers (which is <span class="emphasis"><em>not</em></span> recommended since there
      are a lot of other controllers that might already do the job for you)
      you only have to override the
      <code class="literal">handleRequestInternal(HttpServletRequest,
      HttpServletResponse)</code> method, implement your logic, and return
      a <code class="literal">ModelAndView</code> object. Here is short example
      consisting of a class and a declaration in the web application context.
      </p><pre class="programlisting">package samples;

public class SampleController extends AbstractController {

    public ModelAndView handleRequestInternal(
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception {
        ModelAndView mav = new ModelAndView("foo");
        mav.addObject("message", "Hello World!");
        return mav;        
    }
}</pre><p> </p><pre class="programlisting">&lt;bean id="sampleController" class="samples.SampleController"&gt;
    &lt;property name="cacheSeconds" value="120"/&gt;
&lt;/bean&gt;</pre><p> The class above and the declaration in the web
      application context is all you need besides setting up a handler mapping
      (see <a href="#mvc-handlermapping" title="13.4.&nbsp;Handler mappings">Section&nbsp;13.4, &#8220;Handler mappings&#8221;</a>) to get this very simple
      controller working. This controller will generate caching directives
      telling the client to cache things for 2 minutes before rechecking. This
      controller returns an hard-coded view (hmm, not so nice), named index
      (see <a href="#mvc-viewresolver" title="13.5.&nbsp;Views and resolving them">Section&nbsp;13.5, &#8220;Views and resolving them&#8221;</a> for more information about
      views).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-othersimplecontrollers"></a>13.3.2.&nbsp;Other simple controllers</h3></div></div></div><p>Although you can extend AbstractController, Spring provides a
      number of concrete implementations which offer functionality that is
      commonly used in simple MVC applications. The
      <code class="literal">ParameterizableViewController</code> is basically the same
      as the example above, except for the fact that you can specify the view
      name that it will return in the web application context (ahhh, no need
      to hard-code the viewname).</p><p>The <code class="literal">UrlFilenameViewController</code> inspects the URL
      and retrieves the filename of the file request (the filename of
      <code class="literal">http://www.springframework.org/index.html</code> is
      <code class="literal">index</code>) and uses that as a viewname. Nothing more to
      it.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-multiaction"></a>13.3.3.&nbsp;The <code class="literal">MultiActionController</code></h3></div></div></div><p>Spring offers a multi-action controller with which you aggregate
      multiple actions into one controller, grouping functionality together.
      The multi-action controller lives in a separate package -
      <code class="literal">org.springframework.web.servlet.mvc.multiaction</code> - and
      is capable of mapping requests to method names and then invoking the
      right method name. Using the multi-action controller is especially handy
      when you have a lot of common functionality in one controller, but want
      to have multiple entry points to the controller, for example, to tweak
      behavior.</p><div class="table"><a name="mvc-controller-multiaction-features"></a><p class="title"><b>Table&nbsp;13.4.&nbsp;Features offered by the
        <code class="literal">MultiActionController</code></b></p><div class="table-contents"><table summary="Features offered by the&#xA;        MultiActionController" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explanation</th></tr></thead><tbody><tr><td><code class="literal">delegate</code></td><td>there are two usage-scenarios for the
              MultiActionController. Either you subclass the
              MultiActionController and specify the methods that will be
              resolved by the MethodNameResolver on the subclass (in which
              case you don't need to set the delegate), or you define a
              delegate object, on which methods resolved by the Resolver will
              be invoked. If you choose this scenario, you will have to define
              the delegate using this configuration parameter as a
              collaborator.</td></tr><tr><td><code class="literal">methodNameResolver</code></td><td>somehow the MultiActionController will need to resolve
              the method it has to invoke, based on the request that came in.
              You can define a resolver that is capable of doing that using
              this configuration parameter.</td></tr></tbody></table></div></div><br class="table-break"><p>Methods defined for a multi-action controller need to conform to
      the following signature: </p><pre class="programlisting">// actionName can be replaced by any methodname
ModelAndView actionName(HttpServletRequest, HttpServletResponse);</pre><p>
      Method overloading is not allowed since it would confuse the
      MultiActionController. Furthermore, you can define <span class="emphasis"><em>exception
      handlers</em></span> capable of handling exceptions that are thrown by
      the methods you specify. Exception handler methods need to return a
      ModelAndView object, just as any other action method and need to conform
      to the following signature: </p><pre class="programlisting">// anyMeaningfulName can be replaced by any methodname
ModelAndView anyMeaningfulName(HttpServletRequest, HttpServletResponse, ExceptionClass);</pre><p>
      The <code class="literal">ExceptionClass</code> can be <span class="emphasis"><em>any</em></span>
      exception, as long as it's a subclass of
      <code class="literal">java.lang.Exception</code> or
      <code class="literal">java.lang.RuntimeException</code>.</p><p>The <code class="literal">MethodNameResolver</code> is supposed to resolve
      method names based on the request coming in. There are three resolvers
      at your disposal, but of course you can implement more of them yourself
      if you want to. </p><div class="itemizedlist"><ul type="disc" compact><li><p><code class="literal">ParameterMethodNameResolver</code> - capable of
            resolving a request parameter and using that as the method name
            (<code class="literal">http://www.sf.net/index.view?testParam=testIt</code>
            will result in a method <code class="literal">testIt(HttpServletRequest,
            HttpServletResponse)</code> being called). The
            <code class="literal">paramName</code> configuration parameter specifies the
            parameter that is inspected).</p></li><li><p><code class="literal">InternalPathMethodNameResolver</code> -
            retrieves the filename from the path and uses that as the method
            name (<code class="literal">http://www.sf.net/testing.view</code> will
            result in a method <code class="literal">testing(HttpServletRequest,
            HttpServletResponse)</code> being called).</p></li><li><p><code class="literal">PropertiesMethodNameResolver</code> - uses a
            user-defined properties object with request URLs mapped to
            methodnames. When the properties contain
            <code class="literal">/index/welcome.html=doIt</code> and a request to
            <code class="literal">/index/welcome.html</code> comes in, the
            <code class="literal">doIt(HttpServletRequest, HttpServletResponse)</code>
            method is called. This method name resolver works with the
            <code class="literal">PathMatcher</code>, so if the properties contained
            <code class="literal">/**/welcom?.html</code>, it would also have
            worked!</p></li></ul></div><p>Here are a couple of examples. First, an example showing the
      <code class="literal">ParameterMethodNameResolver</code> and the delegate
      property, which will accept requests to urls with the parameter method
      included and set to <code class="literal">retrieveIndex</code>: </p><pre class="programlisting">&lt;bean id="paramResolver" class="org....mvc.multiaction.ParameterMethodNameResolver"&gt;
  &lt;property name="paramName"&gt;&lt;value&gt;method&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController"&gt;
  &lt;property name="methodNameResolver"&gt;&lt;ref bean="paramResolver"/&gt;&lt;/property&gt;
  &lt;property name="delegate"&gt;&lt;ref bean="sampleDelegate"/&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="sampleDelegate" class="samples.SampleDelegate"/&gt;

## together with

public class SampleDelegate {

    public ModelAndView retrieveIndex(
        HttpServletRequest req,
        HttpServletResponse resp) {

        return new ModelAndView("index", "date", new Long(System.currentTimeMillis()));
    }
}</pre><p> When using the delegates shown above, we could also use the
      <code class="literal">PropertiesMethodNameResolver</code> to match a couple of
      URLs to the method we defined: </p><pre class="programlisting">&lt;bean id="propsResolver" class="org....mvc.multiaction.PropertiesMethodNameResolver"&gt;
  &lt;property name="mappings"&gt;
    &lt;props&gt;
      &lt;prop key="/index/welcome.html"&gt;retrieveIndex&lt;/prop&gt;
      &lt;prop key="/**/notwelcome.html"&gt;retrieveIndex&lt;/prop&gt;
      &lt;prop key="/*/user?.html"&gt;retrieveIndex&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController"&gt;
    &lt;property name="methodNameResolver"&gt;&lt;ref bean="propsResolver"/&gt;&lt;/property&gt;
    &lt;property name="delegate"&gt;&lt;ref bean="sampleDelegate"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-command"></a>13.3.4.&nbsp;CommandControllers</h3></div></div></div><p>Spring's <span class="emphasis"><em>CommandControllers</em></span> are a fundamental
      part of the Spring MVC package. Command controllers provide a way to
      interact with data objects and dynamically bind parameters from the
      <code class="literal">HttpServletRequest</code> to the data object specified. They
      perform a similar role to Struts' ActionForm, but in Spring, your data
      objects don't have to implement a framework-specific interface. First,
      let's examine what command controllers available, to get overview of
      what you can do with them: </p><div class="itemizedlist"><ul type="disc" compact><li><p><code class="literal">AbstractCommandController</code> - a command
            controller you can use to create your own command controller,
            capable of binding request parameters to a data object you
            specify. This class does not offer form functionality, it does
            however, offer validation features and lets you specify in the
            controller itself what to do with the command object that has been
            filled with the parameters from the request.</p></li><li><p><code class="literal">AbstractFormController</code> - an abstract
            controller offering form submission support. Using this controller
            you can model forms and populate them using a command object you
            retrieve in the controller. After a user has filled the form, the
            AbstractFormController binds the fields, validates, and hands the
            object back to the controller to take appropriate action.
            Supported features are: invalid form submission (resubmission),
            validation, and normal form workflow. You implement methods to
            determine which views are used for form presentation and success.
            Use this controller if you need forms, but don't want to specify
            what views you're going to show the user in the application
            context.</p></li><li><p><code class="literal">SimpleFormController</code> - a concrete
            FormController that provides even more support when creating a
            form with a corresponding command object. The SimpleFormController
            let's you specify a command object, a viewname for the form, a
            viewname for page you want to show the user when form submission
            has succeeded, and more.</p></li><li><p><code class="literal">AbstractWizardFormController</code> - as the
            class name suggests, this is an abstract class--your
            WizardController should extend it. This means you have to
            implement the <code class="literal">validatePage()</code>,
            <code class="literal">processFinish</code> and
            <code class="literal">processCancel</code> methods.</p><p>You probably also want to write a contractor, which should
            at the very least call <code class="literal">setPages()</code> and
            <code class="literal">setCommandName()</code>. The former takes as its
            argument an array of type String. This array is the list of views
            which comprise your wizard. The latter takes as its argument a
            String, which will be used to refer to your command object from
            within your views.</p><p>As with any instance of AbstractFormController, you are
            required to use a command object - a JavaBean which will be
            populated with the data from your forms. You can do this in one of
            two ways: either call <code class="literal">setCommandClass()</code> from
            the constructor with the class of your command object, or
            implement the <code class="literal">formBackingObject()</code>
            method.</p><p>AbstractWizardFormController has a number of concrete
            methods that you may wish to override. Of these, the ones you are
            likely to find most useful are: <code class="literal">referenceData</code>
            which you can use to pass model data to your view in the form of a
            Map; <code class="literal">getTargetPage</code> if your wizard needs to
            change page order or omit pages dynamically; and
            <code class="literal">onBindAndValidate</code> if you want to override the
            built-in binding and validation workflow.</p><p>Finally, it is worth pointing out the
            <code class="literal">setAllowDirtyBack</code> and
            <code class="literal">setAllowDirtyForward</code>, which you can call from
            <code class="literal">getTargetPage</code> to allow users to move backwards
            and forwards in the wizard even if validation fails for the
            current page.</p><p>For a full list of methods, see the JavaDoc for
            AbstractWizardFormController. There is an implemented example of
            this wizard in the jPetStore included in the Spring distribution:
            org.springframework.samples.jpetstore.web.spring.OrderFormController</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-handlermapping"></a>13.4.&nbsp;Handler mappings</h2></div></div></div><p>Using a handler mapping you can map incoming web requests to
    appropriate handlers. There are some handler mappings you can use out of
    the box, for example, the <code class="literal">SimpleUrlHandlerMapping</code> or
    the <code class="literal">BeanNameUrlHandlerMapping</code>, but let's first examine
    the general concept of a <code class="literal">HandlerMapping</code>.</p><p>The functionality a basic <code class="literal">HandlerMapping</code> provides
    is the delivering of a <code class="literal">HandlerExecutionChain</code>, which
    must contain the handler that matches the incoming request, and may also
    contain a list of handler interceptors that are applied to the request.
    When a request comes in, the <code class="literal">DispatcherServlet</code> will
    hand it over to the handler mapping to let it inspect the request and come
    up with an appropriate HandlerExecutionChain. Then the DispatcherServlet
    will execute the handler and interceptors in the chain (if any).</p><p>The concept of configurable handler mappings that can optionally
    contain interceptors (executed before or after the actual handler was
    executed, or both) is extremely powerful. A lot of supporting
    functionality can be built into custom <code class="literal">HandlerMapping</code>s.
    Think of a custom handler mapping that chooses a handler not only based on
    the URL of the request coming in, but also on a specific state of the
    session associated with the request.</p><p>This section describes two of Spring's most commonly used handler
    mappings. They both extend the <code class="literal">AbstractHandlerMapping</code>
    and share the following properties: </p><div class="itemizedlist"><ul type="disc" compact><li><p><code class="literal">interceptors</code>: the list of interceptors to
          use. <code class="literal">HandlerInterceptor</code>s are discussed in <a href="#mvc-handlermapping-interceptor" title="13.4.3.&nbsp;Adding HandlerInterceptors">Section&nbsp;13.4.3, &#8220;Adding <code class="literal">HandlerInterceptors</code>&#8221;</a>.</p></li><li><p><code class="literal">defaultHandler</code>: the default handler to use,
          when this handler mapping does not result in a matching
          handler.</p></li><li><p><code class="literal">order</code>: based on the value of the order
          property (see the
          <code class="literal">org.springframework.core.Ordered</code> interface),
          Spring will sort all handler mappings available in the context and
          apply the first matching handler.</p></li><li><p><code class="literal">alwaysUseFullPath</code>: if this property is set
          to <code class="literal">true</code>, Spring will use the full path within the
          current servlet context to find an appropriate handler. If this
          property is set to <code class="literal">false</code> (the default), the path
          within the current servlet mapping will be used. For example, if a
          servlet is mapped using <code class="literal">/testing/*</code> and the
          <code class="literal">alwaysUseFullPath</code> property is set to true,
          <code class="literal">/testing/viewPage.html</code> would be used, whereas if
          the property is set to false, <code class="literal">/viewPage.html</code>
          would be used.</p></li><li><p><code class="literal">urlPathHelper</code>: using this property, you can
          tweak the UrlPathHelper used when inspecting URLs. Normally, you
          shouldn't have to change the default value.</p></li><li><p><code class="literal">urlDecode</code>: the default value for this
          property is <code class="literal">false</code>. The
          <code class="literal">HttpServletRequest</code> returns request URLs and URIs
          that are <span class="emphasis"><em>not</em></span> decoded. If you do want them to be
          decoded before a <code class="literal">HandlerMapping</code> uses them to find
          an appropriate handler, you have to set this to
          <code class="literal">true</code> (note that this requires JDK 1.4). The
          decoding method uses either the encoding specified by the request or
          the default ISO-8859-1 encoding scheme.</p></li><li><p><code class="literal">lazyInitHandlers</code>: allows for lazy
          initialization of <span class="emphasis"><em>singleton</em></span> handlers (prototype
          handlers are always lazily initialized). Default value is
          <code class="literal">false</code>.</p></li></ul></div><p> (<span class="emphasis"><em>Note: the last four properties are only
    available to subclasses of
    <code class="literal">org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</code></em></span>).</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-beanname"></a>13.4.1.&nbsp;<code class="literal">BeanNameUrlHandlerMapping</code></h3></div></div></div><p>A very simple, but very powerful handler mapping is the
      <code class="literal">BeanNameUrlHandlerMapping</code>, which maps incoming HTTP
      requests to names of beans, defined in the web application context.
      Let's say we want to enable a user to insert an account and we've
      already provided an appropriate FormController (see <a href="#mvc-controller-command" title="13.3.4.&nbsp;CommandControllers">Section&nbsp;13.3.4, &#8220;CommandControllers&#8221;</a> for more information on Command- and
      FormControllers) and a JSP view (or Velocity template) that renders the
      form. When using the BeanNameUrlHandlerMapping, we could map the HTTP
      request with URL <code class="literal">http://samples.com/editaccount.form</code>
      to the appropriate FormController as follows: </p><pre class="programlisting">&lt;beans&gt;
  &lt;bean id="handlerMapping" class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;

  &lt;bean name="/editaccount.form" class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
    &lt;property name="formView"&gt;&lt;value&gt;account&lt;/value&gt;&lt;/property&gt;
    &lt;property name="successView"&gt;&lt;value&gt;account-created&lt;/value&gt;&lt;/property&gt;
    &lt;property name="commandName"&gt;&lt;value&gt;Account&lt;/value&gt;&lt;/property&gt;
    &lt;property name="commandClass"&gt;&lt;value&gt;samples.Account&lt;/value&gt;&lt;/property&gt;
  &lt;/bean&gt;
&lt;beans&gt;    </pre><p> All incoming requests for the URL
      <code class="literal">/editaccount.form</code> will now be handled by the
      FormController in the source listing above. Of course we have to define
      a servlet-mapping in web.xml as well, to let through all the requests
      ending with .form. </p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

   &lt;!-- Maps the sample dispatcher to /*.form --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre><p><span class="emphasis"><em>NOTE: if you want to use the
      <code class="literal">BeanNameUrlHandlerMapping</code>, you don't necessarily have
      to define it in the web application context (as indicated above). By
      default, if no handler mapping can be found in the context, the
      DispatcherServlet creates a <code class="literal">BeanNameUrlHandlerMapping</code>
      for you! </em></span></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-urlhandlermapping"></a>13.4.2.&nbsp;<code class="literal">SimpleUrlHandlerMapping</code></h3></div></div></div><p>A further - and much more powerful handler mapping - is the
      <code class="literal">SimpleUrlHandlerMapping</code>. This mapping is configurable
      in the application context and has Ant-style path matching capabilities
      (see the JavaDoc for
      <code class="literal">org.springframework.util.PathMatcher</code>). Here is an
      example: </p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;!-- Maps the sample dispatcher to /*.form --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre><p> Allows all requests ending with .html and
      .form to be handled by the sample dispatcher servlet. </p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="/*/account.form"&gt;editAccountFormController&lt;/prop&gt;
                &lt;prop key="/*/editaccount.form"&gt;editAccountFormController&lt;/prop&gt;
                &lt;prop key="/ex/view*.html"&gt;someViewController&lt;/prop&gt;
                &lt;prop key="/**/help.html"&gt;helpController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="someViewController"
          class="org.springframework.web.servlet.mvc.UrlFilenameViewController"/&gt;

    &lt;bean id="editAccountFormController"
          class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
        &lt;property name="formView"&gt;&lt;value&gt;account&lt;/value&gt;&lt;/property&gt;
        &lt;property name="successView"&gt;&lt;value&gt;account-created&lt;/value&gt;&lt;/property&gt;
        &lt;property name="commandName"&gt;&lt;value&gt;Account&lt;/value&gt;&lt;/property&gt;
        &lt;property name="commandClass"&gt;&lt;value&gt;samples.Account&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;</pre><p> This handler mapping routes requests for
      <code class="literal">help.html</code> in any directory to the
      <code class="literal">helpController</code>, which is a UrlFilenameViewController
      (more about controllers can be found in <a href="#mvc-controller" title="13.3.&nbsp;Controllers">Section&nbsp;13.3, &#8220;Controllers&#8221;</a>). Requests for a resource beginning with
      <code class="literal">view</code>, and ending with <code class="literal">.html</code> in the
      directory <code class="literal">ex</code>, will be routed to the
      <code class="literal">someViewController</code>. Two further mappings are defined
      for <code class="literal">editAccountFormController</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-interceptor"></a>13.4.3.&nbsp;Adding <code class="literal">HandlerInterceptors</code></h3></div></div></div><p>Spring's handler mapping mechanism has a notion of handler
      interceptors, that can be extremely useful when you want to apply
      specific functionality to certain requests, for example, checking for a
      principal.</p><p>Interceptors located in the handler mapping must implement
      <code class="literal">HandlerInterceptor</code> from the
      <code class="literal">org.springframework.web.servlet</code> package. This
      interface defines three methods, one that will be called
      <span class="emphasis"><em>before</em></span> the actual handler will be executed, one
      that will be called <span class="emphasis"><em>after</em></span> the handler is executed,
      and one that is called <span class="emphasis"><em>after the complete request has
      finished</em></span>. These three methods should provide enough
      flexibility to do all kinds of pre- and post-processing.</p><p>The <code class="literal">preHandle</code> method returns a boolean value.
      You can use this method to break or continue the processing of the
      execution chain. When this method returns <code class="literal">true</code>, the
      handler execution chain will continue, when it returns false, the
      DispatcherServlet assumes the interceptor itself has taken care of
      requests (and, for example, rendered an appropriate view) and does not
      continue executing the other interceptors and the actual handler in the
      execution chain.</p><p>The following example provides an interceptor that intercepts all
      requests and reroutes the user to a specific page if the time is not
      between 9 a.m. and 6 p.m. </p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="interceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="officeHoursInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="/*.form"&gt;editAccountFormController&lt;/prop&gt;
                &lt;prop key="/*.view"&gt;editAccountFormController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="officeHoursInterceptor"
          class="samples.TimeBasedAccessInterceptor"&gt;
        &lt;property name="openingTime"&gt;&lt;value&gt;9&lt;/value&gt;&lt;/property&gt;
        &lt;property name="closingTime"&gt;&lt;value&gt;18&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;</pre><p> </p><pre class="programlisting">package samples;

public class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {

    private int openingTime;
    private int closingTime;
    public void setOpeningTime(int openingTime) {
        this.openingTime = openingTime;
    }
    public void setClosingTime(int closingTime) {
        this.closingTime = closingTime;
    }
    public boolean preHandle(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler)
    throws Exception {
        Calendar cal = Calendar.getInstance();
        int hour = cal.get(HOUR_OF_DAY);
        if (openingTime &lt;= hour &lt; closingTime) {
            return true;
        } else {
            response.sendRedirect("http://host.com/outsideOfficeHours.html");
            return false;
        }
    }
}</pre><p> Any request coming in, will be intercepted by the
      <code class="literal">TimeBasedAccessInterceptor</code>, and if the current time
      is outside office hours, the user will be redirected to a static html
      file, saying, for example, he can only access the website during office
      hours.</p><p>As you can see, Spring has an adapter to make it easy for you to
      extend the <code class="literal">HandlerInterceptor</code>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-viewresolver"></a>13.5.&nbsp;Views and resolving them</h2></div></div></div><p>All MVC frameworks for web applications provide a way to address
    views. Spring provides view resolvers, which enable you to render models
    in a browser without tying you to a specific view technology. Out of the
    box, Spring enables you to use Java Server Pages, Velocity templates and
    XSLT views, for example. <a href="#view" title="Chapter&nbsp;14.&nbsp;Integrating view technologies">Chapter&nbsp;14, <i>Integrating view technologies</i></a> has details of
    integrating various view technologies.</p><p>The two interfaces which are important to the way Spring handles
    views are <code class="literal">ViewResolver</code> and <code class="literal">View</code>. The
    <code class="literal">ViewResolver</code> provides a mapping between view names and
    actual views. The <code class="literal">View</code> interface addresses the
    preparation of the request and hands the request over to one of the view
    technologies.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-viewresolver-resolver"></a>13.5.1.&nbsp;ViewResolvers</h3></div></div></div><p>As discussed in <a href="#mvc-controller" title="13.3.&nbsp;Controllers">Section&nbsp;13.3, &#8220;Controllers&#8221;</a>, all controllers
      in the Spring web MVC framework, return a
      <code class="literal">ModelAndView</code> instance. Views in Spring are addressed
      by a view name and are resolved by a view resolver. Spring comes with
      quite a few view resolvers. We'll list most of them and then provide a
      couple of examples.</p><div class="table"><a name="d0e9859"></a><p class="title"><b>Table&nbsp;13.5.&nbsp;View resolvers</b></p><div class="table-contents"><table summary="View resolvers" border="1"><colgroup><col><col></colgroup><thead><tr><th>ViewResolver</th><th>Description</th></tr></thead><tbody><tr><td>AbstractCachingViewResolver</td><td>An abstract view resolver which takes care of caching
              views. Often views need preparation before they can be used,
              extending this view resolver provides caching of views.</td></tr><tr><td>XmlViewResolver</td><td>An implementation of ViewResolver that accepts a
              configuration file written in XML with the same DTD as Spring's
              bean factories. The default configuration file is
              <code class="literal">/WEB-INF/views.xml</code>.</td></tr><tr><td>ResourceBundleViewResolver</td><td>An implementation of ViewResolver that uses bean
              definitions in a ResourceBundle, specified by the bundle
              basename. The bundle is typically defined in a properties file,
              located in the classpath. The default file name is
              <code class="literal">views.properties</code>.</td></tr><tr><td>UrlBasedViewResolver</td><td>A simple implementation of ViewResolver that allows for
              direct resolution of symbolic view names to URLs, without an
              explicit mapping definition. This is appropriate if your
              symbolic names match the names of your view resources in a
              straightforward manner, without the need for arbitrary
              mappings.</td></tr><tr><td>InternalResourceViewResolver</td><td>A convenience subclass of UrlBasedViewResolver that
              supports InternalResourceView (i.e. Servlets and JSPs), and
              subclasses like JstlView and TilesView. The view class for all
              views generated by this resolver can be specified via
              setViewClass. See UrlBasedViewResolver's javadocs for
              details.</td></tr><tr><td>VelocityViewResolver / FreeMarkerViewResolver</td><td>A convenience subclass of UrlBasedViewResolver that
              supports VelocityView (i.e. Velocity templates) or
              FreeMarkerView respectively and custom subclasses of
              them.</td></tr></tbody></table></div></div><br class="table-break"><p>As an example, when using JSP for a view technology you can use
      the <code class="literal">UrlBasedViewResolver</code>. This view resolver
      translates a view name to a URL and hands the request over the
      RequestDispatcher to render the view. </p><pre class="programlisting">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
    &lt;property name="prefix"&gt;&lt;value&gt;/WEB-INF/jsp/&lt;/value&gt;&lt;/property&gt;
    &lt;property name="suffix"&gt;&lt;value&gt;.jsp&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p> When returning <code class="literal">test</code> as a
      viewname, this view resolver will hand the request over to the
      RequestDispatcher that will send the request to
      <code class="literal">/WEB-INF/jsp/test.jsp</code>.</p><p>When mixing different view technologies in a web application, you
      can use the ResourceBundleViewResolver: </p><pre class="programlisting">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename"&gt;&lt;value&gt;views&lt;/value&gt;&lt;/property&gt;
    &lt;property name="defaultParentView"&gt;&lt;value&gt;parentView&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The ResourceBundleViewResolver inspects the ResourceBundle
      identified by the basename, and for each view it is supposed to resolve,
      it uses the value of the property <code class="literal">[viewname].class</code> as
      the view class and the value of the property
      <code class="literal">[viewname].url</code> as the view url. As you can see, you
      can identify a parent view, from which all views in the properties file
      sort of extend. This way you can specify a default view class, for
      example.</p><p><span class="emphasis"><em>A note on caching</em></span> - subclasses of
      <code class="literal">AbstractCachingViewResolver</code> cache view instances they
      have resolved. This greatly improves performance when using certain view
      technology. It's possible to turn off the cache, by setting the
      <code class="literal">cache</code> property to false. Furthermore, if you have the
      requirement to be able to refresh a certain view at runtime (for example
      when a Velocity template has been modified), you can use the
      <code class="literal">removeFromCache(String viewName, Locale loc)</code>
      method.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-viewresolver-chaining"></a>13.5.2.&nbsp;Chaining ViewResolvers</h3></div></div></div><p>Spring supports more than just one view resolver. This allows you
      to chain resolvers and, for example, override specific views in certain
      circumstances. Chaining view resolvers is pretty straightforward - just
      add more than one resolver to your application context and, if
      necessary, set the <code class="literal">order</code> property to specify an
      order. Remember, the higher the order property, the later the view
      resolver will be positioned in the chain.</p><p>In the following example, the chain of view resolvers consists of
      two resolvers, a <code class="literal">InternalResourceViewResolver</code> (which
      is always automatically positioned as the last resolver in the chain)
      and an <code class="literal">XmlViewResolver</code> for specifying Excel views
      (which are not supported by the InternalResourceViewResolver):
      </p><pre class="programlisting">
&lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
  &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
  &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
  &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;

&lt;bean id="excelViewResolver" class="org.springframework.web.servlet.view.XmlViewResolver"&gt;
  &lt;property name="order" value="1"/&gt;
  &lt;property name="location" value="/WEB-INF/views.xml"/&gt;
&lt;/bean&gt;

### views.xml

&lt;beans&gt;
  &lt;bean name="report" class="org.springframework.example.ReportExcelView"/&gt;
&lt;/beans&gt;
</pre><p>If a specific view resolver does not result in a view, Spring will
      inspect the context to see if other view resolvers are configured. If
      there are additional view resolvers, it will continue to inspect them.
      If not, it will throw an Exception.</p><p>You have to keep something else in mind - the contract of a view
      resolver mentions that a view resolver <span class="emphasis"><em>can</em></span> return
      null to indicate the view could not be found. Not all view resolvers do
      this however! This is because in some cases, the resolver simply cannot
      detect whether or not the view exists. For example, the
      <code class="literal">InternalResourceViewResolver</code> uses the
      RequestDispatcher internally, and dispatching is the only way to figure
      out if a JSP exists -this can only be done once. The same holds for the
      VelocityViewResolver and some others. Check the JavaDoc for the view
      resolver to see if you're dealing with a view resolver that does not
      report non-existing views. As a result of this, putting an
      <code class="literal">InternalResourceViewResolver</code> in the chain in a place
      other than the last, will result in the chain not being fully inspected,
      since the <code class="literal">InternalResourceViewResolver</code> will
      <span class="emphasis"><em>always</em></span> return a view!</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e9984"></a>13.5.3.&nbsp;Redirecting to views</h3></div></div></div><p>As has been mentioned, a controller normally returns a logical
      view name, which a view resolver resolves to a particular view
      technology. For view tehcnologies such as JSPs that are actually
      processed via the Servlet/JSP engine, this is normally handled via
      <code class="literal">InternalResourceViewResolver</code>/<code class="literal">InternalResourceView</code>
      which will ultimately end up issuing an internal forward or include, via
      the Servlet API's <code class="literal">RequestDispatcher.forward()</code> or
      <code class="literal">RequestDispatcher.include()</code>. For other view
      technologies, such as Velocity, XSLT, etc., the view itself produces the
      content on the response stream.</p><p>It is sometimes desireable to issue an HTTP redirect back to the
      client, before the view is rendered. This is desireable for example when
      one controller has been called with POSTed data, and the response is
      actually a delegation to another controller (for example on a successful
      form submission). In this case, a normal internal forward will mean the
      other controller will also see the same POST data, whih is potentially
      problematic if it can confuse it with other expected data Another reason
      to do a redirect before displaying the result is that this will
      eliminate the possiblity of the user doing a double submission of form
      data. The browser will have sent the initial POST, will have seen a
      redirect back and done a subsequent GET because of that, and thus as far
      as it is concerned, the current page does not reflect the result of a
      POST, but rather of a GET, so there is no way the user can accidentally
      re-POST the same data by doing a refresh. The refresh would just force a
      GET of the result page, not a resend of the initial POST data.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e10003"></a>13.5.3.1.&nbsp;<code class="literal">RedirectView</code></h4></div></div></div><p>One way to force a redirect as the result of a controller
        response is for the controller to create and return an instance of
        Spring's <code class="literal">RedirectView</code>. In this case,
        <code class="literal">DispatcherServlet</code> will not use the normal view
        resolution mechanism, but rather as it has been given the (redirect)
        view already, will just ask it to do it's work.</p><p>The <code class="literal">RedirectView</code> simply ends up issuing an
        <code class="literal">HttpServletResponse.sendRedirect()</code> call, which will
        come back to the client browser as an HTTP redirect. All model
        attributes are simply exposed as HTTP query parameters. This does mean
        that the model must contain only objects (generally Strings or
        convertible to Strings) which can be readily converted to a
        string-form HTTP query parameter.</p><p>If using RedirectView, and the view is created by the Controller
        itself, it is generally always preferable if the redirect URL at least
        is injected into the Controller, so that it is not baked into the
        controller but rather configured in the context along with view names
        and the like.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e10025"></a>13.5.3.2.&nbsp;The <code class="literal">redirect:</code> prefix</h4></div></div></div><p>While the use of <code class="literal">RedirectView</code> works fine, if
        the controller itself is creating the <code class="literal">RedirectView</code>,
        there is no getting around the fact that the controller is aware that
        a redirection is happening. This is really suboptimal and couples
        things too tightly. The controller should not really care about how
        the response gets handled. It should generally think only in terms of
        view names, that have been injected into it.</p><p>The special redirect: prefix allows this to be achived. If a
        view name is returned which has the prefix redirect:, then
        <code class="literal">UrlBasedViewResolver</code> (and all subclasses) will
        recognize this as a special indication that a redirect is needed. The
        rest of the view name will be treated as the redirect URL.</p><p>The net effect is the same as if the controller had returned a
        <code class="literal">RedirectView</code>, but now the controller itself can
        deal just in terms of logical view names. A logical view name such as
        <code class="literal">redirect:/my/response/controller.html</code> will redirect
        relative to the current servlet context, while a name such as
        <code class="literal">redirect:http://myhost.com/some/arbitrary/path.html</code>
        will redirect to an absolute URL. The important thing is that as long
        is this redirect view name is injected into the controller like any
        other logical view name, the controller is not even aware that
        redirection is happening.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e10055"></a>13.5.3.3.&nbsp;The <code class="literal">forward:</code> prefix</h4></div></div></div><p>It is also possible to use a special forward: prefix for view
        names that will ultimately be resolved by
        <code class="literal">UrlBasedViewResolver</code> and subclasses. All this does
        is create an <code class="literal">InternalResourceView</code> (which ultimately
        does a <code class="literal">RequestDispatcher.forward()</code>) around the rest
        of the view name, which is considered a URL. Therefore, there is never
        any use in using this prefix when using
        <code class="literal">InternalResourceViewResolver</code>/<code class="literal">InternalResourceView</code>
        anyway (for JSPs for example), but it's of potential use when you are
        primarilly using another view technology, but want to still be able to
        in some cases force a forward to happen to a resource to be handled by
        the Servlet/JSP engine. Note that if you need to do this a lot though,
        you may also just chain multiple view resolvers.</p><p>As with the <code class="literal">redirect:</code> prefix, if the view
        name with the prefix is just injected into the controller, the
        controller does not have to be aware that anything special is
        happening in terms of handling the response.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-localeresolver"></a>13.6.&nbsp;Using locales</h2></div></div></div><p>Most parts of Spring's architecture support internationalization,
    just as the Spring web MVC framework does. DispatcherServlet enables you
    to automatically resolve messages using the client's locale. This is done
    with <code class="literal">LocaleResolver</code> objects.</p><p>When a request comes in, the DispatcherServlet looks for a locale
    resolver and if it finds one it tries to use it to set the locale. Using
    the <code class="literal">RequestContext.getLocale()</code> method, you can always
    retrieve the locale that was resolved by the locale resolver.</p><p>Besides the automatic locale resolution, you can also attach an
    interceptor to the handler mapping (see <a href="#mvc-handlermapping-interceptor" title="13.4.3.&nbsp;Adding HandlerInterceptors">Section&nbsp;13.4.3, &#8220;Adding <code class="literal">HandlerInterceptors</code>&#8221;</a> for more information on
    handler mapping interceptors), to change the locale under specific
    circumstances, based on a parameter in the request, for example.</p><p>Locale resolvers and interceptors are all defined in the
    <code class="literal">org.springframework.web.servlet.i18n</code> package, and are
    configured in your application context in the normal way. Here is a
    selection of the locale resolvers included in Spring.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-acceptheader"></a>13.6.1.&nbsp;<code class="literal">AcceptHeaderLocaleResolver</code></h3></div></div></div><p>This locale resolver inspects the
      <code class="literal">accept-language</code> header in the request that was sent
      by the browser of the client. Usually this header field contains the
      locale of the client's operating system.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-cookie"></a>13.6.2.&nbsp;<code class="literal">CookieLocaleResolver</code></h3></div></div></div><p>This locale resolver inspects a Cookie that might exist on the
      client, to see if a locale is specified. If so, it uses that specific
      locale. Using the properties of this locale resolver, you can specify
      the name of the cookie, as well as the maximum age. </p><pre class="programlisting">&lt;bean id="localeResolver"&gt;
    &lt;property name="cookieName"&gt;&lt;value&gt;clientlanguage&lt;/value&gt;&lt;/property&gt;
    &lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;
    &lt;property name="cookieMaxAge"&gt;&lt;value&gt;100000&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p> This is an example of defining a
      CookieLocaleResolver.</p><div class="table"><a name="d0e10123"></a><p class="title"><b>Table&nbsp;13.6.&nbsp;Special beans in the WebApplicationContext</b></p><div class="table-contents"><table summary="Special beans in the WebApplicationContext" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>cookieName</td><td>classname + LOCALE</td><td>The name of the cookie</td></tr><tr><td>cookieMaxAge</td><td>Integer.MAX_INT</td><td>The maximum time a cookie will stay persistent on the
              client. If -1 is specified, the cookie will not be persisted. It
              will only be available until the client shuts down his or her
              browser.</td></tr><tr><td>cookiePath</td><td>/</td><td>Using this parameter, you can limit the visibility of the
              cookie to a certain part of your site. When cookiePath is
              specified, the cookie will only be visible to that path, and the
              paths below it.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-session"></a>13.6.3.&nbsp;<code class="literal">SessionLocaleResolver</code></h3></div></div></div><p>The <code class="literal">SessionLocaleResolver</code> allows you to
      retrieve locales from the session that might be associated with the
      user's request.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-interceptor"></a>13.6.4.&nbsp;<code class="literal">LocaleChangeInterceptor</code></h3></div></div></div><p>You can build in changing of locales using the
      <code class="literal">LocaleChangeInterceptor</code>. This interceptor needs to be
      added to one of the handler mappings (see <a href="#mvc-handlermapping" title="13.4.&nbsp;Handler mappings">Section&nbsp;13.4, &#8220;Handler mappings&#8221;</a>). It will detect a parameter in the
      request and change the locale (it calls <code class="literal">setLocale()</code>
      on the LocaleResolver that also exists in the context). </p><pre class="programlisting">&lt;bean id="localeChangeInterceptor"
      class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
    &lt;property name="paramName"&gt;&lt;value&gt;siteLanguage&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="localeResolver"
      class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/&gt;

&lt;bean id="urlMapping"
      class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
    &lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="localeChangeInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="mappings"&gt;
        &lt;props&gt;
            &lt;prop key="/**/*.view"&gt;someController&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p> All calls to all *.view resources containing a
      parameter named <code class="literal">siteLanguage</code> will now change the
      locale. So a call to
      <code class="literal">http://www.sf.net/home.view?siteLanguage=nl</code> will
      change the site language to Dutch.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-themeresolver"></a>13.7.&nbsp;Using themes</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-themeresolver-introduction"></a>13.7.1.&nbsp;Introduction</h3></div></div></div><p>The <span class="emphasis"><em>theme</em></span> support provided by the Spring web
      MVC framework enables you to further enhance the user experience by
      allowing the look and feel of your application to be
      <span class="emphasis"><em>themed</em></span>. A theme is basically a collection of static
      resources affecting the visual style of the application, typically style
      sheets and images.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-themeresolver-defining"></a>13.7.2.&nbsp;Defining themes</h3></div></div></div><p>When you want to use themes in your web application you'll have to
      setup a <code class="literal">org.springframework.ui.context.ThemeSource</code>.
      The <code class="literal">WebApplicationContext</code> interface extends
      <code class="literal">ThemeSource</code> but delegates its responsabilities to a
      dedicated implementation. By default the delegate will be a
      <code class="literal">org.springframework.ui.context.support.ResourceBundleThemeSource</code>
      that loads properties files from the root of the classpath. If you want
      to use a custom <code class="literal">ThemeSource</code> implementation or if you
      need to configure the basename prefix of the
      <code class="literal">ResourceBundleThemeSource</code>, you can register a bean in
      the application context with the reserved name "themeSource". The web
      application context will automatically detect that bean and start using
      it.</p><p>When using the <code class="literal">ResourceBundleThemeSource</code>, a
      theme is defined in a simple properties file. The properties file lists
      the resources that make up the theme. Here's an example:
      </p><pre class="programlisting">styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg
</pre><p> The keys of the properties are the names used to refer to
      the themed elements from view code. For a JSP this would typically be
      done using the <code class="literal">spring:theme</code> custom tag, which is very
      similar to the <code class="literal">spring:message</code> tag. The following JSP
      fragment uses the theme defined above to customize the look and feel:
      </p><pre class="programlisting">&lt;taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;link rel="stylesheet" href="&lt;spring:theme code="styleSheet"/&gt;" type="text/css"/&gt;
   &lt;/head&gt;
   &lt;body background="&lt;spring:theme code="background"/&gt;"&gt;
      ...
   &lt;/body&gt;
&lt;/html&gt;
</pre><p>By default, the <code class="literal">ResourceBundleThemeSource</code> uses
      an empty basename prefix. As a result the properties files will be
      loaded from the root of the classpath, so we'll have to put our
      <code class="literal">cool.properties</code> theme definition in a directory at
      the root of the classpath, e.g. in <code class="literal">/WEB-INF/classes</code>.
      Note that the <code class="literal">ResourceBundleThemeSource</code> uses the
      standard Java resource bundle loading mechanism, allowing for full
      internationalisation of themes. For instance, we could have a
      <code class="literal">/WEB-INF/classes/cool_nl.properties</code> that references a
      special background image, e.g. with Dutch text on it.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-themeresolver-resolving"></a>13.7.3.&nbsp;Theme resolvers</h3></div></div></div><p>Now that we have our themes defined, the only thing left to do is
      decide which theme to use. The <code class="literal">DispatcherServlet</code> will
      look for a bean named "themeResolver" to find out which
      <code class="literal">ThemeResolver</code> implementation to use. A theme resolver
      works in much the same way as a <code class="literal">LocalResolver</code>. It can
      detect the theme that should be used for a particular request and can
      also alter the request's theme. The following theme resolvers are
      provided by Spring:</p><div class="table"><a name="d0e10276"></a><p class="title"><b>Table&nbsp;13.7.&nbsp;ThemeResolver implementations</b></p><div class="table-contents"><table summary="ThemeResolver implementations" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td>FixedThemeResolver</td><td>Selects a fixed theme, set using the "defaultThemeName"
              property.</td></tr><tr><td>SessionThemeResolver</td><td>The theme is maintained in the users HTTP session. It
              only needs to be set once for each session, but is not persisted
              between sessions.</td></tr><tr><td>CookieThemeResolver</td><td>The selected theme is stored in a cookie on the client's
              machine.</td></tr></tbody></table></div></div><br class="table-break"><p>Spring also provides a <code class="literal">ThemeChangeInterceptor</code>,
      which allows changing the theme on every request by including a simple
      request parameter.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-multipart"></a>13.8.&nbsp;Spring's multipart (fileupload) support</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-introduction"></a>13.8.1.&nbsp;Introduction</h3></div></div></div><p>Spring has built-in multipart support to handle fileuploads in web
      applications. The design for the multipart support is done with
      pluggable <code class="literal">MultipartResolver</code> objects, defined in the
      <code class="literal">org.springframework.web.multipart</code> package. Out of the
      box, Spring provides <code class="literal">MultipartResolver</code>s for use with
      <span class="emphasis"><em>Commons FileUpload</em></span> (<a href="http://jakarta.apache.org/commons/fileupload" target="_top">http://jakarta.apache.org/commons/fileupload</a>) and
      <span class="emphasis"><em>COS FileUpload</em></span> (<a href="http://www.servlets.com/cos" target="_top">http://www.servlets.com/cos</a>). How uploading files is
      supported will be described in the rest of this chapter.</p><p>By default, no multipart handling will be done by Spring, as some
      developers will want to handle multiparts themselves. You will have to
      enable it yourself by adding a multipart resolver to the web
      application's context. After you have done that, each request will be
      inspected to see if it contains a multipart. If no multipart is found,
      the request will continue as expected. However, if a multipart is found
      in the request, the MultipartResolver that has been declared in your
      context will be used. After that, the multipart attribute in your
      request will be treated like any other attribute.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-resolver"></a>13.8.2.&nbsp;Using the <code class="literal">MultipartResolver</code></h3></div></div></div><p>The following example shows how to use the
      <code class="literal">CommonsMultipartResolver</code>: </p><pre class="programlisting">&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;

    &lt;!-- one of the properties available; the maximum file size in bytes --&gt;
    &lt;property name="maxUploadSize"&gt;
        &lt;value&gt;100000&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p> This is an example using the
      <code class="literal">CosMultipartResolver</code>: </p><pre class="programlisting">&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.cos.CosMultipartResolver"&gt;

    &lt;!-- one of the properties available; the maximum file size in bytes --&gt;
    &lt;property name="maxUploadSize"&gt;
        &lt;value&gt;100000&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Of course you need to stick the appropriate jars in your classpath
      for the multipart resolver to work. In the case of the
      CommonsMultipartResolver, you need to use
      <code class="literal">commons-fileupload.jar</code>, while in the case of the
      CosMultipartResolver, use <code class="literal">cos.jar</code>.</p><p>Now that you have seen how to set Spring up to handle multipart
      requests, let's talk about how to actually use it. When the Spring
      DispatcherServlet detects a Multipart request, it activates the resolver
      that has been declared in your context and hands over the request. What
      it basically does is wrap the current
      <code class="literal">HttpServletRequest</code> into a
      <code class="literal">MultipartHttpServletRequest</code> that has support for
      multiparts. Using the MultipartHttpServletRequest you can get
      information about the multiparts contained by this request and actually
      get the multiparts themselves in your controllers.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-forms"></a>13.8.3.&nbsp;Handling a fileupload in a form</h3></div></div></div><p>After the MultipartResolver has finished doing its job, the
      request will be processed like any other. To use it, you create a form
      with an upload field, then let Spring bind the file on your form. Just
      as with any other property that's not automagically convertible to a
      String or primitive type, to be able to put binary data in your beans
      you have to register a custom editor with the
      <code class="literal">ServletRequestDatabinder</code>. There are a couple of
      editors available for handling files and setting the results on a bean.
      There's a <code class="literal">StringMultipartEditor</code> capable of converting
      files to Strings (using a user-defined character set) and there is a
      <code class="literal">ByteArrayMultipartEditor</code> which converts files to byte
      arrays. They function just as the <code class="literal">CustomDateEditor</code>
      does.</p><p>So, to be able to upload files using a form in a website, declare
      the resolver, a url mapping to a controller that will process the bean,
      and the controller itself. </p><pre class="programlisting">&lt;beans&gt;

    ...

    &lt;bean id="multipartResolver"
        class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/&gt;

    &lt;bean id="urlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;props&gt;
                &lt;prop key="/upload.form"&gt;fileUploadController&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="fileUploadController" class="examples.FileUploadController"&gt;
        &lt;property name="commandClass"&gt;&lt;value&gt;examples.FileUploadBean&lt;/value&gt;&lt;/property&gt;
        &lt;property name="formView"&gt;&lt;value&gt;fileuploadform&lt;/value&gt;&lt;/property&gt;
        &lt;property name="successView"&gt;&lt;value&gt;confirmation&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>After that, create the controller and the actual bean to hold the
      file property </p><pre class="programlisting">// snippet from FileUploadController
public class FileUploadController extends SimpleFormController {

    protected ModelAndView onSubmit(
        HttpServletRequest request,
        HttpServletResponse response,
        Object command,
        BindException errors)
        throws ServletException, IOException {

        // cast the bean
        FileUploadBean bean = (FileUploadBean)command;

        // let's see if there's content there
        byte[] file = bean.getFile();
        if (file == null) {
            // hmm, that's strange, the user did not upload anything
        }

        // well, let's do nothing with the bean for now and return:
        return super.onSubmit(request, response, command, errors);
    }

    protected void initBinder(
        HttpServletRequest request,
        ServletRequestDataBinder binder)
        throws ServletException {
        // to actually be able to convert Multipart instance to byte[]
        // we have to register a custom editor (in this case the
        // ByteArrayMultipartEditor
        binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());
        // now Spring knows how to handle multipart object and convert them
    }

}

// snippet from FileUploadBean
public class FileUploadBean {
    private byte[] file;

    public void setFile(byte[] file) {
        this.file = file;
    }

    public byte[] getFile() {
        return file;
    }
}</pre><p> As you can see, the FileUploadBean has a property typed
      byte[] that holds the file. The controller registers a custom editor to
      let Spring know how to actually convert the multipart objects the
      resolver has found to properties specified by the bean. In these
      examples, nothing is done with the byte[] property of the bean itself,
      but in practice you can do whatever you want (save it in a database,
      mail it to somebody, etc).</p><p>But we're still not finished. To actually let the user upload
      something, we have to create a form: </p><pre class="programlisting">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Upload a file please&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Please upload a file&lt;/h1&gt;
        &lt;form method="post" action="upload.form" enctype="multipart/form-data"&gt;
            &lt;input type="file" name="file"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p> As you can see, we've created a field named
      after the property of the bean that holds the byte[]. Furthermore we've
      added the encoding attribute which is necessary to let the browser know
      how to encode the multipart fields (do not forget this!). Now everything
      should work.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-exceptionhandlers"></a>13.9.&nbsp;Handling exceptions</h2></div></div></div><p>Spring provides <code class="literal">HandlerExceptionResolvers</code> to ease
    the pain of unexpected exceptions occurring while your request is being
    handled by a controller which matched the request.
    <code class="literal">HandlerExceptionResolvers</code> somewhat resemble the
    exception mappings you can define in the web application descriptor
    <code class="literal">web.xml</code>. However, they provide a more flexible way to
    handle exceptions. They provide information about what handler was
    executing when the exception was thrown. Furthermore, a programmatic way
    of handling exception gives you many more options for how to respond
    appropriately before the request is forwarded to another URL (the same end
    result as when using the servlet specific exception mappings).</p><p>Besides implementing the
    <code class="literal">HandlerExceptionResolver</code>, which is only a matter of
    implementing the <code class="literal">resolveException(Exception, Handler)</code>
    method and returning a <code class="literal">ModelAndView</code>, you may also use
    the <code class="literal">SimpleMappingExceptionResolver</code>. This resolver
    enables you to take the class name of any exception that might be thrown
    and map it to a view name. This is functionally equivalent to the
    exception mapping feature from the Servlet API, but it's also possible to
    implement more fine grained mappings of exceptions from different
    handlers.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="view"></a>Chapter&nbsp;14.&nbsp;Integrating view technologies</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-introduction"></a>14.1.&nbsp;Introduction</h2></div></div></div><p>One of the areas in which Spring excels is in the separation of view
    technologies from the rest of the MVC framework. For example, deciding to
    use Velocity or XSLT in place of an existing JSP is primarily a matter of
    configuration. This chapter covers the major view technologies that work
    with Spring and touches briefly on how to add new ones. This chapter
    assumes you are already familiar with <a href="#mvc-viewresolver" title="13.5.&nbsp;Views and resolving them">Section&nbsp;13.5, &#8220;Views and resolving them&#8221;</a>
    which covers the basics of how views in general are coupled to the MVC
    framework.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-jsp"></a>14.2.&nbsp;JSP &amp; JSTL</h2></div></div></div><p>Spring provides a couple of out-of-the-box solutions for JSP and
    JSTL views. Using JSP or JSTL is done using a normal viewresolver defined
    in the WebApplicationContext. Furthermore, of course you need to write
    some JSPs that will actually render the view. This part describes some of
    the additional features Spring provides to facilitate JSP
    development.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-resolver"></a>14.2.1.&nbsp;View resolvers</h3></div></div></div><p>Just as with any other view technology you're integrating with
      Spring, for JSPs you'll need a view resolver that will resolve your
      views. The most commonly used view resolvers when developing with JSPs
      are the <code class="literal">InternalResourceViewResolver</code> and the
      <code class="literal">ResourceBundleViewResolver</code>. Both are declared in the
      WebApplicationContext:</p><pre class="programlisting"># The ResourceBundleViewResolver:
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
  &lt;property name="basename" value="views"/&gt;
&lt;/bean&gt;

# And a sample properties file is uses (views.properties in WEB-INF/classes):
welcome.class=org.springframework.web.servlet.view.JstlView
welcome.url=/WEB-INF/jsp/welcome.jsp

productList.class=org.springframework.web.servlet.view.JstlView
productList.url=/WEB-INF/jsp/productlist.jsp</pre><p>As you can see, the ResourceBundleViewResolver needs a properties
      file defining the view names mapped to 1) a class and 2) a URL. With a
      ResourceBundleViewResolver you can mix different types of views using
      only one resolver.</p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
  &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
  &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
  &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;</pre><p>The InternalResourceBundleViewResolver can be configured for using
      JSPs as described above. As a best practice, we strongly encourage
      placing your JSP files in a a directory under the WEB-INF directory, so
      there can be no direct access by clients.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-jstl"></a>14.2.2.&nbsp;'Plain-old' JSPs versus JSTL</h3></div></div></div><p>When using Java Standard Tag Library you must use a special view
      class, the <code class="literal">JstlView</code>, as JSTL needs some preparation
      before things such as the i18N features will work.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-tags"></a>14.2.3.&nbsp;Additional tags facilitating development</h3></div></div></div><p>Spring provides data binding of request parameters to command
      objects as described in earlier chapters. To facilitate the development
      of JSP pages in combination with those data binding features, Spring
      provides a few tags that make things even easier. All Spring tags have
      <span class="emphasis"><em>html escaping</em></span> features to enable or disable
      escaping of characters.</p><p>The tag library descriptor (TLD) is included in the
      <code class="literal">spring.jar</code> as well in the distribution itself. More
      information about the individual tags can be found online: <a href="http://www.springframework.org/docs/taglib/index.html" target="_top">http://www.springframework.org/docs/taglib/index.html</a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-tiles"></a>14.3.&nbsp;Tiles</h2></div></div></div><p>It is possible to integrate Tiles - just as any other view
    technology - in web applications using Spring. The following describes in
    a broad way how to do this.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tiles-dependencies"></a>14.3.1.&nbsp;Dependencies</h3></div></div></div><p>To be able to use Tiles you have to have a couple of additional
      dependencies included in your project. The following is the list of
      dependencies you need.</p><div class="itemizedlist"><ul type="disc" compact><li><p><code class="literal">Struts version 1.1 or higher</code></p></li><li><p><code class="literal">Commons BeanUtils</code></p></li><li><p><code class="literal">Commons Digester</code></p></li><li><p><code class="literal">Commons Lang</code></p></li><li><p><code class="literal">Commons Logging</code></p></li></ul></div><p>These dependencies are all available in the Spring distribution.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tiles-integrate"></a>14.3.2.&nbsp;How to integrate Tiles</h3></div></div></div><p>To be able to use Tiles, you have to configure it using files
      containing definitions (for basic information on definitions and other
      Tiles concepts, please have a look at <a href="http://jakarta.apache.org/struts" target="_top">http://jakarta.apache.org/struts</a>). In Spring this is done
      using the <code class="literal">TilesConfigurer</code>. Have a look at the
      following piece of example ApplicationContext configuration:
      </p><pre class="programlisting">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles.TilesConfigurer"&gt;
  &lt;property name="factoryClass" value="org.apache.struts.tiles.xmlDefinition.I18nFactorySet"/&gt;
  &lt;property name="definitions"&gt;
    &lt;list&gt;
      &lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>As you can see, there are five files containing definitions, which
      are all located in the WEB-INF/defs directory. At initialization of the
      WebApplicationContext, the files will be loaded and the
      definitionsfactory defined by the
      <code class="literal">factoryClass</code>-property is initialized. After that has
      been done, the tiles includes in the definition files can be used as
      views within your Spring web application. To be able to use the views
      you have to have a <code class="literal">ViewResolver</code> just as with any
      other view technology used with Spring. Below you can find two
      possibilities, the <code class="literal">InternalResourceViewResolver</code> and
      the <code class="literal">ResourceBundleViewResolver</code>.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tiles-internal"></a>14.3.2.1.&nbsp;<code class="literal">InternalResourceViewResolver</code></h4></div></div></div><p>The InternalResourceViewResolver instantiates the given
        <code class="literal">viewClass</code> for each view it has to resolve.
        </p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
  &lt;property name="requestContextAttribute" value="requestContext"/&gt;
  &lt;property name="viewClass" value="org.springframework.web.servlet.view.tiles.TilesView"/&gt;
&lt;/bean&gt;</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tiles-resource"></a>14.3.2.2.&nbsp;<code class="literal">ResourceBundleViewResolver</code></h4></div></div></div><p>The ResourceBundleViewResolver has to be provided with a
        property file containing viewnames and viewclasses the resolver can
        use: </p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
  &lt;property name="basename" value="views"/&gt;
&lt;/bean&gt;</pre><pre class="programlisting">    ...
welcomeView.class=org.springframework.web.servlet.view.tiles.TilesView
welcomeView.url=welcome (&lt;b&gt;this is the name of a definition&lt;/b&gt;)

vetsView.class=org.springframework.web.servlet.view.tiles.TilesView
vetsView.url=vetsView (&lt;b&gt;again, this is the name of a definition&lt;/b&gt;)

findOwnersForm.class=org.springframework.web.servlet.view.JstlView
findOwnersForm.url=/WEB-INF/jsp/findOwners.jsp
...</pre><p> As you can see, when using the
        ResourceBundleViewResolver, you can mix view using different view
        technologies.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-velocity"></a>14.4.&nbsp;Velocity &amp; FreeMarker</h2></div></div></div><p><a href="http://jakarta.apache.org/velocity" target="_top">Velocity</a> and
    <a href="http://www.freemarker.org" target="_top">FreeMarker</a> are two
    templating languages that can both be used as view technologies within
    Spring MVC applications. The languages are quite similar and serve similar
    needs and so are considered together in this section. For semantic and
    syntactic differences between the two languages, see the <a href="http://www.freemarker.org" target="_top">FreeMarker</a> web site.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-dependencies"></a>14.4.1.&nbsp;Dependencies</h3></div></div></div><p>Your web application will need to include
      <code class="literal">velocity-1.x.x.jar</code> or
      <code class="literal">freemarker-2.x.jar</code> in order to work with Velocity or
      FreeMarker respectively and <code class="literal">commons-collections.jar</code>
      needs also to be available for Velocity. Typically they are included in
      the <code class="literal">WEB-INF/lib</code> folder where they are guaranteed to
      be found by a J2EE server and added to the classpath for your
      application. It is of course assumed that you already have the
      <code class="literal">spring.jar</code> in your <code class="literal">WEB-INF/lib</code>
      folder too! The latest stable velocity, freemarker and commons
      collections jars are supplied with the Spring framework and can be
      copied from the relevant <code class="literal">/lib/</code> sub-directories. If
      you make use of Spring's dateToolAttribute or numberToolAttribute in
      your Velocity views, you will also need to include the
      <code class="literal">velocity-tools-generic-1.x.jar</code></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-contextconfig"></a>14.4.2.&nbsp;Context configuration</h3></div></div></div><p>A suitable configuration is initialized by adding the relevant
      configurer bean definition to your *-servlet.xml as shown below:</p><pre class="programlisting">&lt;!--
  This bean sets up the Velocity environment for us based on a root path for templates.
  Optionally, a properties file can be specified for more control over the Velocity
  environment, but the defaults are pretty sane for file based template loading.
--&gt;
&lt;bean id="velocityConfig" class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
  &lt;property name="resourceLoaderPath" value="/WEB-INF/velocity/"/&gt;
&lt;/bean&gt;

&lt;!--
  View resolvers can also be configured with ResourceBundles or XML files. If you need
  different view resolving based on Locale, you have to use the resource bundle resolver.
--&gt;
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt;
  &lt;property name="cache" value="true"/&gt;
  &lt;property name="prefix" value=""/&gt;
  &lt;property name="suffix" value=".vm"/&gt;
&lt;/bean&gt;</pre><pre class="programlisting">&lt;!-- freemarker config --&gt;
&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
  &lt;property name="templateLoaderPath" value="/WEB-INF/freemarker/"/&gt;
&lt;/bean&gt;

&lt;!--
  View resolvers can also be configured with ResourceBundles or XML files. If you need
  different view resolving based on Locale, you have to use the resource bundle resolver.
--&gt;
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt;
  &lt;property name="cache" value="true"/&gt;
  &lt;property name="prefix" value=""/&gt;
  &lt;property name="suffix" value=".ftl"/&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>NB: For non web-apps add a
      <code class="literal">VelocityConfigurationFactoryBean</code> or a
      <code class="literal">FreeMarkerConfigurationFactoryBean</code> to your
      application context definition file.</em></span></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-createtemplates"></a>14.4.3.&nbsp;Creating templates</h3></div></div></div><p>Your templates need to be stored in the directory specified by the
      <code class="literal">*Configurer</code> bean shown above in <a href="#view-velocity-contextconfig" title="14.4.2.&nbsp;Context configuration">Section&nbsp;14.4.2, &#8220;Context configuration&#8221;</a> This document does not cover
      details of creating templates for the two languages - please see their
      relevant websites for information. If you use the view resolvers
      highlighted, then the logical view names relate to the template file
      names in similar fashion to
      <code class="literal">InternalResourceViewResolver</code> for JSP's. So if your
      controller returns a ModelAndView object containing a view name of
      "welcome" then the resolvers will look for the
      <code class="literal">/WEB-INF/freemarker/welcome.ftl</code> or
      <code class="literal">/WEB-INF/velocity/welcome.vm</code> template as
      appropriate.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-advancedconfig"></a>14.4.4.&nbsp;Advanced configuration</h3></div></div></div><p>The basic configurations highlighted above will be suitable for
      most application requirements, however additional configuration options
      are available for when unusual or advanced requirements dictate.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-velocity-example-velocityproperties"></a>14.4.4.1.&nbsp;velocity.properties</h4></div></div></div><p>This file is completely optional, but if specified, contains the
        values that are passed to the Velocity runtime in order to configure
        velocity itself. Only required for advanced configurations, if you
        need this file, specify its location on the
        <code class="literal">VelocityConfigurer</code> bean definition above.</p><pre class="programlisting">&lt;bean id="velocityConfig" class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
  &lt;property name="configLocation value="/WEB-INF/velocity.properties"/&gt;
&lt;/bean&gt;</pre><p>Alternatively, you can specify velocity properties directly in
        the bean definition for the Velocity config bean by replacing the
        "configLocation" property with the following inline properties.</p><pre class="programlisting">&lt;bean id="velocityConfig" class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
  &lt;property name="velocityProperties"&gt;
    &lt;props&gt;
      &lt;prop key="resource.loader"&gt;file&lt;/prop&gt;
      &lt;prop key="file.resource.loader.class"&gt;
        org.apache.velocity.runtime.resource.loader.FileResourceLoader
      &lt;/prop&gt;
      &lt;prop key="file.resource.loader.path"&gt;${webapp.root}/WEB-INF/velocity&lt;/prop&gt;
      &lt;prop key="file.resource.loader.cache"&gt;false&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Refer to the <a href="http://www.springframework.org/docs/api/org/springframework/ui/velocity/VelocityEngineFactory.html" target="_top">API
        documentation</a> for Spring configuration of Velocity, or the
        Velocity documentation for examples and definitions of the
        <code class="literal">velocity.properties</code> file itself.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e10678"></a>14.4.4.2.&nbsp;FreeMarker</h4></div></div></div><p>FreeMarker 'Settings' and 'SharedVariables' can be passed
        directly to the FreeMarker <code class="literal">Configuration</code> object
        managed by Spring by setting the appropriate bean properties on the
        <code class="literal">FreeMarkerConfigurer</code> bean. The
        <code class="literal">freemarkerSettings</code> property requires a
        <code class="literal">java.util.Properties</code> object and the
        <code class="literal">freemarkerVariables</code> property requires a
        <code class="literal">java.util.Map</code>.</p><pre class="programlisting">&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
  &lt;property name="templateLoaderPath" value="/WEB-INF/freemarker/"/&gt;
  &lt;property name="freemarkerVariables"&gt;
    &lt;map&gt;
      &lt;entry key="xml_escape" ref="fmXmlEscape"/&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/&gt;</pre><p>See the FreeMarker documentation for details of settings and
        variables as they apply to the <code class="literal">Configuration</code>
        object.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-forms"></a>14.4.5.&nbsp;Bind support and form handling</h3></div></div></div><p>Spring provides a tag library for use in JSP's that contains
      (amongst other things) a <code class="literal">&lt;spring:bind&gt;</code> tag.
      This tag primarily enables forms to display values from form backing
      objects and to show the results of failed validations from a
      <code class="literal">Validator</code> in the web or business tier. From version
      1.1, Spring now has support for the same functionality in both Velocity
      and FreeMarker, with additional convenience macros for generating form
      input elements themselves.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-velocity-validation"></a>14.4.5.1.&nbsp;the bind macros</h4></div></div></div><p>A standard set of macros are maintained within the
        <code class="literal">spring.jar</code> file for both languages, so they are
        always available to a suitably configured application. However they
        can only be used if your view sets the bean property
        <code class="literal">exposeSpringMacroHelpers</code> to <code class="literal">true</code>
        . The same property can be set on
        <code class="literal">VelocityViewResolver</code> or
        <code class="literal">FreeMarkerViewResolver</code> too if you happen to be
        using it, in which case all of your views will inherit the value from
        it. Note that this property is <span class="bold"><strong>not
        required</strong></span> for any aspect of HTML form handling <span class="bold"><strong>except</strong></span> where you wish to take advantage of the
        Spring macros. Below is an example of a view.properties file showing
        correct configuration of such a view for either language;</p><pre class="programlisting">personFormV.class=org.springframework.web.servlet.view.velocity.VelocityView
personFormV.url=personForm.vm
personFormV.exposeSpringMacroHelpers=true</pre><pre class="programlisting">personFormF.class=org.springframework.web.servlet.view.freemarker.FreeMarkerView
personFormF.url=personForm.ftl
personFormF.exposeSpringMacroHelpers=true</pre><p>Some of the macros defined in the Spring libraries are
        considered internal (private) but no such scoping exists in the macro
        definitions making all macros visible to calling code and user
        templates. The following sections concentrate only on the macros you
        need to be directly calling from within your templates. If you wish to
        view the macro code directly, the files are called spring.vm /
        spring.ftl and are in the packages
        <code class="literal">org.springframework.web.servlet.view.velocity</code> or
        <code class="literal">org.springframework.web.servlet.view.freemarker</code>
        respectively.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-velocity-validationmessages"></a>14.4.5.2.&nbsp;simple binding</h4></div></div></div><p>In your html forms (vm / ftl templates) that act as the
        'formView' for a Spring form controller, you can use code similar to
        the following to bind to field values and display error messages for
        each input field in similar fashion to the JSP equivalent. Note that
        the name of the command object is "command" by default, but can be
        overridden in your MVC configuration by setting the 'commandName' bean
        property on your form controller. Example code is shown below for the
        <code class="literal">personFormV</code> and <code class="literal">personFormF</code>
        views configured earlier;</p><pre class="programlisting">&lt;!-- velocity macros are automatically available --&gt;
&lt;html&gt;
...
&lt;form action="" method="POST"&gt;
  Name: 
  #springBind( "command.name" )
  &lt;input type="text" 
    name="${status.expression}" 
    value="$!status.value" /&gt;&lt;br&gt;
  #foreach($error in $status.errorMessages) &lt;b&gt;$error&lt;/b&gt; &lt;br&gt; #end
  &lt;br&gt;
  ... 
  &lt;input type="submit" value="submit"/&gt;
&lt;/form&gt;
...
&lt;/html&gt;</pre><pre class="programlisting">&lt;!-- freemarker macros have to be imported into a namespace.  We strongly
recommend sticking to 'spring' --&gt;
&lt;#import "spring.ftl" as spring /&gt;
&lt;html&gt;
...
&lt;form action="" method="POST"&gt;
  Name: 
  &lt;@spring.bind "command.name" /&gt; 
  &lt;input type="text" 
    name="${spring.status.expression}" 
    value="${spring.status.value?default("")}" /&gt;&lt;br&gt;
  &lt;#list spring.status.errorMessages as error&gt; &lt;b&gt;${error}&lt;/b&gt; &lt;br&gt; &lt;/#list&gt;
  &lt;br&gt;
  ... 
  &lt;input type="submit" value="submit"/&gt;
&lt;/form&gt;
...
&lt;/html&gt;</pre><p><code class="literal">#springBind</code> /
        <code class="literal">&lt;@spring.bind&gt;</code> requires a 'path' argument
        which consists of the name of your command object (it will be
        'command' unless you changed it in your FormController properties)
        followed by a period and the name of the field on the command object
        you wish to bind to. Nested fields can be used too such as
        "command.address.street". The <code class="literal">bind</code> macro assumes
        the default HTML escaping behavior specified by the ServletContext
        parameter <code class="literal">defaultHtmlEscape</code> in web.xml</p><p>The optional form of the macro called
        <code class="literal">#springBindEscaped</code> /
        <code class="literal">&lt;@spring.bindEscaped&gt;</code> takes a second argument
        and explicitly specifies whether HTML escaping should be used in the
        status error messages or values. Set to true or false as required.
        Additional form handling macros simplify the use of HTML escaping and
        these macros should be used wherever possible. They are explained in
        the next section.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e10793"></a>14.4.5.3.&nbsp;form input generation macros</h4></div></div></div><p>Additional convenience macros for both languages simplify both
        binding and form generation (including validation error display). It
        is never necessary to use these macros to generate form input fields,
        and they can be mixed and matched with simple HTML or calls direct to
        the spring bind macros highlighted previously.</p><p>The following table of available macros show the VTL and FTL
        definitions and the parameter list that each takes.</p><div class="table"><a name="d0e10800"></a><p class="title"><b>Table&nbsp;14.1.&nbsp;table of macro definitions</b></p><div class="table-contents"><table summary="table of macro definitions" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="center">macro</th><th align="center">VTL definition</th><th align="center">FTL definition</th></tr></thead><tbody><tr><td align="left"><span class="bold"><strong>message</strong></span> (output a
                string from a resource bundle based on the code
                parameter)</td><td><code class="literal">#springMessage($code)</code></td><td><code class="literal">&lt;@spring.message
                code/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>messageText</strong></span> (output a
                string from a resource bundle based on the code parameter,
                falling back to the value of the default parameter)</td><td><code class="literal">#springMessageText($code
                $default)</code></td><td><code class="literal">&lt;@spring.messageText code,
                default/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>url</strong></span> (prefix a relative
                URL with the application's context root)</td><td><code class="literal">#springUrl($relativeUrl)</code></td><td><code class="literal">&lt;@spring.url
                relativeUrl/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>formInput</strong></span> (standard
                input field for gathering user input)</td><td><code class="literal">#springFormInput($path
                $attributes)</code></td><td><code class="literal">&lt;@spring.formInput path, attributes,
                fieldType/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>formHiddenInput *</strong></span>
                (hidden input field for submitting non-user input)</td><td><code class="literal">#springFormHiddenInput($path
                $attributes)</code></td><td><code class="literal">&lt;@spring.formHiddenInput path,
                attributes/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>formPasswordInput</strong></span> *
                (standard input field for gathering passwords. Note that no
                value will ever be populated in fields of this type)</td><td><code class="literal">#springFormPasswordInput($path
                $attributes)</code></td><td><code class="literal">&lt;@spring.formPasswordInput path,
                attributes/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>formTextarea</strong></span> (large
                text field for gathering long, freeform text input)</td><td><code class="literal">#springFormTextarea($path
                $attributes)</code></td><td><code class="literal">&lt;@spring.formTextarea path,
                attributes/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>formSingleSelect</strong></span> (drop
                down box of options allowing a single required value to be
                selected)</td><td><code class="literal">#springFormSingleSelect( $path $options
                $attributes)</code></td><td><code class="literal">&lt;@spring.formSingleSelect path, options,
                attributes/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>formMultiSelect</strong></span> (a
                list box of options allowing the user to select 0 or more
                values)</td><td><code class="literal">#springFormMultiSelect($path $options
                $attributes)</code></td><td><code class="literal">&lt;@spring.formMultiSelect path, options,
                attributes/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>formRadioButtons</strong></span> (a
                set of radio buttons allowing a single selection to be made
                from the available choices)</td><td><code class="literal">#springFormRadioButtons($path $options
                $separator $attributes)</code></td><td><code class="literal">&lt;@spring.formRadioButtons path, options
                separator, attributes/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>formCheckboxes</strong></span> (a set
                of checkboxes allowing 0 or more values to be
                selected)</td><td><code class="literal">#springFormCheckboxes($path $options
                $separator $attributes)</code></td><td><code class="literal">&lt;@spring.formCheckboxes path, options,
                separator, attributes/&gt;</code></td></tr><tr><td align="left"><span class="bold"><strong>showErrors</strong></span> (simplify
                display of validation errors for the bound field)</td><td><code class="literal">#springShowErrors($separator
                $classOrStyle)</code></td><td><code class="literal">&lt;@spring.showErrors separator,
                classOrStyle/&gt;</code></td></tr></tbody></table></div></div><br class="table-break"><p>* In FTL (FreeMarker), these two macros are not actually
        required as you can use the normal <code class="literal">formInput</code> macro,
        specifying '<code class="literal">hidden</code>' or
        '<code class="literal">password</code>' as the value for the
        <code class="literal">fieldType</code> parameter.</p><p>The parameters to any of the above macros have consistent
        meanings:</p><div class="itemizedlist"><ul type="disc"><li><p>path: the name of the field to bind to (ie
            "command.name")</p></li><li><p>options: a Map of all the available values that can be
            selected from in the input field. The keys to the map represent
            the values that will be POSTed back from the form and bound to the
            command object. Map objects stored against the keys are the labels
            displayed on the form to the user and may be different from the
            corresponding values posted back by the form. Usually such a map
            is supplied as reference data by the controller. Any Map
            implementation can be used depending on required behavior. For
            strictly sorted maps, a <code class="literal">SortedMap</code> such as a
            <code class="literal">TreeMap</code> with a suitable Comparator may be used
            and for arbitrary Maps that should return values in insertion
            order, use a <code class="literal">LinkedHashMap</code> or a
            <code class="literal">LinkedMap</code> from commons-collections.</p></li><li><p>separator: where multiple options are available as discreet
            elements (radio buttons or checkboxes), the sequence of characters
            used to separate each one in the list (ie "&lt;br&gt;").</p></li><li><p>attributes: an additional string of arbitrary tags or text
            to be included within the HTML tag itself. This string is echoed
            literally by the macro. For example, in a textarea field you may
            supply attributes as 'rows="5" cols="60"' or you could pass style
            information such as 'style="border:1px solid silver"'.</p></li><li><p>classOrStyle: for the showErrors macro, the name of the CSS
            class that the span tag wrapping each error will use. If no
            information is supplied (or the value is empty) then the errors
            will be wrapped in &lt;b&gt;&lt;/b&gt; tags.</p></li></ul></div><p>Examples of the macros are outlined below some in FTL and some
        in VTL. Where usage differences exist between the two languages, they
        are explained in the notes.</p><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e10992"></a>14.4.5.3.1.&nbsp;Input Fields</h5></div></div></div><pre class="programlisting">&lt;!-- the Name field example from above using form macros in VTL --&gt;
...
    Name:
    #springFormInput("command.name" "")&lt;br&gt;
    #springShowErrors("&lt;br&gt;" "")&lt;br&gt;</pre><p>The formInput macro takes the path parameter (command.name)
          and an additional attributes parameter which is empty in the example
          above. The macro, along with all other form generation macros,
          performs an implicit spring bind on the path parameter. The binding
          remains valid until a new bind occurs so the showErrors macro
          doesn't need to pass the path parameter again - it simply operates
          on whichever field a bind was last created for.</p><p>The showErrors macro takes a separator parameter (the
          characters that will be used to separate multiple errors on a given
          field) and also accepts a second parameter, this time a class name
          or style attribute. Note that FreeMarker is able to specify default
          values for the attributes parameter, unlike Velocity, and the two
          macro calls above could be expressed as follows in FTL:</p><pre class="programlisting">&lt;@spring.formInput "command.name"/&gt;
&lt;@spring.showErrors "&lt;br&gt;"/&gt;</pre><p>Output is shown below of the form fragment generating the name
          field, and displaying a validation error after the form was
          submitted with no value in the field. Validation occurs through
          Spring's Validation framework.</p><p>The generated HTML looks like this:</p><pre class="programlisting">Name:
  &lt;input type="text" name="name" value=""     
&gt;
&lt;br&gt;
  &lt;b&gt;required&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;</pre><p>The formTextarea macro works the same way as the formInput
          macro and accepts the same parameter list. Commonly, the second
          parameter (attributes) will be used to pass style information or
          rows and cols attributes for the textarea.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e11012"></a>14.4.5.3.2.&nbsp;Selection Fields</h5></div></div></div><p>Four selection field macros can be used to generate common UI
          value selection inputs in your HTML forms.</p><div class="itemizedlist"><ul type="disc"><li><p>formSingleSelect</p></li><li><p>formMultiSelect</p></li><li><p>formRadioButtons</p></li><li><p>formCheckboxes</p></li></ul></div><p>Each of the four macros accepts a Map of options containing
          the value for the form field, and the label corresponding to that
          value. The value and the label can be the same.</p><p>An example of radio buttons in FTL is below. The form backing
          object specifies a default value of 'London' for this field and so
          no validation is necessary. When the form is rendered, the entire
          list of cities to choose from is supplied as reference data in the
          model under the name 'cityMap'.</p><pre class="programlisting">...
  Town:
  &lt;@spring.formRadioButtons "command.address.town", cityMap, "" /&gt;&lt;br&gt;&lt;br&gt;</pre><p>This renders a line of radio buttons, one for each value in
          <code class="literal">cityMap</code> using the separator "". No additional
          attributes are supplied (the last parameter to the macro is
          missing). The cityMap uses the same String for each key-value pair
          in the map. The map's keys are what the form actually submits as
          POSTed request parameters, map values are the labels that the user
          sees. In the example above, given a list of three well known cities
          and a default value in the form backing object, the HTML would
          be</p><pre class="programlisting">Town:
&lt;input type="radio" name="address.town" value="London"
   
&gt;
London
&lt;input type="radio" name="address.town" value="Paris"
  checked="checked" 
&gt;
Paris
&lt;input type="radio" name="address.town" value="New York"
   
&gt;
New York</pre><p>If your application expects to handle cities by internal codes
          for example, the map of codes would be created with suitable keys
          like the example below.</p><pre class="programlisting">protected Map referenceData(HttpServletRequest request) throws Exception {
  Map cityMap = new LinkedHashMap();
  cityMap.put("LDN", "London");
  cityMap.put("PRS", "Paris");
  cityMap.put("NYC", "New York");
  
  Map m = new HashMap();
  m.put("cityMap", cityMap);
  return m;
}</pre><p>The code would now produce output where the radio values are
          the relevant codes but the user still sees the more user friendly
          city names.</p><pre class="programlisting">Town:
&lt;input type="radio" name="address.town" value="LDN"
   
&gt;
London
&lt;input type="radio" name="address.town" value="PRS"
  checked="checked" 
&gt;
Paris
&lt;input type="radio" name="address.town" value="NYC"
   
&gt;
New York</pre></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e11051"></a>14.4.5.4.&nbsp;Overriding HTML escaping and making tags XHTML
        compliant</h4></div></div></div><p>Default usage of the form macros above will result in HTML tags
        that are HTML 4.01 compliant and that use the default value for HTML
        escaping defined in your web.xml as used by Spring's bind support. In
        order to make the tags XHTML compliant or to override the default HTML
        escaping value, you can specify two variables in your template (or in
        your model where they will be visible to your templates). The
        advantage of specifying them in the templates is that they can be
        changed to different values later in the template processing to
        provide different behavior for different fields in your form.</p><p>To switch to XHTML compliance for your tags, specify a value of
        'true' for a model/context variable named xhtmlCompliant:</p><pre class="programlisting">## for Velocity..
#set($springXhtmlCompliant = true)

&lt;#-- for FreeMarker --&gt;
&lt;#assign xhtmlCompliant = true in spring&gt;</pre><p>Any tags generated by the Spring macros will now be XHTML
        compliant after processing this directive.</p><p>In similar fashion, HTML escaping can be specified per
        field:</p><pre class="programlisting">&lt;#-- until this point, default HTML escaping is used --&gt;

&lt;#assign htmlEscape = true in spring&gt;
&lt;#-- next field will use HTML escaping --&gt;
&lt;@spring.formInput "command.name" /&gt;

&lt;#assign htmlEscape = false in spring&gt;
&lt;#-- all future fields will be bound with HTML escaping off --&gt;</pre></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-xslt"></a>14.5.&nbsp;XSLT</h2></div></div></div><p>XSLT is a transformation language for XML and is popular as a view
    technology within web applications. XSLT can be a good choice as a view
    technology if your application naturally deals with XML, or if your model
    can easily be converted to XML. The following section shows how to produce
    an XML document as model data and have it transformed with XSLT in a
    Spring application.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-xslt-firstwords"></a>14.5.1.&nbsp;My First Words</h3></div></div></div><p>This example is a trivial Spring application that creates a list
      of words in the Controller and adds them to the model map. The map is
      returned along with the view name of our XSLT view. See <a href="#mvc-controller" title="13.3.&nbsp;Controllers">Section&nbsp;13.3, &#8220;Controllers&#8221;</a> for details of Spring
      <code class="literal">Controller</code>s. The XSLT view will turn the list of
      words into a simple XML document ready for transformation.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-beandefs"></a>14.5.1.1.&nbsp;Bean definitions</h4></div></div></div><p>Configuration is standard for a simple Spring application. The
        dispatcher servlet config file contains a reference to a
        <code class="literal">ViewResolver</code>, URL mappings and a single controller
        bean.. </p><pre class="programlisting">&lt;bean id="homeController"class="xslt.HomeController"/&gt; </pre><p>
        ..that implements our word generation 'logic'.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-controllercode"></a>14.5.1.2.&nbsp;Standard MVC controller code</h4></div></div></div><p>The controller logic is encapsulated in a subclass of
        AbstractController, with the handler method being defined like so..
        </p><pre class="programlisting">protected ModelAndView handleRequestInternal(
    HttpServletRequest req,
    HttpServletResponse resp)
    throws Exception {
        
    Map map = new HashMap();
    List wordList = new ArrayList();
        
    wordList.add("hello");
    wordList.add("world");
       
    map.put("wordList", wordList);
      
    return new ModelAndView("home", map);
} </pre><p>So far we've done nothing that's XSLT specific. The model data
        has been created in the same way as you would for any other Spring MVC
        application. Depending on the configuration of the application now,
        that list of words could be rendered by JSP/JSTL by having them added
        as request attributes, or they could be handled by Velocity by adding
        the object to the VelocityContext. In order to have XSLT render them,
        they of course have to be converted into an XML document somehow.
        There are software packages available that will automatically 'domify'
        an object graph, but within Spring, you have complete flexibility to
        create the DOM from your model in any way you choose. This prevents
        the transformation of XML playing too great a part in the structure of
        your model data which is a danger when using tools to manage the
        domification process.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-subclassing"></a>14.5.1.3.&nbsp;Convert the model data to XML</h4></div></div></div><p>In order to create a DOM document from our list of words or any
        other model data, we subclass
        <code class="literal">org.springframework.web.servlet.view.xslt.AbstractXsltView</code>.
        In doing so, we must implement the abstract method
        <code class="literal">createDomNode()</code>. The first parameter passed to this
        method is our model Map. Here's the complete listing of the HomePage
        class in our trivial word application - it uses JDOM to build the XML
        document before converting it to the required W3C Node, but this is
        simply because I find JDOM (and Dom4J) easier API's to handle than the
        W3C API. </p><pre class="programlisting">
package xslt;

// imports omitted for brevity

public class HomePage extends AbstractXsltView {

    protected Node createDomNode( 
        Map model, String rootName, HttpServletRequest req, HttpServletResponse res
    ) throws Exception {
        
        org.jdom.Document doc = new org.jdom.Document();
        Element root = new Element(rootName);
        doc.setRootElement(root);

        List words = (List) model.get("wordList");
        for (Iterator it = words.iterator(); it.hasNext();) {
            String nextWord = (String) it.next();
            Element e = new Element("word");
            e.setText(nextWord);
            root.addContent(e);
        }

        // convert JDOM doc to a W3C Node and return
        return new DOMOutputter().output( doc );
    }

}</pre><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e11114"></a>14.5.1.3.1.&nbsp;Adding stylesheet parameters</h5></div></div></div><p>A series of parameter name/value pairs can optionally be
          defined by your subclass which will be added to the transformation
          object. The parameter names must match those defined in your XSLT
          template declared with <code class="literal">&lt;xsl:param
          name="myParam"&gt;defaultValue&lt;/xsl:param&gt;</code> To
          specify the parameters, override the method
          <code class="literal">getParameters()</code> from AbstractXsltView and return
          a <code class="literal">Map</code> of the name/value pairs. If your parameters
          need to derive information from the current request, you can (from
          version 1.1) override the <code class="literal">getParameters(HttpServletRequest
          request)</code> method instead.</p></div><div class="sect4" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="view-xslt-formathelper"></a>14.5.1.3.2.&nbsp;Formatting dates and currency</h5></div></div></div><p>Unlike JSTL and Velocity, XSLT has relatively poor support for
          locale based currency and date formatting. In recognition of the
          fact, Spring provides a helper class that you can use from within
          your <code class="literal">createDomNode()</code> methods to get such support.
          See the javadocs for
          <code class="literal">org.springframework.web.servlet.view.xslt.FormatHelper</code></p></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-viewdefinitions"></a>14.5.1.4.&nbsp;Defining the view properties</h4></div></div></div><p>The views.properties file (or equivalent xml definition if
        you're using an XML based view resolver as we did in the Velocity
        examples above) looks like this for the one-view application that is
        'My First Words'.. </p><pre class="programlisting">home.class=xslt.HomePage
home.stylesheetLocation=/WEB-INF/xsl/home.xslt
home.root=words</pre><p> Here, you can see how the view is tied in
        with the HomePage class just written which handles the model
        domification in the first property '.class'. The stylesheetLocation
        property obviously points to the XSLT file which will handle the XML
        transformation into HTML for us and the final property '.root' is the
        name that will be used as the root of the XML document. This gets
        passed to the HomePage class above in the second parameter to the
        <code class="literal">createDomNode</code> method.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-transforming"></a>14.5.1.5.&nbsp;Document transformation</h4></div></div></div><p>Finally, we have the XSLT code used for transforming the above
        document. As highlighted in the views.properties file, it is called
        <code class="literal">home.xslt</code> and it lives in the war file under
        <code class="literal">WEB-INF/xsl</code>. </p><pre class="programlisting">&lt;?xml version="1.0"?&gt;

&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
    &lt;xsl:output method="text/html" omit-xml-declaration="yes"/&gt;

    &lt;xsl:template match="/"&gt;
        &lt;html&gt;
            &lt;head&gt;&lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;
            &lt;body&gt;

                &lt;h1&gt;My First Words&lt;/h1&gt;
                &lt;xsl:for-each select="wordList/word"&gt;
                    &lt;xsl:value-of select="."/&gt;&lt;br /&gt;
                &lt;/xsl:for-each&gt; 

            &lt;/body&gt;
        &lt;/html&gt;
    &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-xslt-summary"></a>14.5.2.&nbsp;Summary</h3></div></div></div><p>A summary of the files discussed and their location in the WAR
      file is shown in the simplified WAR structure below. </p><pre class="programlisting">ProjectRoot
  |
  +- WebContent
      |
      +- WEB-INF
          |
          +- classes
          |    |
          |    +- xslt
          |    |   |
          |    |   +- HomePageController.class 
          |    |   +- HomePage.class
          |    |
          |    +- views.properties
          |
          +- lib
          |   |
          |   +- spring.jar
          |
          +- xsl
          |   |
          |   +- home.xslt
          |
          +- frontcontroller-servlet.xml</pre><p> You will also need
      to ensure that an XML parser and an XSLT engine are available on the
      classpath. JDK 1.4 provides them by default, and most J2EE containers
      will also make them available by default, but it's a possible source of
      errors to be aware of.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-document"></a>14.6.&nbsp;Document views (PDF/Excel)</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-document-intro"></a>14.6.1.&nbsp;Introduction</h3></div></div></div><p>Returning an HTML page isn't always the best way for the user to
      view the model output, and Spring makes it simple to generate a PDF
      document or an Excel spreadsheet dynamically from the model data. The
      document is the view and will be streamed from the server with the
      correct content type to (hopefully) enable the client PC to run their
      spreadsheet or PDF viewer application in response.</p><p>In order to use Excel views, you need to add the 'poi' library to
      your classpath, and for PDF generation, the iText.jar. Both are included
      in the main Spring distribution.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-document-config"></a>14.6.2.&nbsp;Configuration and setup</h3></div></div></div><p>Document based views are handled in an almost identical fashion to
      XSLT views, and the following sections build upon the previous one by
      demonstrating how the same controller used in the XSLT example is
      invoked to render the same model as both a PDF document and an Excel
      spreadsheet (which can also be viewed or manipulated in Open
      Office).</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configviews"></a>14.6.2.1.&nbsp;Document view definitions</h4></div></div></div><p>Firstly, let's amend the views.properties file (or xml
        equivalent) and add a simple view definition for both document types.
        The entire file now looks like this with the XSLT view shown from
        earlier.. </p><pre class="programlisting">home.class=xslt.HomePage
home.stylesheetLocation=/WEB-INF/xsl/home.xslt
home.root=words

xl.class=excel.HomePage

pdf.class=pdf.HomePage</pre><p> <span class="emphasis"><em>If you want to start with a
        template spreadsheet to add your model data to, specify the location
        as the 'url' property in the view definition</em></span></p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configcontroller"></a>14.6.2.2.&nbsp;Controller code</h4></div></div></div><p>The controller code we'll use remains exactly the same from the
        XSLT example earlier other than to change the name of the view to use.
        Of course, you could be clever and have this selected based on a URL
        parameter or some other logic - proof that Spring really is very good
        at decoupling the views from the controllers!</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configsubclasses"></a>14.6.2.3.&nbsp;Subclassing for Excel views</h4></div></div></div><p>Exactly as we did for the XSLT example, we'll subclass suitable
        abstract classes in order to implement custom behavior in generating
        our output documents. For Excel, this involves writing a subclass of
        <code class="literal">org.springframework.web.servlet.view.document.AbstractExcelView</code>
		(for Excel files generated by POI)
			or <code class="literal">org.springframework.web.servlet.view.document.AbstractJExcelView</code>
		(for JExcelApi-generated Excel files).
        and implementing the <code class="literal">buildExcelDocument</code></p><p>Here's the complete listing for our POI Excel view which displays
        the word list from the model map in consecutive rows of the first
        column of a new spreadsheet.. </p><pre class="programlisting">package excel;

// imports omitted for brevity

public class HomePage extends AbstractExcelView {

    protected void buildExcelDocument(
        Map model,
        HSSFWorkbook wb,
        HttpServletRequest req,
        HttpServletResponse resp)
        throws Exception {
    
        HSSFSheet sheet;
        HSSFRow sheetRow;
        HSSFCell cell;

        // Go to the first sheet
        // getSheetAt: only if wb is created from an existing document
        //sheet = wb.getSheetAt( 0 );
        sheet = wb.createSheet("Spring");
        sheet.setDefaultColumnWidth((short)12);

        // write a text at A1
        cell = getCell( sheet, 0, 0 );
        setText(cell,"Spring-Excel test");

        List words = (List ) model.get("wordList");
        for (int i=0; i &lt; words.size(); i++) {
            cell = getCell( sheet, 2+i, 0 );
            setText(cell, (String) words.get(i));

        }
    }
}</pre><p>And this a view generating the same Excel file, now using JExcelApi: </p><pre class="programlisting">package excel;
			
// imports omitted for brevity

public class HomePage extends AbstractExcelView {

    protected void buildExcelDocument(Map model,
        WritableWorkbook wb,
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception {
			
        WritableSheet sheet = wb.createSheet("Spring");

        sheet.addCell(new Label(0, 0, "Spring-Excel test");
		
        List words  = (List)model.get("wordList");
        for (int i = -; i &lt; words.size(); i++) {
            sheet.addCell(new Label(2+i, 0, (String)words.get(i));
        }
    }
}
</pre><p>			
		</p><p>Note the differences between the APIs. We've found that the
		JExcelApi is somewhat more intuitive and furthermore, JExcelApi
		has a bit better image-handling capabilities. There have been 
		memory problems with large Excel file when using JExcelApi however.</p><p>If you now amend the controller such that it returns
        <code class="literal">xl</code> as the name of the view (<code class="literal">return new
        ModelAndView("xl", map);</code>) and run your application again,
        you should find that the Excel spreadsheet is created and downloaded
        automatically when you request the same page as before.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configsubclasspdf"></a>14.6.2.4.&nbsp;Subclassing for PDF views</h4></div></div></div><p>The PDF version of the word list is even simpler. This time, the
        class extends
        <code class="literal">org.springframework.web.servlet.view.document.AbstractPdfView</code>
        and implements the <code class="literal">buildPdfDocument()</code> method as
        follows.. </p><pre class="programlisting">package pdf;

// imports omitted for brevity

public class PDFPage extends AbstractPdfView {

    protected void buildPdfDocument(
        Map model,
        Document doc,
        PdfWriter writer,
        HttpServletRequest req,
        HttpServletResponse resp)
        throws Exception {
        
        List words = (List) model.get("wordList");
        
        for (int i=0; i&lt;words.size(); i++)
            doc.add( new Paragraph((String) words.get(i)));
    
    }
}</pre><p> Once again, amend the controller to return the
        <code class="literal">pdf</code> view with a <code class="literal">return new
        ModelAndView("pdf", map);</code> and reload the URL in your
        application. This time a PDF document should appear listing each of
        the words in the model map.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-jasper-reports"></a>14.7.&nbsp;JasperReports</h2></div></div></div><p>JasperReports (<a href="http://jasperreports.sourceforge.net" target="_top">http://jasperreports.sourceforge.net</a>) is a powerful,
    open-source reporting engine that supports the creation of report designs
    using an easily understood XML file formats. JasperReports is capable of
    rendering reports output into four different formats: CSV, Excel, HTML and
    PDF.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-dependencies"></a>14.7.1.&nbsp;Dependencies</h3></div></div></div><p>Your application will need to include the latest release of
      JasperReports, which at the time of writing was 0.6.1. JasperReports
      itself depends on the following projects:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>BeanShell</p></li><li style="list-style-type: disc"><p>Commons BeanUtils</p></li><li style="list-style-type: disc"><p>Commons Collections</p></li><li style="list-style-type: disc"><p>Commons Digester</p></li><li style="list-style-type: disc"><p>Commons Logging</p></li><li style="list-style-type: disc"><p>iText</p></li><li style="list-style-type: disc"><p>POI</p></li></ul></div><p>JasperReports also requires a JAXP compliant XML parser.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-configuration"></a>14.7.2.&nbsp;Configuration</h3></div></div></div><p>To configure JasperReports views in your
      <code class="literal">ApplicationContext</code> you have to define a
      <code class="literal">ViewResolver</code> to map view names to the appropriate
      view class depending on which format you want your report rendered
      in.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-resolver"></a>14.7.2.1.&nbsp;Configuring the <code class="literal">ViewResolver</code></h4></div></div></div><p>Typically, you will use the
        <code class="literal">ResourceBundleViewResolver</code> to map view names to
        view classes and files in a properties file </p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename" value="views"/&gt;
&lt;/bean&gt;
                  </pre><p>Here we've configured an instance of
        <code class="literal">ResourceBundleViewResolver</code> which will look for view
        mappings in the resource bundle with base name
        <code class="literal">views</code>. The exact contents of this file is described
        in the next section.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-views"></a>14.7.2.2.&nbsp;Configuring the <code class="literal">View</code>s</h4></div></div></div><p>Spring contains five different View implementations for
        JasperReports four of which corresponds to one of the four output
        formats supported by JasperReports and one that allows for the format
        to be determined at runtime:</p><div class="table"><a name="view-jasper-reports-configuration-views-classes"></a><p class="title"><b>Table&nbsp;14.2.&nbsp;JasperReports <code class="literal">View</code> Classes</b></p><div class="table-contents"><table summary="JasperReports View Classes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class Name</th><th>Render Format</th></tr></thead><tbody><tr><td><code class="literal">JasperReportsCsvView</code></td><td>CSV</td></tr><tr><td><code class="literal">JasperReportsHtmlView</code></td><td>HTML</td></tr><tr><td><code class="literal">JasperReportsPdfView</code></td><td>PDF</td></tr><tr><td><code class="literal">JasperReportsXlsView</code></td><td>Microsoft Excel</td></tr><tr><td><code class="literal">JasperReportsMultiFormatView</code></td><td>Decided at runtime (see <a href="#view-jasper-reports-configuration-multiformat-view" title="14.7.2.4.&nbsp;Using JasperReportsMultiFormatView">Section&nbsp;14.7.2.4, &#8220;Using <code class="literal">JasperReportsMultiFormatView</code>&#8221;</a>)</td></tr></tbody></table></div></div><br class="table-break"><p>Mapping one of these classes to a view name and a report file is
        simply a matter of adding the appropriate entries into the resource
        bundle configured in the previous section as shown here:</p><pre class="programlisting">simpleReport.class=org.springframework.web.servlet.view.jasperreports.JasperReportsPdfView
simpleReport.url=/WEB-INF/reports/DataSourceReport.jasper
              </pre><p>Here you can see that the view with name,
        <code class="literal">simpleReport</code>, is mapped to the
        <code class="literal">JasperReportsPdfView</code> class. This will cause the
        output of this report to be rendered in PDF format. The
        <code class="literal">url</code> property of the view is set to the location of
        the underlying report file.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-report-files"></a>14.7.2.3.&nbsp;About Report Files</h4></div></div></div><p>JasperReports has two distinct types of report file: the design
        file, which has a <code class="literal">.jrxml</code> extension, and the
        compiled report file, which has a <code class="literal">.jasper</code>
        extension. Typically, you use the JasperReports Ant task to compile
        your <code class="literal">.jrxml</code> design file into a
        <code class="literal">.jasper</code> file before deploying it into your
        application. With Spring you can map either of these files to your
        report file and Spring will take care of compiling the
        <code class="literal">.jrxml</code> file on the fly for you. You should note
        that after a <code class="literal">.jrxml</code> file is compiled by Spring, the
        compiled report is cached for the life of the application. To make
        changes to the file you will need to restart your application.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-multiformat-view"></a>14.7.2.4.&nbsp;Using <code class="literal">JasperReportsMultiFormatView</code></h4></div></div></div><p>The <code class="literal">JasperReportsMultiFormatView</code> allows for
        report format to be specified at runtime. The actual rendering of the
        report is delegated to one of the other JasperReports view classes -
        the <code class="literal">JasperReportsMultiFormatView</code> class simply adds
        a wrapper layer that allows for the exact implementation to be
        specified at runtime.</p><p>The <code class="literal">JasperReportsMultiFormatView</code> class
        introduces two concepts: the format key and the discriminator key. The
        <code class="literal">JasperReportsMultiFormatView</code> class uses the mapping
        key to lookup the actual view implementation class and uses the format
        key to lookup up the mapping key. From a coding perspective you add an
        entry to your model with the formay key as the key and the mapping key
        as the value, for example:</p><pre class="programlisting">public ModelAndView handleSimpleReportMulti(HttpServletRequest request,
HttpServletResponse response) throws Exception {

  String uri = request.getRequestURI();
  String format = uri.substring(uri.lastIndexOf(".") + 1);

  Map model = getModel();
  model.put("format", format);

  return new ModelAndView("simpleReportMulti", model);
}</pre><p>In this example, the mapping key is determined from the
        extension of the request URI and is added to the model under the
        default format key: <code class="literal">format</code>. If you wish to use a
        different format key then you can configure this using the
        <code class="literal">formatKey</code> property of the
        <code class="literal">JasperReportsMultiFormatView</code> class.</p><p>By default the following mapping key mappings are configured in
        <code class="literal">JasperReportsMultiFormatView</code>: </p><div class="table"><a name="view-jasper-reports-configuration-multiformat-view-mappings"></a><p class="title"><b>Table&nbsp;14.3.&nbsp;JasperReportsMultiFormatView Default Mapping Key
            Mappings</b></p><div class="table-contents"><table summary="JasperReportsMultiFormatView Default Mapping Key&#xA;            Mappings" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mapping Key</th><th>View Class</th></tr></thead><tbody><tr><td>csv</td><td><code class="literal">JasperReportsCsvView</code></td></tr><tr><td>html</td><td><code class="literal">JasperReportsHtmlView</code></td></tr><tr><td>pdf</td><td><code class="literal">JasperReportsPdfView</code></td></tr><tr><td>xls</td><td><code class="literal">JasperReportsXlsView</code></td></tr></tbody></table></div></div><p><br class="table-break"> So in the example above a request to URI /foo/myReport.pdf
        would be mapped to the <code class="literal">JasperReportsPdfView</code> class.
        You can override the mapping key to view class mappings using the
        <code class="literal">formatMappings</code> property of
        <code class="literal">JasperReportsMultiFormatView</code>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-model"></a>14.7.3.&nbsp;Populating the <code class="literal">ModelAndView</code></h3></div></div></div><p>In order to render your report correctly in the format you have
      chosen, you must supply Spring with all of the data needed to populate
      your report. For JasperReports this means you must pass in all report
      parameters along with the report datasource. Report parameters are
      simple name/value pairs and can be added be to the
      <code class="literal">Map</code> for your model as you would add any name/value
      pair.</p><p>When adding the datasource to the model you have two approaches to
      choose from. The first approach is to add an instance of
      <code class="literal">JRDataSource</code> or <code class="literal">Collection</code> to the
      model <code class="literal">Map</code> under any arbitrary key. Spring will then
      locate this object in the model and treat it as the report datasource.
      For example, you may populate your model like this: </p><pre class="programlisting">private Map getModel() {
  Map model = new HashMap();
  Collection beanData = getBeanData();
  model.put("myBeanData", beanData);
  return model;
}</pre><p>The second approach is to add the instance of
      <code class="literal">JRDataSource</code> or <code class="literal">Collection</code> under a
      specific key and then configure this key using the
      <code class="literal">reportDataKey</code> property of the view class. In both
      cases Spring will instances of <code class="literal">Collection</code> in a
      <code class="literal">JRBeanCollectionDataSource</code> instance. For example:
      </p><pre class="programlisting">private Map getModel() {
  Map model = new HashMap();
  Collection beanData = getBeanData();
  Collection someData = getSomeData();
  model.put("myBeanData", beanData);
  model.put("someData", someData);
  return model;
}</pre><p> Here you can see that two <code class="literal">Collection</code>
      instances are being added to the model. To ensure that the correct one
      is used, we simply modify our view configuration as appropriate:
      </p><pre class="programlisting">simpleReport.class=org.springframework.web.servlet.view.jasperreports.JasperReportsPdfView
simpleReport.url=/WEB-INF/reports/DataSourceReport.jasper
simpleReport.reportDataKey=myBeanData
              </pre><p>Be aware that when using the first approach, Spring will use the
      first instance of <code class="literal">JRDataSource</code> or
      <code class="literal">Collection</code> that it encounters. If you need to place
      multiple instances of <code class="literal">JRDataSource</code> or
      <code class="literal">Collection</code> into the model then you need to use the
      second approach.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-subreports"></a>14.7.4.&nbsp;Working with Sub-Reports</h3></div></div></div><p>JasperReports provides support for embedded sub-reports within
      your master report files. There are a wide variety of mechanisms for
      including sub-reports in your report files. The easiest way is to hard
      code the report path and the SQL query for the sub report into your
      design files. The drawback of this approach is obvious - the values are
      hard-coded into your report files reducing reusability and making it
      harder to modify and update report designs. To overcome this you can
      configure sub-reports declaratively and you can include additional data
      for these sub-reports directly from your controllers.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-subreports-config-reports"></a>14.7.4.1.&nbsp;Configuring Sub-Report Files</h4></div></div></div><p>To control which sub-report files are included in a master
        report using Spring, your report file must be configured to accept
        sub-reports from an external source. To do this you declare a
        parameter in your report file like this: </p><pre class="programlisting">&lt;parameter name="ProductsSubReport" class="net.sf.jasperreports.engine.JasperReport"/&gt;</pre><p>
        Then, you define your sub-report to use this sub-report parameter:
        </p><pre class="programlisting">&lt;subreport&gt;
    &lt;reportElement isPrintRepeatedValues="false" x="5" y="25" width="325"
        height="20" isRemoveLineWhenBlank="true" backcolor="#ffcc99"/&gt;
    &lt;subreportParameter name="City"&gt;
        &lt;subreportParameterExpression&gt;&lt;![CDATA[$F{city}]]&gt;&lt;/subreportParameterExpression&gt;
    &lt;/subreportParameter&gt;
    &lt;dataSourceExpression&gt;&lt;![CDATA[$P{SubReportData}]]&gt;&lt;/dataSourceExpression&gt;
    &lt;subreportExpression class="net.sf.jasperreports.engine.JasperReport"&gt;
                  &lt;![CDATA[$P{ProductsSubReport}]]&gt;&lt;/subreportExpression&gt;
&lt;/subreport&gt;</pre><p> This defines a master report file that
        expects the sub-report to be passed in as an instance of
        <code class="literal">net.sf.jasperreports.engine.JasperReports</code> under the
        parameter <code class="literal">ProductsSubReport</code>. When configuring your
        Jasper view class, you can instruct Spring to load a report file and
        pass into the JasperReports engine as a sub-report using the
        <code class="literal">subReportUrls</code> property: </p><pre class="programlisting">&lt;property name="subReportUrls"&gt;
    &lt;map&gt;
        &lt;entry key="ProductsSubReport" value="/WEB-INF/reports/subReportChild.jrxml"/&gt;
    &lt;/map&gt;
&lt;/property&gt;</pre><p> Here, the key of the <code class="literal">Map</code>
        corresponds to the name of the sub-report parameter in th report
        design file, and the entry is the URL of the report file. Spring will
        load this report file, compiling it if necessary, and will pass into
        the JasperReports engine under the given key.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-subreports-config-datasources"></a>14.7.4.2.&nbsp;Configuring Sub-Report Data Sources</h4></div></div></div><p>This step is entirely optional when using Spring configure your
        sub-reports. If you wish, you can still configure the data source for
        your sub-reports using static queries. However, if you want Spring to
        convert data returned in your <code class="literal">ModelAndView</code> into
        instances of <code class="literal">JRDataSource</code> then you need to specify
        which of the parameters in your <code class="literal">ModelAndView</code> Spring
        should convert. To do this configure the list of parameter names using
        the <code class="literal">subReportDataKeys</code> property of the your chosen
        view class: </p><pre class="programlisting">&lt;property name="subReportDataKeys"
    value="SubReportData"/&gt;</pre><p> Here, the key you supply MUST
        correspond to both the key used in your <code class="literal">ModelAndView</code>
        and the key used in your report design file.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-exporter-parameters"></a>14.7.5.&nbsp;Configuring Exporter Parameters</h3></div></div></div><p>If you have special requirements for exporter configuration -
      perhaps you want a specific page size for your PDF report, then you can
      configure these exporter parameters declaratively in your Spring
      configuration file using the <code class="literal">exporterParameters</code>
      property of the view class. The <code class="literal">exporterParameters</code>
      property is typed as <code class="literal">Map</code> and in your configuration
      the key of an entry should be the fully-qualified name of a static field
      that contains the exporter parameter definition and the value of an
      entry should be the value you want to assign to the parameter. An
      example of this is shown below: </p><pre class="programlisting">&lt;bean id="htmlReport" class="org.springframework.web.servlet.view.jasperreports.JasperReportsHtmlView"&gt;
  &lt;property name="url" value="/WEB-INF/reports/simpleReport.jrxml"/&gt;
  &lt;property name="exporterParameters"&gt;
    &lt;map&gt;
      &lt;entry key="net.sf.jasperreports.engine.export.JRHtmlExporterParameter.HTML_FOOTER"&gt;
        &lt;value&gt;Footer by Spring!
          &amp;lt;/td&amp;gt;&amp;lt;td width="50%"&amp;gt;&amp;amp;nbsp; &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
          &amp;lt;/table&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
        &lt;/value&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p> Here you can see that the
      <code class="literal">JasperReportsHtmlView</code> is being configured with an
      exporter parameter for
      <code class="literal">net.sf.jasperreports.engine.export.JRHtmlExporterParameter.HTML_FOOTER</code>
      which will output a footer in the resulting HTML.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="webintegration"></a>Chapter&nbsp;15.&nbsp;Integrating with other web frameworks</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="intro"></a>15.1.&nbsp;Introduction</h2></div></div></div><p>Spring can be easily integrated into any Java-based web framework.  
    All you need to do is to declare the 
    <a href="http://www.springframework.org/docs/api/org/springframework/web/context/ContextLoaderListener.html" target="_top">
    <code class="literal">ContextLoaderListener</code></a> in your <code class="literal">web.xml</code> and use a 
    <span class="emphasis"><em>contextConfigLocation</em></span> &lt;context-param&gt; to set which context files 
    to load.</p><p>The &lt;context-param&gt;: </p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>The &lt;listener&gt;: </p><pre class="programlisting">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</pre><p><span class="bold"><strong>NOTE:</strong></span> Listeners were added to 
    the Servlet API in version 2.3. If you have a Servlet 2.2 container, you can 
    use the <a href="http://www.springframework.org/docs/api/org/springframework/web/context/ContextLoaderServlet.html" target="_top">
    <code class="literal">ContextLoaderServlet</code></a> to achieve this same functionality.</p><p>If you don't specify the <span class="emphasis"><em>contextConfigLocation</em></span> 
    context parameter, the <code class="literal">ContextLoaderListener</code> will look 
    for a <span class="emphasis"><em>/WEB-INF/applicationContext.xml</em></span> file to load. 
    Once the context files are loaded, Spring creates a 
    <a href="http://www.springframework.org/docs/api/org/springframework/web/context/WebApplicationContext.html" target="_top">
    <code class="literal">WebApplicationContext</code></a> object based on the bean 
    definitions and puts it into the <code class="literal">ServletContext</code>.</p><p>All Java web frameworks are built on top of the Servlet API, so you 
    can use the following code to get the <code class="literal">ApplicationContext</code> 
    that Spring created.</p><pre class="programlisting">WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);</pre><p>The <a href="http://www.springframework.org/docs/api/org/springframework/web/context/support/WebApplicationContextUtils.html" target="_top">
    <code class="literal">WebApplicationContextUtils</code></a> class is for convenience, 
    so you don't have to remember the name of the <code class="literal">ServletContext</code> 
    attribute. Its <span class="emphasis"><em>getWebApplicationContext()</em></span> method will 
    return null if an object doesn't exist under the 
    <code class="literal">WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> 
    key. Rather than risk getting NullPointerExceptions in your application, 
    it's better to use the <span class="emphasis"><em>getRequiredWebApplicationContext()</em></span>
    method. This method throws an Exception when the 
    <span class="emphasis"><em>ApplicationContext</em></span> is missing.</p><p>Once you have a reference to the <code class="literal">WebApplicationContext</code>, 
    you can retrieve beans by their name or type. Most developers retrieve beans 
    by name, then cast them to one of their implemented interfaces.</p><p>Fortunately, most of the frameworks in this section have simpler 
    ways of looking up beans. Not only do they make it easy to get beans from 
    the <code class="literal">BeanFactory</code>, but they also allow you to use dependency 
    injection on their controllers. Each framework section has more detail on 
    its specific integration strategies.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jsf"></a>15.2.&nbsp;JavaServer Faces</h2></div></div></div><p>JavaServer Faces (JSF) is a component-based, event-driven web framework. 
    According to Sun Microsystem's <a href="http://java.sun.com/j2ee/javaserverfaces/overview.html" target="_top">
    JSF Overview</a>, JSF technology includes:</p><div class="itemizedlist"><ul type="disc"><li><p>A set of APIs for representing UI components and managing 
                their state, handling events and input validation, defining page 
                navigation, and supporting internationalization and accessibility.
   				</p></li><li><p>A JavaServer Pages (JSP) custom tag library for expressing a 
                JavaServer Faces interface within a JSP page.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-delegatingvariableresolver"></a>15.2.1.&nbsp;DelegatingVariableResolver</h3></div></div></div><p>The easiest way to integrate your Spring middle-tier with your JSF 
	    web layer is to  use the 
	    <a href="http://www.springframework.org/docs/api/org/springframework/web/jsf/DelegatingVariableResolver.html" target="_top">
		<code class="literal">DelegatingVariableResolver</code></a> class. To configure 
	    this variable resolver in your application, you'll need to edit your 
	    <span class="emphasis"><em>faces-context.xml</em></span>. After the opening <code class="literal">
		&lt;faces-config&gt;</code> element, add an <code class="literal">&lt;application&gt;</code> 
	    element and a <code class="literal">&lt;variable-resolver&gt;</code> element within it.  
	    The value of the variable resolver should reference Spring's 
	    <code class="literal">DelegatingVariableResolver</code>: </p><pre class="programlisting">&lt;faces-config&gt;
  &lt;application&gt;
	  &lt;variable-resolver&gt;org.springframework.web.jsf.DelegatingVariableResolver&lt;/variable-resolver&gt;
	  &lt;locale-config&gt;
	    &lt;default-locale&gt;en&lt;/default-locale&gt;
	    &lt;supported-locale&gt;en&lt;/supported-locale&gt;
	    &lt;supported-locale&gt;es&lt;/supported-locale&gt;
	  &lt;/locale-config&gt;
	  &lt;message-bundle&gt;messages&lt;/message-bundle&gt;
	&lt;/application&gt;</pre><p>By specifying Spring's variable resolver, you can configure Spring 
	    beans as managed properties of your managed beans. The 
	    <code class="literal">DelegatingVariableResolver</code> will first delegate value lookups 
	    to the default resolver of the underlying JSF implementation, and then to 
	    Spring's root <code class="literal">WebApplicationContext</code>. This allows you to 
	    easily inject dependencies into your JSF-managed beans.</p><p>Managed beans are defined in your <code class="literal">faces-config.xml</code> 
	    file. Below is an example where #{userManager} is a bean that's retrieved 
	    from Spring's <code class="literal">BeanFactory</code>. </p><pre class="programlisting">&lt;managed-bean&gt;
  &lt;managed-bean-name&gt;userList&lt;/managed-bean-name&gt;
	&lt;managed-bean-class&gt;com.whatever.jsf.UserList&lt;/managed-bean-class&gt;
  &lt;managed-bean-scope&gt;request&lt;/managed-bean-scope&gt;
  &lt;managed-property&gt;
    &lt;property-name&gt;userManager&lt;/property-name&gt;
    &lt;value&gt;#{userManager}&lt;/value&gt;
  &lt;/managed-property&gt;
&lt;/managed-bean&gt;</pre><p>The <code class="literal">DelegatingVariableResolver</code> is the recommended 
	    strategy for integrating JSF and Spring. If you're looking for more robust 
	    integration features, you might take a look at the 
		<a href="http://jsf-spring.sourceforge.net/" target="_top">JSF-Spring</a> project.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-facescontextutils"></a>15.2.2.&nbsp;FacesContextUtils</h3></div></div></div><p>A custom VariableResolver works well when mapping your properties 
	    to beans in <span class="emphasis"><em>faces-config.xml</em></span>, but at times you may need to grab a bean explicitly.  The 
		<a href="http://www.springframework.org/docs/api/org/springframework/web/jsf/FacesContextUtils.html" target="_top">
		<code class="literal">FacesContextUtils</code></a> class makes this easy. It's similar to 
		<code class="literal">WebApplicationContextUtils</code>, except that it takes a <code class="literal">FacesContext</code> 
		parameter rather than a <code class="literal">ServletContext</code> parameter.
		</p><pre class="programlisting">ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="struts"></a>15.3.&nbsp;Struts</h2></div></div></div><p><a href="http://struts.apache.org" target="_top">Struts</a> is the
    <span class="emphasis"><em>de facto</em></span> web framework for Java applications, mainly 
    because it was one of the first to be released (June 2001). Invented by 
    Craig McClanahan, Struts is an open source project hosted by the Apache 
    Software Foundation. At the time, it greatly simplified the JSP/Servlet 
    programming paradigm and won over many developers who were using 
    proprietary frameworks. It simplified the programming model, it was open 
    source, and it had a large community, which allowed the project to grow 
    and become popular among Java web developers.</p><p>To integrate your Struts application with Spring, you have two 
    options:</p><div class="itemizedlist"><ul type="disc"><li><p>Configure Spring to manage your Actions as beans, using the 
					<code class="literal">ContextLoaderPlugin</code>, and set their 
					dependencies in a Spring context file.</p></li><li><p>Subclass Spring's <span class="emphasis"><em>ActionSupport</em></span> 
					classes and grab your Spring-managed beans explicitly using 
					a <span class="emphasis"><em>getWebApplicationContext()</em></span> method.</p></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="struts-contextloaderplugin"></a>15.3.1.&nbsp;ContextLoaderPlugin</h3></div></div></div><p>The <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/ContextLoaderPlugIn.html" target="_top">
        <code class="literal">ContextLoaderPlugin</code></a> is a Struts 1.1+ plug-in 
        that loads a Spring context file for the Struts 
        <code class="literal">ActionServlet</code>. This context refers to the root 
        <code class="literal">WebApplicationContext</code> (loaded by the 
        <code class="literal">ContextLoaderListener</code>) as its parent. The default 
        name of the context file is the name of the mapped servlet, plus 
        <span class="emphasis"><em>-servlet.xml</em></span>. If <code class="literal">ActionServlet</code> 
        is defined in web.xml as 
        <code class="literal">&lt;servlet-name&gt;action&lt;/servlet-name&gt;</code>, the 
        default is <span class="emphasis"><em>/WEB-INF/action-servlet.xml</em></span>.</p><p>To configure this plug-in, add the following XML to the plug-ins section near the bottom of your 
			<span class="emphasis"><em>struts-config.xml</em></span> file:
			</p><pre class="programlisting">&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"/&gt;</pre><p>The location of the context configuration files can be 
            customized using the "contextConfigLocation" property.
            </p><pre class="programlisting">&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"&gt;
  &lt;set-property property="contextConfigLocation"
      value="/WEB-INF/action-servlet.xml.xml,/WEB-INF/applicationContext.xml"/&gt;
&lt;/plug-in&gt;</pre><p>It is possible to use this plugin to load all your context files, which can be useful when using testing tools
        like StrutsTestCase.  StrutsTestCase's <code class="literal">MockStrutsTestCase</code> won't initialize Listeners on startup
        so putting all your context files in the plugin is a workaround.  A 
        <a href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1088866&amp;group_id=39190&amp;atid=424562" target="_top">
        bug has been filed</a> for this issue.</p><p>After configuring this plug-in in <span class="emphasis"><em>struts-config.xml</em></span>, you can configure your Action to be 
			managed by Spring. Spring 1.1.3 provides two ways to do this:</p><div class="itemizedlist"><ul type="disc"><li><p>Override Struts' default <code class="literal">RequestProcessor</code>
					with Spring's <code class="literal">DelegatingRequestProcessor</code>.</p></li><li><p>Use the <span class="emphasis"><em>DelegatingActionProxy</em></span> class 
					in the type attribute of your <code class="literal">&lt;action-mapping&gt;</code>.</p></li></ul></div><p>Both of these methods allow you to manage your Actions and 
        their dependencies in the <span class="emphasis"><em>action-context.xml</em></span> file. 
        The bridge between the Action in <span class="emphasis"><em>struts-config.xml</em></span> 
        and <span class="emphasis"><em>action-servlet.xml</em></span> is built with the 
        action-mapping's "path" and the bean's "name". If you have the 
        following in your <span class="emphasis"><em>struts-config.xml</em></span> file:
		</p><pre class="programlisting">&lt;action path="/users" .../&gt;</pre><p>You must define that Action's bean with the "/users" name in
        <span class="emphasis"><em>action-servlet.xml</em></span>:
			</p><pre class="programlisting">&lt;bean name="/users" .../&gt;</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="struts-delegatingrequestprocessor"></a>15.3.1.1.&nbsp;DelegatingRequestProcessor</h4></div></div></div><p>To configure the <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingRequestProcessor.html" target="_top">
	        <code class="literal">DelegatingRequestProcessor</code></a> in your 
	        <span class="emphasis"><em>struts-config.xml</em></span> file, override the "processorClass" 
	        property in the &lt;controller&gt; element. These lines follow the 
	        &lt;action-mapping&gt; element. </p><pre class="programlisting">&lt;controller&gt;
  &lt;set-property property="processorClass"
      value="org.springframework.web.struts.DelegatingRequestProcessor"/&gt;
&lt;/controller&gt;</pre><p>After adding this setting, your Action will automatically be 
	        looked up in Spring's context file, no matter what the type. In fact, 
	        you don't even need to specify a type. Both of the following snippets 
	        will work: </p><pre class="programlisting">&lt;action path="/user" type="com.whatever.struts.UserAction"/&gt;		
	&lt;action path="/user"/&gt;</pre><p>If you're using Struts' <span class="emphasis"><em>modules</em></span> feature, 
	        your bean names must contain the module prefix. For example, an action 
	        defined as <code class="literal">&lt;action path="/user"/&gt;</code> with module 
	        prefix "admin" requires a bean name with <code class="literal">&lt;bean name="/admin/user"/&gt;</code>.</p><p><span class="bold"><strong>NOTE:</strong></span> If you're using Tiles 
	        in your Struts application, you must configure your &lt;controller&gt;
	        with the <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingTilesRequestProcessor.html" target="_top">
			<code class="literal">DelegatingTilesRequestProcessor</code></a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="struts-delegatingactionproxy"></a>15.3.1.2.&nbsp;DelegatingActionProxy</h4></div></div></div><p>If you have a custom <code class="literal">RequestProcessor</code> and 
	        can't use the <code class="literal">DelegatingTilesRequestProcessor</code>, you can 
	        use the <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/DelegatingActionProxy.html" target="_top">
	        <code class="literal">DelegatingActionProxy</code></a> as the type in your 
	        action-mapping. </p><pre class="programlisting">&lt;action path="/user" type="org.springframework.web.struts.DelegatingActionProxy"
    name="userForm" scope="request" validate="false" parameter="method"&gt;
  &lt;forward name="list" path="/userList.jsp"/&gt;
  &lt;forward name="edit" path="/userForm.jsp"/&gt;
&lt;/action&gt;</pre><p>The bean definition in <span class="emphasis"><em>action-servlet.xml</em></span> 
	        remains the same, whether you use a custom <code class="literal">RequestProcessor</code>
	        or the <code class="literal">DelegatingActionProxy</code>.</p><p>If you define your Action in a context file, the full feature set of Spring's
          bean container will be available for it: dependency injection as well as the option
          to instantiate a new Action instance for each request. To activate the latter,
          add <span class="emphasis"><em>singleton="false"</em></span> to your Action's bean definition.
		</p><pre class="programlisting">&lt;bean name="/user" <span class="emphasis"><em>singleton="false"</em></span> autowire="byName"
    class="org.example.web.UserAction"/&gt;</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="struts-actionsupport"></a>15.3.2.&nbsp;ActionSupport Classes</h3></div></div></div><p>As previously mentioned, you can retrieve the
        <code class="literal">WebApplicationContext</code> from the <code class="literal">ServletContext</code>
        using the WebApplicationContextUtils class. An easier way is to extend
        Spring's Action classes for Struts. For example, instead of subclassing
        Struts' Action class, you can subclass Spring's
        <a href="http://www.springframework.org/docs/api/org/springframework/web/struts/ActionSupport.html" target="_top">
        <code class="literal">ActionSupport</code></a> class.</p><p>The <code class="literal">ActionSupport</code> class provides additional
        convenience methods, like <span class="emphasis"><em>getWebApplicationContext()</em></span>.
        Below is an example of how you might use this in an Action:
		</p><pre class="programlisting">public class UserAction extends DispatchActionSupport {

    public ActionForward execute(ActionMapping mapping,
                                 ActionForm form,
                                 HttpServletRequest request,
                                 HttpServletResponse response)
            throws Exception {
        if (log.isDebugEnabled()) {
            log.debug("entering 'delete' method...");
        }

        WebApplicationContext ctx = getWebApplicationContext();
        UserManager mgr = (UserManager) ctx.getBean("userManager");

        // talk to manager for business logic

        return mapping.findForward("success");
    }
}</pre><p>Spring includes subclasses for all of the standard Struts Actions
    - the Spring versions merely have <span class="emphasis"><em>Support</em></span> appended to
    the name:

    </p><div class="itemizedlist"><ul type="disc" compact><li><p><a href="http://www.springframework.org/docs/api/org/springframework/web/struts/ActionSupport.html" target="_top"><code class="literal">ActionSupport</code></a>,</p></li><li><p><a href="http://www.springframework.org/docs/api/org/springframework/web/struts/DispatchActionSupport.html" target="_top"><code class="literal">DispatchActionSupport</code></a>,</p></li><li><p><a href="http://www.springframework.org/docs/api/org/springframework/web/struts/LookupDispatchActionSupport.html" target="_top"><code class="literal">LookupDispatchActionSupport</code></a> and</p></li><li><p><a href="http://www.springframework.org/docs/api/org/springframework/web/struts/MappingDispatchActionSupport.html" target="_top"><code class="literal">MappingDispatchActionSupport</code></a>.</p></li></ul></div><p>
    </p><p>The recommended strategy is to use the approach that best suits
    your project. Subclassing makes your code more readable, and you know
    exactly how your dependencies are resolved. However, using the
    <code class="literal">ContextLoaderPlugin</code> allow you to easily add new
    dependencies in your context XML file. Either way, Spring provides some
    nice options for integrating the two frameworks.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-tapestry"></a>15.4.&nbsp;Tapestry</h2></div></div></div><p>Tapestry is a powerful, component-oriented web application framework
    from Apache's Jakarta project (<a href="http://jakarta.apache.org/tapestry" target="_top">http://jakarta.apache.org/tapestry</a>). While Spring has its
    own powerful web ui layer, there are a number of unique advantages to
    building a J2EE application using a combination of Tapestry for the web
    ui, and the Spring container for the lower layers. This document attempts
    to detail a few best practices for combining these two frameworks. It is
    expected that you are relatively familiar with both Tapestry and Spring
    Framework basics, so they will not be explained here. General introductory
    documentation for both Tapestry and Spring Framework are available on
    their respective web sites.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tapestry-architecture"></a>15.4.1.&nbsp;Architecture</h3></div></div></div><p>A typical layered J2EE application built with Tapestry and Spring
      will consist of a top UI layer built with Tapestry, and a number of
      lower layers, hosted out of one or more Spring Application
      Contexts.</p><div class="itemizedlist"><ul type="disc"><li><p>
						<span class="emphasis"><em>User Interface Layer:</em></span>
					</p><p>- concerned with the user interface</p><p>- contains some application logic</p><p>- provided by Tapestry</p><p>- aside from providing UI via Tapestry, code in this layer
          does its work via objects which implement interfaces from the
          Service Layer. The actual objects which implement these service
          layer interfaces are obtained from a Spring Application
          Context.</p></li><li><p>
						<span class="emphasis"><em>Service Layer:</em></span>
					</p><p>- application specific 'service' code</p><p>- works with domain objects, and uses the Mapper API to get
          those domain objects into and out of some sort of repository
          (database)</p><p>- hosted in one or more Spring contexts</p><p>- code in this layer manipulates objects in the domain model,
          in an application specific fashion. It does its work via other code
          in this layer, and via the Mapper API. An object in this layer is
          given the specific mapper implementations it needs to work with, via
          the Spring context.</p><p>- since code in this layer is hosted in the Spring context, it
          may be transactionally wrapped by the Spring context, as opposed to
          managing its own transactions</p></li><li><p>
						<span class="emphasis"><em>Domain Model:</em></span>
					</p><p>- domain specific object hierarchy, which deals with data and
          logic specific to this domain</p><p>- although the domain object hierarchy is built with the idea
          that it is persisted somehow and makes some general concessions to
          this (for example, bidirectional relationships), it generally has no
          knowledge of other layers. As such, it may be tested in isolation,
          and used with different mapping implementations for production vs.
          testing.</p><p>- these objects may be standalone, or used in conjunction with
          a Spring application context to take advantage of some of the
          benefits of the context, e.g., isolation, inversion of control,
          different strategy implementations, etc.</p></li><li><p>
						<span class="emphasis"><em>Data Source Layer:</em></span>
					</p><p>- Mapper API (also called Data Access Objects): an API used to
          persist the domain model to a repository of some sort (generally a
          DB, but could be the filesystem, memory, etc.)</p><p>- Mapper API implementations: one or more specific
          implementations of the Mapper API, for example, a Hibernate-specific
          mapper, a JDO-specific mapper, JDBC-specific mapper, or a memory
          mapper.</p><p>- mapper implementations live in one or more Spring
          Application Contexts. A service layer object is given the mapper
          objects it needs to work with via the context.</p></li><li><p>
						<span class="emphasis"><em>Database, filesystem, or other
          repositories:</em></span>
					</p><p>- objects in the domain model are stored into one or more
          repositories via one or more mapper implementations</p><p>- a repository may be very simple (e.g. filesystem), or may
          have its own representation of the data from the domain model (i.e.
          a schema in a db). It does not know about other layers
          howerver.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tapestry-implementation"></a>15.4.2.&nbsp;Implementation</h3></div></div></div><p>The only real question (which needs to be addressed by this
      document), is how Tapestry pages get access to service implementations,
      which are simply beans defined in an instance of the Spring Application
      Context.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-context"></a>15.4.2.1.&nbsp;Sample application context</h4></div></div></div><p>Assume we have the following simple Application Context
        definition, in xml form: </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" 
        "http://www.springframework.org/dtd/spring-beans.dtd"&gt;
 
&lt;beans&gt;
 
    &lt;!-- ========================= GENERAL DEFINITIONS ========================= --&gt;
 
    &lt;!-- ========================= PERSISTENCE DEFINITIONS ========================= --&gt;
 
    &lt;!-- the DataSource --&gt;
    &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName"&gt;&lt;value&gt;java:DefaultDS&lt;/value&gt;&lt;/property&gt;
        &lt;property name="resourceRef"&gt;&lt;value&gt;false&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
 
    &lt;!-- define a Hibernate Session factory via a Spring LocalSessionFactoryBean --&gt;
    &lt;bean id="hibSessionFactory" 
        class="org.springframework.orm.hibernate.LocalSessionFactoryBean"&gt;
        &lt;property name="dataSource"&gt;&lt;ref bean="dataSource"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
 
    &lt;!--
     - Defines a transaction manager for usage in business or data access objects.
     - No special treatment by the context, just a bean instance available as reference
     - for business objects that want to handle transactions, e.g. via TransactionTemplate.
     --&gt;
    &lt;bean id="transactionManager" 
        class="org.springframework.transaction.jta.JtaTransactionManager"&gt;
    &lt;/bean&gt;
 
    &lt;bean id="mapper" 
        class="com.whatever.dataaccess.mapper.hibernate.MapperImpl"&gt;
        &lt;property name="sessionFactory"&gt;&lt;ref bean="hibSessionFactory"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
   
    &lt;!-- ========================= BUSINESS DEFINITIONS ========================= --&gt;
 
    &lt;!-- AuthenticationService, including tx interceptor --&gt;
    &lt;bean id="authenticationServiceTarget"
        class="com.whatever.services.service.user.AuthenticationServiceImpl"&gt;
        &lt;property name="mapper"&gt;&lt;ref bean="mapper"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="authenticationService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
        &lt;property name="target"&gt;&lt;ref bean="authenticationServiceTarget"/&gt;&lt;/property&gt;
        &lt;property name="proxyInterfacesOnly"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
    &lt;!-- UserService, including tx interceptor --&gt;
    &lt;bean id="userServiceTarget"
        class="com.whatever.services.service.user.UserServiceImpl"&gt;
        &lt;property name="mapper"&gt;&lt;ref bean="mapper"/&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="userService" 
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager"&gt;&lt;ref bean="transactionManager"/&gt;&lt;/property&gt;
        &lt;property name="target"&gt;&lt;ref bean="userServiceTarget"/&gt;&lt;/property&gt;
        &lt;property name="proxyInterfacesOnly"&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;props&gt;
                &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
 &lt;/beans&gt;</pre><p> Inside the Tapestry application, we need to
        load this application context, and allow Tapestry pages to get the
        authenticationService and userService beans, which implement the
        AuthenticationService and UserService interfaces, respectively.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-appctx"></a>15.4.2.2.&nbsp;Obtaining beans in Tapestry pages</h4></div></div></div><p>At this point, the application context is available to a web
        application by calling Spring's static utility function
        <code class="literal">WebApplicationContextUtils.getApplicationContext(servletContext)</code>,
        where servletContext is the standard <code class="literal">ServletContext</code>
        from the J2EE Servlet specification. As such, one simple mechanism for
        a page to get an instance of the UserService, for example, would be
        with code such as: </p><pre class="programlisting">    WebApplicationContext appContext = WebApplicationContextUtils.getApplicationContext(
        getRequestCycle().getRequestContext().getServlet().getServletContext());
    UserService userService = (UserService) appContext.getBean("userService");
    ... some code which uses UserService</pre><p> This mechanism does
        work. It can be made a lot less verbose by encapsulating most of the
        functionality in a method in the base class for the page or component.
        However, in some respects it goes against the Inversion of Control
        approach which Spring encourages, which is being used in other layers
        of this app, in that ideally you would like the page to not have to
        ask the context for a specific bean by name, and in fact, the page
        would ideally not know about the context at all.</p><p>Luckily, there is a mechanism to allow this. We rely upon the
        fact that Tapestry already has a mechanism to declaratively add
        properties to a page, and it is in fact the preferred approach to
        manage all properties on a page in this declarative fashion, so that
        Tapestry can properly manage their lifecycle as part of the page and
        component lifecycle.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-exposeappctx"></a>15.4.2.3.&nbsp;Exposing the application context to Tapestry</h4></div></div></div><p>First we need to make the <code class="literal">ApplicationContext</code>
        available to the Tapestry page or Component without having to have the
        <code class="literal">ServletContext</code>; this is because at the stage in the
        page's/component's lifecycle when we need to access the
        <code class="literal">ApplicationContext</code>, the
        <code class="literal">ServletContext</code> won't be easily available to the
        page, so we can't use
        <code class="literal">WebApplicationContextUtils.getApplicationContext(servletContext)</code>
        directly. One way is by defining a custom version of the Tapestry
        IEngine which exposes this for us: </p><pre class="programlisting">package com.whatever.web.xportal;
...
import ...
...
public class MyEngine extends org.apache.tapestry.engine.BaseEngine {
 
    public static final String APPLICATION_CONTEXT_KEY = "appContext";
 
    /**
     * @see org.apache.tapestry.engine.AbstractEngine#setupForRequest(org.apache.tapestry.request.RequestContext)
     */
    protected void setupForRequest(RequestContext context) {
        super.setupForRequest(context);
     
        // insert ApplicationContext in global, if not there
        Map global = (Map) getGlobal();
        ApplicationContext ac = (ApplicationContext) global.get(APPLICATION_CONTEXT_KEY);
        if (ac == null) {
            ac = WebApplicationContextUtils.getWebApplicationContext(
                context.getServlet().getServletContext()
            );
            global.put(APPLICATION_CONTEXT_KEY, ac);
        }
    }
}</pre><p>This engine class places the Spring Application Context as
        an attribute called "appContext" in this Tapestry app's 'Global'
        object. Make sure to register the fact that this special IEngine
        instance should be used for this Tapestry application, with an entry
        in the Tapestry application definition file. For example:
        </p><pre class="programlisting">file: xportal.application:
 
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE application PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
&lt;application
    name="Whatever xPortal"
    engine-class="com.whatever.web.xportal.MyEngine"&gt;
&lt;/application&gt;</pre><p>
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-componentdefs"></a>15.4.2.4.&nbsp;Component definition files</h4></div></div></div><p>Now in our page or component definition file (*.page or *.jwc),
        we simply add property-specification elements to grab the beans we
        need out of the ApplicationContext, and create page or component
        properties for them. For example: </p><pre class="programlisting">    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;</pre><p> The OGNL expression
        inside the property-specification specifies the initial value for the
        property, as a bean obtained from the context. The entire page
        definition might look like this: </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE page-specification PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
     
&lt;page-specification class="com.whatever.web.xportal.pages.Login"&gt;
 
    &lt;property-specification name="username" type="java.lang.String"/&gt;
    &lt;property-specification name="password" type="java.lang.String"/&gt;
    &lt;property-specification name="error" type="java.lang.String"/&gt;
    &lt;property-specification name="callback" type="org.apache.tapestry.callback.ICallback" persistent="yes"/&gt;
    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;
   
    &lt;bean name="delegate" class="com.whatever.web.xportal.PortalValidationDelegate"/&gt;
 
    &lt;bean name="validator" class="org.apache.tapestry.valid.StringValidator" lifecycle="page"&gt;
        &lt;set-property name="required" expression="true"/&gt;
        &lt;set-property name="clientScriptingEnabled" expression="true"/&gt;
    &lt;/bean&gt;
 
    &lt;component id="inputUsername" type="ValidField"&gt;
        &lt;static-binding name="displayName" value="Username"/&gt;
        &lt;binding name="value" expression="username"/&gt;
        &lt;binding name="validator" expression="beans.validator"/&gt;
    &lt;/component&gt;
   
    &lt;component id="inputPassword" type="ValidField"&gt;
        &lt;binding name="value" expression="password"/&gt;
       &lt;binding name="validator" expression="beans.validator"/&gt;
       &lt;static-binding name="displayName" value="Password"/&gt;
       &lt;binding name="hidden" expression="true"/&gt;
    &lt;/component&gt;
 
&lt;/page-specification&gt;</pre><p>
				</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tapestry-getters"></a>15.4.2.5.&nbsp;Adding abstract accessors</h4></div></div></div><p>Now in the Java class definition for the page or component
        itself, all we need to do is add an abstract getter method for the
        properties we have defined, to access them. When the page or component
        is actually loaded by Tapestry, it performs runtime code
        instrumentation on the classfile to add the properties which have been
        defined, and hook up the abstract getter methods to the newly created
        fields. For example: </p><pre class="programlisting">    // our UserService implementation; will come from page definition
    public abstract UserService getUserService();
    // our AuthenticationService implementation; will come from page definition
    public abstract AuthenticationService getAuthenticationService();</pre><p>
        For completeness, the entire Java class, for a login page in this
        example, might look like this: </p><pre class="programlisting">package com.whatever.web.xportal.pages;
 
/**
 *  Allows the user to login, by providing username and password.
 *  After successfully logging in, a cookie is placed on the client browser
 *  that provides the default username for future logins (the cookie
 *  persists for a week).
 */
public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {
 
    /** the key under which the authenticated user object is stored in the visit as */
    public static final String USER_KEY = "user";
   
    /**
     * The name of a cookie to store on the user's machine that will identify
     * them next time they log in.
     **/
    private static final String COOKIE_NAME = Login.class.getName() + ".username";  
    private final static int ONE_WEEK = 7 * 24 * 60 * 60;
 
    // --- attributes
 
    public abstract String getUsername();
    public abstract void setUsername(String username);
 
    public abstract String getPassword();
    public abstract void setPassword(String password);
 
    public abstract ICallback getCallback();
    public abstract void setCallback(ICallback value);
    
    public abstract UserService getUserService();
 
    public abstract AuthenticationService getAuthenticationService();
 
    // --- methods
 
    protected IValidationDelegate getValidationDelegate() {
        return (IValidationDelegate) getBeans().getBean("delegate");
    }
 
    protected void setErrorField(String componentId, String message) {
        IFormComponent field = (IFormComponent) getComponent(componentId);
        IValidationDelegate delegate = getValidationDelegate();
        delegate.setFormComponent(field);
        delegate.record(new ValidatorException(message));
    }
 
    /**
     *  Attempts to login. 
     *
     *  &lt;p&gt;If the user name is not known, or the password is invalid, then an error
     *  message is displayed.
     *
     **/
    public void attemptLogin(IRequestCycle cycle) {
     
        String password = getPassword();
 
        // Do a little extra work to clear out the password.
 
        setPassword(null);
        IValidationDelegate delegate = getValidationDelegate();
 
        delegate.setFormComponent((IFormComponent) getComponent("inputPassword"));
        delegate.recordFieldInputValue(null);
 
        // An error, from a validation field, may already have occurred.
 
        if (delegate.getHasErrors())
            return;
 
        try {
            User user = getAuthenticationService().login(getUsername(), getPassword());
           loginUser(user, cycle);
        }
        catch (FailedLoginException ex) {
            this.setError("Login failed: " + ex.getMessage());
            return;
        }
    }
 
    /**
     *  Sets up the {@link User} as the logged in user, creates
     *  a cookie for their username (for subsequent logins),
     *  and redirects to the appropriate page, or
     *  a specified page).
     *
     **/
    public void loginUser(User user, IRequestCycle cycle) {
     
        String username = user.getUsername();
 
        // Get the visit object; this will likely force the
        // creation of the visit object and an HttpSession.
 
        Map visit = (Map) getVisit();
        visit.put(USER_KEY, user);
 
        // After logging in, go to the MyLibrary page, unless otherwise
        // specified.
 
        ICallback callback = getCallback();
 
        if (callback == null)
            cycle.activate("Home");
        else
            callback.performCallback(cycle);
 
        // I've found that failing to set a maximum age and a path means that
        // the browser (IE 5.0 anyway) quietly drops the cookie.
 
        IEngine engine = getEngine();
        Cookie cookie = new Cookie(COOKIE_NAME, username);
        cookie.setPath(engine.getServletPath());
        cookie.setMaxAge(ONE_WEEK);
 
        // Record the user's username in a cookie
 
        cycle.getRequestContext().addCookie(cookie);
 
        engine.forgetPage(getPageName());
    }
   
    public void pageBeginRender(PageEvent event) {
        if (getUsername() == null)
            setUsername(getRequestCycle().getRequestContext().getCookieValue(COOKIE_NAME));
    }
}</pre><p>
				</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tapestry-summary"></a>15.4.3.&nbsp;Summary</h3></div></div></div><p>In this example, we've managed to allow service beans defined in
      the Spring <code class="literal">ApplicationContext</code> to be provided to the
      page in a declarative fashion. The page class does not know where the
      service implementations are coming from, and in fact it is easy to slip
      in another implementation, for example, during testing. This inversion
      of control is one of the prime goals and benefits of the Spring
      Framework, and we have managed to extend it all the way up the J2EE
      stack in this Tapestry application.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webwork"></a>15.5.&nbsp;WebWork</h2></div></div></div><p><a href="http://www.opensymphony.com/webwork" target="_top">WebWork</a>
    is a web framework designed with simplicity in mind. It's built on top of 
    <a href="http://www.opensymphony.com/xwork" target="_top">XWork</a>, which is a 
    generic command framework. XWork also has an IoC container, but it isn't 
    as full-featured as Spring and won't be covered in this section. WebWork 
    controllers are called Actions, mainly because they must implement the 
    <a href="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/Action.html" target="_top">
    <code class="literal">Action</code></a> interface. The 
    <a href="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/ActionSupport.html" target="_top">
    <code class="literal">ActionSupport</code></a> class implements this interface, 
    and it is most common parent class for WebWork actions.</p><p>WebWork maintains its own Spring integration project, located on 
    java.net in the <a href="https://xwork-optional.dev.java.net/" target="_top">
    xwork-optional</a> project. Currently, three options are available for 
    integrating WebWork with Spring:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><strong>SpringObjectFactory</strong></span>: 
            override XWork's default 
            <a href="http://www.opensymphony.com/xwork/api/com/opensymphony/xwork/ObjectFactory.html" target="_top">
            <code class="literal">ObjectFactory</code></a> so XWork will look for 
            Spring beans in the root <code class="literal">WebApplicationContext</code>.</p></li><li><p><span class="bold"><strong>ActionAutowiringInterceptor:</strong></span> 
            use an interceptor to  automatically wire an Action's dependencies 
            as they're created.</p></li><li><p><span class="bold"><strong>SpringExternalReferenceResolver:</strong></span> 
            look up Spring beans based on the name defined in an &lt;external-ref&gt; 
            element of an &lt;action&gt; element.</p></li></ul></div><p>All of these strategies are explained in further detail in 
    <a href="http://wiki.opensymphony.com/display/WW/WebWork+2+Spring+Integration" target="_top">
    WebWork's Documentation</a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="remoting"></a>Chapter&nbsp;16.&nbsp;Remoting and web services using Spring</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12311"></a>16.1.&nbsp;Introduction</h2></div></div></div><p>
			Spring features integration classes for remoting support using various
			technologies. The remoting support eases the development of remote-enabled
			services, implemented by your usual (Spring) POJOs. Currently, Spring supports
			four remoting technologies:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p>
						<span class="emphasis"><em>Remote Method Invocation (RMI)</em></span>. Through the use
						of the <code class="literal">RmiProxyFactoryBean</code> and the
						<code class="literal">RmiServiceExporter</code> Spring supports both traditional
						RMI (with java.rmi.Remote interfaces and java.rmi.RemoteException) and
						transparent remoting via RMI invokers (with any Java interface).
					</p></li><li><p>
						<span class="emphasis"><em>Spring's HTTP invoker</em></span>. Spring provides a special
						remoting strategy which allows for Java serialization via HTTP,
						supporting any Java interface (just like the RMI invoker). The corresponding
						support classes are <code class="literal">HttpInvokerProxyFactoryBean</code> and
						<code class="literal">HttpInvokerServiceExporter</code>.
					</p></li><li><p>
						<span class="emphasis"><em>Hessian</em></span>. By using the
						<code class="literal">HessianProxyFactoryBean</code>
						and the <code class="literal">HessianServiceExporter</code> you can transparently
						expose your services using the lightweight binary HTTP-based protocol
						provided by Caucho.
					</p></li><li><p>
						<span class="emphasis"><em>Burlap</em></span>. Burlap is Caucho's XML-based
						alternative for Hessian. Spring provides support classes such
						as <code class="literal">BurlapProxyFactoryBean</code> and 
						<code class="literal">BurlapServiceExporter</code>.
					</p></li><li><p>
						<span class="emphasis"><em>JAX RPC</em></span>. Spring provides remoting support
						for Web Services via JAX-RPC.
					</p></li><li><p>
						<span class="emphasis"><em>JMS (TODO)</em></span>.
					</p></li></ul></div><p>
		</p><p>
			While discussing the remoting capabilities of Spring, we'll use the following domain 
			model and corresponding services:
			</p><pre class="programlisting">
// Account domain object
public class Account implements Serializable{
  private String name;

  public String getName();
  public void setName(String name) {
    this.name = name;
  }
}
			</pre><p>
			</p><pre class="programlisting">
// Account service
public interface AccountService {

  public void insertAccount(Account acc);
  
  public List getAccounts(String name);
}
			</pre><p>
			</p><pre class="programlisting">
// Remote Account service
public interface RemoteAccountService extends Remote {

  public void insertAccount(Account acc) throws RemoteException;
  
  public List getAccounts(String name) throws RemoteException;
}
			</pre><p>
			</p><pre class="programlisting">
// ... and corresponding implement doing nothing at the moment
public class AccountServiceImpl implements AccountService {

  public void insertAccount(Account acc) {
    // do something
  }
  
  public List getAccounts(String name) {
    // do something
  }
}
			</pre><p>
		</p><p>
			We will start exposing the service to a remote client by using RMI and 
			talk a bit about the drawbacks of using RMI. We'll then continue to show
			an example for Hessian.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12394"></a>16.2.&nbsp;Exposing services using RMI</h2></div></div></div><p>
			Using Spring's support for RMI, you can transparently expose your services through
			the RMI infrastructure. After having this set up, you basically have a configuration
			similar to remote EJBs, except for the fact that there is no standard support for
			security context propagation or remote transaction propagation. Spring does provide
			hooks for such additional invocation context when using the RMI invoker, so you can
			for example plug in security frameworks or custom security credentials here.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12399"></a>16.2.1.&nbsp;Exporting the service using the <code class="literal">RmiServiceExporter</code></h3></div></div></div><p>
				Using the <code class="literal">RmiServiceExporter</code>, we can expose the interface
				of our AccountService object as RMI object. The interface can be accessed by using
				<code class="literal">RmiProxyFactoryBean</code>, or via plain RMI in case of a traditional
				RMI service. The <code class="literal">RmiServiceExporter</code> explicitly supports the
				exposing of any non-RMI services via RMI invokers.
			</p><p>
				Of course, we first have to set up our service in the Spring BeanFactory:
				</p><pre class="programlisting">
&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
    &lt;!-- any additional properties, maybe a DAO? --&gt;
&lt;/bean&gt;
				</pre><p>
			</p><p>
				Next we'll have to expose our service using the <code class="literal">RmiServiceExporter</code>:
				</p><pre class="programlisting">
&lt;bean class="org.springframework.remoting.rmi.RmiServiceExporter"&gt;
	&lt;!-- does not necessarily have to be the same name as the bean to be exported --&gt;
	&lt;property name="serviceName" value="AccountService"/&gt;
	&lt;property name="service" ref="accountService"/&gt;
	&lt;property name="serviceInterface" value="example.AccountService"/&gt;
	&lt;!-- defaults to 1099 --&gt;
	&lt;property name="registryPort" value="1199"/&gt;
&lt;/bean&gt;
				</pre><p>
				As you can see, we're overriding the port for the RMI registry. Often,
				your application server also maintains an RMI registry and it is wise
				to not interfere with that one.
				Furthermore, the service name is used to bind the service under. So right now,
				the service will be bound at <code class="literal">rmi://HOST:1199/AccountService</code>.				
				We'll use the URL later on to link in the service at the client side.
			</p><p>
				<span class="emphasis"><em>Note: We've left out one property, i.e. the <code class="literal">servicePort</code>
					property, which is 0 by default. This means an anonymous port will be used
					to communicate with the service. You can specify a different port if you like.</em></span>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12439"></a>16.2.2.&nbsp;Linking in the service at the client</h3></div></div></div><p>
				Our client is a simple object using the AccountService to manage accounts:
				</p><pre class="programlisting">
public class SimpleObject {
  private AccountService accountService;
  public void setAccountService(AccountService accountService) {
    this.accountService = accountService;
  }
}
				</pre><p>				
			</p><p>
				To link in the service on the client, we'll create a separate bean factory,
				containing the simple object and the service linking configuration bits:
				</p><pre class="programlisting">
&lt;bean class="example.SimpleObject"&gt;
	&lt;property name="accountService" ref="accountService"/&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.rmi.RmiProxyFactoryBean"&gt;
	&lt;property name="serviceUrl" value="rmi://HOST:1199/AccountService"/&gt;
	&lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;
				</pre><p>
				That's all we need to do to support the remote account service on the client.
				Spring will transparently create an invoker and remotely enable the account
				service through the RmiServiceExporter. At the client we're linking it in using
				the RmiProxyFactoryBean.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12452"></a>16.3.&nbsp;Using Hessian or Burlap to remotely call services via HTTP</h2></div></div></div><p>
			Hessian offers a binary HTTP-based remoting protocol. It's created by
			Caucho and more information about Hessian itself can be found 
			at <a href="http://www.caucho.com" target="_top">http://www.caucho.com</a>.			
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12459"></a>16.3.1.&nbsp;Wiring up the DispatcherServlet for Hessian</h3></div></div></div><p>
				Hessian communicates via HTTP and does so using a custom servlet.
				Using Spring's DispatcherServlet principles, you can easily 
				wire up such a servlet exposing your services. First we'll have to
				create a new servlet in your application (this an excerpt from
				<code class="literal">web.xml</code>):
				</p><pre class="programlisting">
&lt;servlet&gt;
	&lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
	&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/remoting/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
				</pre><p>
			</p><p>
				You're probably familiar with Spring's DispatcherServlet principles and if so,
				you know that now you'll have to create an application context named
				<code class="literal">remoting-servlet.xml</code> (after the name of your servlet) in
				the <code class="literal">WEB-INF</code> directory. The application context will be used
				in the next section.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12478"></a>16.3.2.&nbsp;Exposing your beans by using the HessianServiceExporter</h3></div></div></div><p>
				In the newly created application context called <code class="literal">remoting-servlet.xml</code>,
				we'll create a HessianServiceExporter exporting your services:
				</p><pre class="programlisting">
&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
  &lt;!-- any additional properties, maybe a DAO? --&gt;
&lt;/bean&gt;

&lt;bean name="/AccountService" class="org.springframework.remoting.caucho.HessianServiceExporter"&gt;
  &lt;property name="service" ref="accountService"/&gt;
  &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;
				</pre><p>
				Now we're ready to link in the service at the client. No explicit handler mapping
				is specified, mapping request URLs onto services, so BeanNameUrlHandlerMapping
				will be used: hence, the service will be exported at the URL indicated through
				its bean name: <code class="literal">http://HOST:8080/remoting/AccountService</code>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12492"></a>16.3.3.&nbsp;Linking in the service on the client</h3></div></div></div><p>
				Using the <code class="literal">HessianProxyFactoryBean</code> we can link in the service
				at the client. The same principles apply as with the RMI example. We'll create
				a separate bean factory or application context and mention the following beans
				where the SimpleObject is using the AccountService to manage accounts:
				</p><pre class="programlisting">
&lt;bean class="example.SimpleObject"&gt;
  &lt;property name="accountService" ref="accountService"/&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.caucho.HessianProxyFactoryBean"&gt;
	&lt;property name="serviceUrl" value="http://remotehost:8080/AccountService"/&gt;
	&lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;
				</pre><p>
				That's all there is to it.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12503"></a>16.3.4.&nbsp;Using Burlap</h3></div></div></div><p>
				We won't discuss Burlap, the XML-based equivalent of Hessian, in detail here,
				since it is configured and set up in exactly the same way as the Hessian
				variant explained above. Just replace the word <code class="literal">Hessian</code>
				with <code class="literal">Burlap</code> and you're all set to go.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12514"></a>16.3.5.&nbsp;Applying HTTP basic authentication to a service exposed through Hessian or Burlap</h3></div></div></div><p>
				One of the advantages of Hessian and Burlap is that we can easily apply HTTP basic
				authentication, because both protocols are HTTP-based. Your normal HTTP server security
				mechanism can easily be applied through using the <code class="literal">web.xml</code> security
				features, for example. Usually, you don't use per-user security credentials here, but
				rather shared credentials defined at the Hessian/BurlapProxyFactoryBean level
				(similar to a JDBC DataSource).
			</p><p>
				</p><pre class="programlisting">
&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;
	&lt;property name="interceptors"&gt;
		&lt;list&gt;
			&lt;ref bean="authorizationInterceptor"/&gt;
		&lt;/list&gt;
	&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="authorizationInterceptor" 
	class="org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor"&gt;
	&lt;property name="authorizedRoles"&gt;
		&lt;list&gt;
			&lt;value&gt;administrator&lt;/value&gt;
			&lt;value&gt;operator&lt;/value&gt;
		&lt;/list&gt;
	&lt;/property&gt;	
&lt;/bean&gt;
				</pre><p>
			</p><p>
				This an example where we explicitly mention the BeanNameUrlHandlerMapping
				and set an interceptor allowing only administrators and operators to call
				the beans mentioned in this application context.
			</p><p>
				<span class="emphasis"><em>
					Note: Of course, this example doesn't show a flexible kind of security
					infrastructure. For more options as far as security is concerned,
					have a look at the Acegi Security System for Spring, to be found at
					<a href="http://acegisecurity.sourceforge.net" target="_top">http://acegisecurity.sourceforge.net</a>.
				</em></span>
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12536"></a>16.4.&nbsp;Exposing services using HTTP invokers</h2></div></div></div><p>
			As opposed to Burlap and Hessian, which are both lightweight protocols using their
			own slim serialization mechanisms, Spring Http invokers use the standard
			Java serialization mechanism to expose services through HTTP. This has a huge
			advantage if your arguments and return types are complex types that cannot be
			serialized using the serialization mechanisms Hessian and Burlap use (refer to the
			next section for more considerations when choosing a remoting technology).
		</p><p>
			Under the hood, Spring uses either the standard facilities provided by J2SE to
			perform HTTP calls or Commons HttpClient. Use the latter if you need more advanced
			and easy-to-use functionality. Refer to 
			<a href="http://jakarta.apache.org/commons/httpclient" target="_top">jakarta.apache.org/commons/httpclient</a>
			for more info.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12546"></a>16.4.1.&nbsp;Exposing the service object</h3></div></div></div><p>
				Setting up the HTTP invoker infrastructure for a service objects much resembles
				the way you would do using Hessian or Burlap. Just as Hessian support provides
				the <code class="literal">HessianServiceExporter</code>, Spring Http invoker support provides
				the so-called <code class="literal">org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code>.
				To expose the <code class="literal">AccountService</code> (mentioned above), the following
				configuration needs to be in place:
</p><pre class="programlisting">
&lt;bean name="/AccountService" class="org.sprfr.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
  &lt;property name="service" ref="accountService"/&gt;
  &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;
</pre><p>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12563"></a>16.4.2.&nbsp;Linking in the service at the client</h3></div></div></div><p>
				Again, linking in the service from the client much resembles the way you would
				do it when using Hessian or Burlap. Using a proxy, Spring will be able to
				translate your calls to HTTP POST requests to the URL pointing to the exported
				service.
</p><pre class="programlisting">
&lt;bean id="httpInvokerProxy" class="org.sprfr.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
  &lt;property name="serviceUrl" value="http://remotehost:8080/AccountService"/&gt;
  &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;
</pre><p>
			</p><p>
				As mentioned before, you can choose what HTTP client you want to use.
				By default, the HttpInvokerProxy uses the J2SE HTTP functionality, but
				you can also use the Commons HttpClient by setting the <code class="literal">httpInvokerRequestExecutor</code> property:
</p><pre class="programlisting">
&lt;property name="httpInvokerRequestExecutor"&gt;
	&lt;bean class="org.springframework.remoting.httpinvoker.CommonsHttpInvokerRequestExecutor"/&gt;
&lt;/property&gt;
</pre><p>
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12579"></a>16.5.&nbsp;Web Services</h2></div></div></div><p>
			Spring has support for:
			</p><div class="itemizedlist"><ul type="disc" compact><li>Exposing services using JAX-RPC</li><li>Accessing Web Services</li></ul></div><p>
		</p><p>
            Next to the support listed above, you can also expose your web services using
            XFire <a href="http://xfire.codehaus.org" target="_top">xfire.codehaus.org</a>.
            XFire is a ligthweight SOAP library, currently in development at Codehaus.
        </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12595"></a>16.5.1.&nbsp;Exposing services using JAX-RPC</h3></div></div></div><p>
				Spring has a convenience base class for JAX-RPC servlet endpoint implementations -
				<code class="literal">ServletEndpointSupport</code>. To expose our AccountService we extend Spring's ServletEndpointSupport class
				and implement our business logic here, usually delegating the call to the business layer.
</p><pre class="programlisting">
/**
 * JAX-RPC compliant RemoteAccountService implementation that simply delegates
 * to the AccountService implementation in the root web application context.
 *
 * This wrapper class is necessary because JAX-RPC requires working with
 * RMI interfaces. If an existing service needs to be exported, a wrapper that
 * extends ServletEndpointSupport for simple application context access is
 * the simplest JAX-RPC compliant way.
 *
 * This is the class registered with the server-side JAX-RPC implementation.
 * In the case of Axis, this happens in "server-config.wsdd" respectively via
 * deployment calls. The Web Service tool manages the life-cycle of instances
 * of this class: A Spring application context can just be accessed here.
 */
public class AccountServiceEndpoint extends ServletEndpointSupport implements RemoteAccountService {
    
    private AccountService biz;
	
    protected void onInit() {
        this.biz = (AccountService) getWebApplicationContext().getBean("accountService");
    }

    public void insertAccount(Account acc) throws RemoteException {
        biz.insertAccount(acc);
    }
  
    public Account[] getAccounts(String name) throws RemoteException {
        return biz.getAccounts(name);
    }
  
}	
</pre><p>
				Our AccountServletEndpoint needs to run in the same web application as the Spring context to allow for access
				to Spring's facilities. In case of Axis, copy the AxisServlet definition into your web.xml, and set up
				the endpoint in "server-config.wsdd" (or use the deploy tool).
				See the sample application JPetStore where the OrderService is exposed as a Web Service using Axis.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12606"></a>16.5.2.&nbsp;Accessing Web Services</h3></div></div></div><p>
				Spring has two factory beans to create web service proxies <code class="literal">LocalJaxRpcServiceFactoryBean</code> and
				<code class="literal">JaxRpcPortProxyFactoryBean</code>. The former can only return a JAX-RPC Service class for us to work with.
				The latter is the full fledged version that can return a proxy that implements our business service interface.
				In this example we use the later to create a proxy for the AccountService Endpoint we exposed in the previous paragraph.
				You will see that Spring has great support for Web Services requiring little coding efforts - most of the magic is done in
				the spring configuration file as usual:
</p><pre class="programlisting">
    &lt;bean id="accountWebService" class="org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean"&gt;
        &lt;property name="serviceInterface"&gt;
            &lt;value&gt;example.RemoteAccountService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="wsdlDocumentUrl"&gt;
            &lt;value&gt;http://localhost:8080/account/services/accountService?WSDL&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="namespaceUri"&gt;
            &lt;value&gt;http://localhost:8080/account/services/accountService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="serviceName"&gt;
            &lt;value&gt;AccountService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="portName"&gt;
            &lt;value&gt;AccountPort&lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</pre><p>
				Where <code class="literal">serviceInterface</code> is our remote business interface the clients will use.
				<code class="literal">wsdlDocumentUrl</code> is the URL for the WSDL file. Spring needs this a startup time to create the JAX-RPC Service.
				<code class="literal">namespaceUri</code> corresponds to the targetNamespace in the .wsdl file.
				<code class="literal">serviceName</code> corresponds to the serivce name in the .wsdl file.
				<code class="literal">portName</code> corresponds to the port name in the .wsdl file.
			</p><p>
				Accessing the Web Service is now very easy as we have a bean factory for it that will expose it as <code class="literal">RemoteAccountService</code>
				interface. We can wire this up in Spring:
</p><pre class="programlisting">
    &lt;bean id="client" class="example.AccountClientImpl"&gt;
        ...
        &lt;property name="service"&gt;
            &lt;ref bean="accountWebService"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</pre><p>
				And from the client code we can access the Web Service just as if it was a normal class, except that it throws RemoteException.
</p><pre class="programlisting">
public class AccountClientImpl {

    private RemoteAccountService service;
    
    public void setService(RemoteAccountService service) {
        this.service = service;
    }
    
    public void foo() {
       try {
           service.insertAccount(...);
        } catch (RemoteException e) {
           // ouch
           ...
        }
     }
     
}
</pre><p>
			</p><p>
				We can get rid of the checked RemoteException since Spring supports automatic conversion to its corresponding unchecked
				<code class="literal">RemoteAccessException</code>. This requires that we provide a non RMI interface also. Our configuration is now:
</p><pre class="programlisting">
    &lt;bean id="accountWebService" class="org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean"&gt;
        &lt;property name="serviceInterface"&gt;
            &lt;value&gt;example.AccountService&lt;/value&gt;
        &lt;/property&gt;
        &lt;property name="portInterface"&gt;
            &lt;value&gt;example.RemoteAccountService&lt;/value&gt;
        &lt;/property&gt;
        ...
    &lt;/bean&gt;
</pre><p>
				Where <code class="literal">serviceInterface</code> is changed to our non RMI interface. Our RMI interface is now defined using the property
				<code class="literal">portInterface</code>. Our client code can now avoid handling <code class="literal">java.rmi.RemoteException</code>:
</p><pre class="programlisting">
public class AccountClientImpl {

    private AccountService service;
    
    public void setService(AccountService service) {
        this.service = service;
    }
    
    public void foo() {
        service.insertAccount(...);
     }
     
}
</pre><p>
    		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12666"></a>16.5.3.&nbsp;Register Bean Mappings</h3></div></div></div><p>
				To transfer complex objects over the wire such as Account we must register bean mappings on the client side.
				</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td align="left" valign="top"><p>
						On the server side using Axis registering bean mappings is usually done in server-config.wsdd.
					</p></td></tr></table></div><p>
				We will use Axis to register bean mappings on the client side. To do this we need to subclass Spring Bean factory and
				register the bean mappings programmatic:
</p><pre class="programlisting">
public class AxisPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {

	protected void postProcessJaxRpcService(Service service) {
		TypeMappingRegistry registry = service.getTypeMappingRegistry();
		TypeMapping mapping = registry.createTypeMapping();
		registerBeanMapping(mapping, Account.class, "Account");
		registry.register("http://schemas.xmlsoap.org/soap/encoding/", mapping);
	}

	protected void registerBeanMapping(TypeMapping mapping, Class type, String name) {
		QName qName = new QName("http://localhost:8080/account/services/accountService", name);
		mapping.register(type, qName,
		    new BeanSerializerFactory(type, qName),
		    new BeanDeserializerFactory(type, qName));
	}

}
</pre><p>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12678"></a>16.5.4.&nbsp;Registering our own Handler</h3></div></div></div><p>
				In this section we will register our own <code class="literal">javax.rpc.xml.handler.Handler</code> to the Web Service Proxy
				where we can do custom code before the SOAP message is sent over the wire.
				The <code class="literal">javax.rpc.xml.handler.Handler</code> is a callback interface. There is a convenience base class provided
				in jaxrpc.jar -	<code class="literal">javax.rpc.xml.handler.GenericHandler</code> that we will extend:
</p><pre class="programlisting">
public class AccountHandler extends GenericHandler {

    public QName[] getHeaders() {
        return null;
    }

    public boolean handleRequest(MessageContext context) {
        SOAPMessageContext smc = (SOAPMessageContext) context;
        SOAPMessage msg = smc.getMessage();

        try {
            SOAPEnvelope envelope = msg.getSOAPPart().getEnvelope();
            SOAPHeader header = envelope.getHeader();
            ...
		
        } catch (SOAPException e) {
            throw new JAXRPCException(e);
        }

        return true;
    }

}
</pre><p>
			What we need to do now is to register our AccountHandler to JAX-RPC Service so it would invoke <code class="literal">handleRequest</code>
			before the message is sent over the wire. Spring has at this time of writing no declarative support for registering handlers.
			So we must use the programmatic approach. However Spring has made it very easy for us to do this as we can extend its bean factory
			and override its <code class="literal">postProcessJaxRpcService</code> method that is designed for this: 
</p><pre class="programlisting">
public class AccountHandlerJaxRpcPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {

    protected void postProcessJaxRpcService(Service service) {
        QName port = new QName(this.getNamespaceUri(), this.getPortName());
        List list = service.getHandlerRegistry().getHandlerChain(port);
        list.add(new HandlerInfo(AccountHandler.class, null, null));

        logger.info("Registered JAX-RPC Handler [" + AccountHandler.class.getName() + "] on port " + port);
    }

}
</pre><p>
			And the last thing we must remember to do is to change the Spring configuration to use our factory bean:
</p><pre class="programlisting">
    &lt;bean id="accountWebService" class="example.AccountHandlerJaxRpcPortProxyFactoryBean"&gt;
        ...
    &lt;/bean&gt;    
</pre><p>
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e12707"></a>16.5.5.&nbsp;Exposing web services using XFire</h3></div></div></div><p>
                XFire is a lightweight SOAP library, hosted by Codehaus. At the time of writing (March 2005), XFire
                is still in development. Although Spring support is stable, lots of features should be added in the future.
                Exposing XFire is done using an XFire context that shipping with XFire itself in combination with a
                RemoteExporter-style bean you have to add to your WebApplicationContext.
            </p><p>
                As with all methods that allow you to expose service, you have to create a DispatcherServlet with
                a corresponding WebApplicationContext containing the services you will be exposing:
                </p><pre class="programlisting">
&lt;servlet&gt;
  &lt;servlet-name&gt;xfire&lt;/servlet-name&gt;
  &lt;servlet-class&gt;
    org.springframework.web.servlet.DispatcherServlet
  &lt;/servlet-class&gt;
&lt;/servlet&gt;
                </pre><p>
            </p><p>
                You also have to link in the XFire configuration. This is done by adding a context file to the
                <code class="literal">contextConfigLocations</code> context parameter picked up by the ContextLoaderListener
                (or Servlet for that matter). The configuration file is located in the XFire jar and should of course
                be placed on the classpath of your application archive.
                </p><pre class="programlisting">
&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;
    classpath:org/codehaus/xfire/spring/xfire.xml
  &lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
  &lt;listener-class&gt;
    org.springframework.web.context.ContextLoaderListener
  &lt;/listener-class&gt;
&lt;/listener&gt;
                </pre><p>
            </p><p>
              After you added a servlet mapping (mapping /* to the XFire servlet declared above) you only have to add
              one extra bean to expose the service using XFire. Add for example the following you <code class="literal">xfire-servlet.xml</code>:
              </p><pre class="programlisting">
&lt;beans&gt;
  &lt;bean name="/Echo" class="org.codehaus.xfire.spring.XFireExporter"&gt;
    &lt;property name="service" ref="echo"&gt;
    &lt;property name="serviceInterface" value="org.codehaus.xfire.spring.Echo"/&gt;
    &lt;property name="serviceBuilder" ref="xfire.serviceBuilder"/&gt;
    &lt;!-- the XFire bean is wired up in the xfire.xml file you've linked in earlier
    &lt;property name="xfire" ref="xfire"/&gt;
  &lt;/bean&gt;

  &lt;bean id="echo" class="org.codehaus.xfire.spring.EchoImpl"/&gt;
&lt;/beans&gt;
</pre><p>
            </p><p>
              XFire handles the rest. It introspects your service interface and generates a WSDL from it.
              Parts of this documentation have been taken from the XFire site. For more detailed information on XFire
              Spring integration, have a look at the <a href="http://docs.codehaus.org/display/XFIRE/Spring" target="_top">docs.codehaus.org/display/XFIRE/Spring</a>.
            </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12738"></a>16.6.&nbsp;Auto-detection is not implemented for remote interfaces</h2></div></div></div><p>
            The main reason why auto-detection of implemented interfaces does not occur for
            remote interfaces is to avoid opening too many doors to remote callers. The target
            object might implement internal callback interfaces like InitializingBean or
            DisposableBean which one would not want to expose to callers.
        </p><p>
            Offering a proxy with all interfaces implemented by the target usually does not
            matter in the local case. But when exporting a remote service, you should expose
            a specific service interface, with specific operations intended for remote usage.
            Besides internal callback interfaces, the target might implement multiple business
            interfaces, with just one of them intended for remote exposure. For these reasons,
            we <span class="emphasis"><em>require</em></span> such a service interface to be specified.
        </p><p>
            This is a trade-off between configuration convenience and the risk of accidental
            exposure of internal methods. Always specifying a service interface is not too much
            effort, and puts you on the safe side regarding controlled exposure of specific
            methods.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12750"></a>16.7.&nbsp;Considerations when choosing a technology</h2></div></div></div><p>
			Each and every technology presented here has its drawbacks. You should carefully
			consider you needs, the services your exposing and the objects you'll be sending
			over the wire when choosing a technology.
		</p><p>
			When using RMI, it's not possible to access the objects through the HTTP protocol,
			unless you're tunneling the RMI traffic. RMI is a fairly heavy-weight protocol
			in that it support full-object serialization which is important when using a
			complex data model that needs serialization over the wire. However, RMI-JRMP
			is tied to Java clients: It is a Java-to-Java remoting solution.
		</p><p>
			Spring's HTTP invoker is a good choice if you need HTTP-based remoting but also
			rely on Java serialization. It shares the basic infrastructure with RMI invokers,
			just using HTTP as transport. Note that HTTP invokers are not only limited to
			Java-to-Java remoting but also to Spring on both the client and server side.
			(The latter also applies to Spring's RMI invoker for non-RMI interfaces.)
		</p><p>
			Hessian and/or Burlap might provide significant value when operating in a
			heterogeneous environment, because they explicitly allow for non-Java clients.
			However, non-Java support is still limited. Known problems include the serialization
			of Hibernate objects in combination with lazily initializing collections. If you
			have such a data model, consider using RMI or HTTP invokers instead of Hessian.
		</p><p>
			JMS can be useful for providing clusters of services and allowing the JMS broker
      to take care of load balancing, discovery and auto-failover.
      By default Java serialization is used when using JMS remoting but
      the JMS provider could use a different mechanism for the wire formatting,
      such as XStream to allow servers to be implemented in other technologies.
		</p><p>
			Last but not least, EJB has an advantage over RMI in that it supports standard
			role-based authentication and authorization and remote transaction propagation.
			It is possible to get RMI invokers or HTTP invokers to support security context
			propagation as well, although this is not provided by core Spring: There are
			just appropriate hooks for plugging in third-party or custom solutions here.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ejb"></a>Chapter&nbsp;17.&nbsp;Accessing and implementing EJBs</h2></div></div></div><p>As a lightweight container, Spring is often considered an EJB
  replacement. We do believe that for many if not most applications and use
  cases, Spring as a container, combined with its rich supporting
  functionality in the area of transactions, ORM and JDBC access, is a better
  choice than implementing equivalent functionality via an EJB container and
  EJBs.</p><p>However, it is important to note that using Spring does not prevent
  you from using EJBs. In fact, Spring makes it much easier to access EJBs and
  implement EJBs and functionality within them. Additionally, using Spring to
  access services provided by EJBs allows the implementation of those services
  to later transparently be switched between local EJB, remote EJB, or POJO
  (plain java object) variants, without the client code client code having to
  be changed.</p><p>In this chapter, we look at how Spring can help you access and
  implement EJBs. Spring provides particular value when accessing stateless
  session beans (SLSBs), so we'll begin by discussing this.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ejb-access"></a>17.1.&nbsp;Accessing EJBs</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-concepts"></a>17.1.1.&nbsp;Concepts</h3></div></div></div><p>To invoke a method on a local or remote stateless session bean,
      client code must normally perform a JNDI lookup to obtain the (local or
      remote) EJB Home object, then use a 'create' method call on that object
      to obtain the actual (local or remote) EJB object. One or more methods
      are then invoked on the EJB.</p><p>To avoid repeated low-level code, many EJB applications use the
      Service Locator and Business Delegate patterns. These are better than
      spraying JNDI lookups throughout client code, but their usual
      implementations have significant disadvantages. For example:</p><div class="itemizedlist"><ul type="disc"><li><p>Typically code using EJBs depends on Service Locator or
          Business Delegate singletons, making it hard to test</p></li><li><p>In the case of the Service Locator pattern used without a
          Business Delegate, application code still ends up having to invoke
          the create() method on an EJB home, and deal with the resulting
          exceptions. Thus it remains tied to the EJB API and the complexity
          of the EJB programming model.</p></li><li><p>Implementing the Business Delegate pattern typically results
          in significant code duplication, where we have to write numerous
          methods that simply call the same method on the EJB.</p></li></ul></div><p>The Spring approach is to allow the creation and use of proxy
      objects, normally configured inside a Spring ApplicationContext or
      BeanFactory, which act as code-less business delegates. You do not need
      to write another Service Locator, another JNDI lookup, or duplicate
      methods in a hand-coded Business Delegate unless you&#8217;re adding real
      value.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-local"></a>17.1.2.&nbsp;Accessing local SLSBs</h3></div></div></div><p>Assume that we have a web controller that needs to use a local
      EJB. We&#8217;ll follow best practice and use the EJB Business Methods
      Interface pattern, so that the EJB&#8217;s local interface extends a non
      EJB-specific business methods interface. Let&#8217;s call this business
      methods interface MyComponent.</p><pre class="programlisting">public interface MyComponent {
    ...
}</pre><p>(One of the main reasons to the Business Methods Interface pattern
      is to ensure that synchronization between method signatures in local
      interface and bean implementation class is automatic. Another reason is
      that it later makes it much easier for us to switch to a POJO (plain
      java object) implementation of the service if it makes sense to do so)
      Of course we&#8217;ll also need to implement the local home interface and
      provide a bean implementation class that implements SessionBean and the
      MyComponent business methods interface. Now the only Java coding we&#8217;ll
      need to do to hook up our web tier controller to the EJB implementation
      is to expose a setter method of type MyComponent on the controller. This
      will save the reference as an instance variable in the
      controller:</p><pre class="programlisting">private MyComponent myComponent;

public void setMyComponent(MyComponent myComponent) {
    this.myComponent = myComponent;
}</pre><p>We can subsequently use this instance variable in any business
      method in the controller. Now assuming we are obtaining our controller
      object out of a Spring ApplicationContext or BeanFactory, we can in the
      same context configure a
      <code class="literal">LocalStatelessSessionProxyFactoryBean</code> instance, which
      will be EJB proxy object. The configuration of the proxy, and setting of
      the <code class="literal">myComponent</code> property of the controller is done
      with a configuration entry such as:</p><pre class="programlisting">&lt;bean id="myComponent"
      class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
  &lt;property name="jndiName" value="myComponent"/&gt;
  &lt;property name="businessInterface" value="com.mycom.MyComponent"/&gt;
&lt;/bean&gt;

&lt;bean id="myController" class="com.mycom.myController"&gt;
  &lt;property name="myComponent" ref="myComponent"/&gt;
&lt;/bean&gt;</pre><p>There&#8217;s a lot of magic happening behind the scenes, courtesy of
      the Spring AOP framework, although you aren&#8217;t forced to work with AOP
      concepts to enjoy the results. The <code class="literal">myComponent</code> bean
      definition creates a proxy for the EJB, which implements the business
      method interface. The EJB local home is cached on startup, so there&#8217;s
      only a single JNDI lookup. Each time the EJB is invoked, the proxy
      invokes the create() method on the local EJB and invokes the
      corresponding business method on the EJB.</p><p>The <code class="literal">myController</code> bean definition sets the
      <code class="literal">myController</code> property of the controller class to this
      proxy.</p><p>This EJB access mechanism delivers huge simplification of
      application code: The web tier code (or other EJB client code) has no
      dependence on the use of EJB. If we want to replace this EJB reference
      with a POJO or a mock object or other test stub, we could simply change
      the myComponent bean definition without changing a line of Java code.
      Additionally, we haven&#8217;t had to write a single line of JNDI lookup or
      other EJB plumbing code as part of our application.</p><p>Benchmarks and experience in real applications indicate that the
      performance overhead of this approach (which involves reflective
      invocation of the target EJB) is minimal, and undetectable in typical
      use. Remember that we don&#8217;t want to make fine-grained calls to EJBs
      anyway, as there&#8217;s a cost associated with the EJB infrastructure in the
      application server.</p><p>There is one caveat with regards to the JNDI lookup. In a bean
      container, this class is normally best used as a singleton (there simply
      is no reason to make it a prototype). However, if that bean container
      pre-instantiates singletons (as do the XML ApplicationContext variants)
      you may have a problem if the bean container is loaded before the EJB
      container loads the target EJB. That is because the JNDI lookup will be
      performed in the init method of this class and cached, but the EJB will
      not have been bound at the target location yet. The solution is to not
      pre-instantiate this factory object, but allow it to be created on first
      use. In the XML containers, this is controlled via the
      <code class="literal">lazy-init</code> attribute.</p><p>Although this will not be of interest to the majority of Spring
      users, those doing programmatic AOP work with EJBs may want to look at
      <code class="literal">LocalSlsbInvokerInterceptor</code>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-remote"></a>17.1.3.&nbsp;Accessing remote SLSBs</h3></div></div></div><p>Accessing remote EJBs is essentially identical to accessing local
      EJBs, except that the
      <code class="literal">SimpleRemoteStatelessSessionProxyFactoryBean</code> is used.
      Of course, with or without Spring, remote invocation semantics apply; a
      call to a method on an object in another VM in another computer does
      sometimes have to be treated differently in terms of usage scenarios and
      failure handling.</p><p>Spring's EJB client support adds one more advantage over the
      non-Spring approach. Normally it is problematic for EJB client code to
      be easily switched back and forth between calling EJBs locally or
      remotely. This is because the remote interface methods must declare that
      they throw <code class="literal">RemoteException</code>, and client code must deal
      with this, while the local interface methods don't. Client code
      written for local EJBs which needs to be moved to remote EJBs
      typically has to be modified to add handling for the remote exceptions,
      and client code written for remote EJBs which needs to be moved to local
      EJBs, can either stay the same but do a lot of unnecessary handling of
      remote exceptions, or needs to be modified to remove that code. With the
      Spring remote EJB proxy, you can instead not declare any thrown
      <code class="literal">RemoteException</code> in your Business Method Interface and
      implementing EJB code, have a remote interface which is identical except
      that it does throw <code class="literal">RemoteException</code>, and rely on the
      proxy to dynamically treat the two interfaces as if they were the same.
      That is, client code does not have to deal with the checked
      <code class="literal">RemoteException</code> class. Any actual
      <code class="literal">RemoteException</code> that is thrown during the EJB
      invocation will be re-thrown as the non-checked
      <code class="literal">RemoteAccessException</code> class, which is a subclass of
      <code class="literal">RuntimeException</code>. The target service can then be
      switched at will between a local EJB or remote EJB (or even plain Java
      object) implementation, without the client code knowing or caring. Of
      course, this is optional; there is nothing stopping you from declaring
      <code class="literal">RemoteExceptions</code> in your business interface.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ejb-implementation"></a>17.2.&nbsp;Using Spring convenience EJB implementation classes</h2></div></div></div><p>Spring also provides convenience classes to help you implement EJBs.
    These are designed to encourage the good practice of putting business
    logic behind EJBs in POJOs, leaving EJBs responsible for transaction
    demarcation and (optionally) remoting.</p><p>To implement a Stateless or Stateful session bean, or Message Driven
    bean, you derive your implementation class from
    <code class="literal">AbstractStatelessSessionBean</code>,
    <code class="literal">AbstractStatefulSessionBean</code>, and
    <code class="literal">AbstractMessageDrivenBean</code>/<code class="literal">AbstractJmsMessageDrivenBean</code>,
    respectively.</p><p>Consider an example Stateless Session bean which actually delegates
    the implementation to a plain java service object. We have the business
    interface:</p><pre class="programlisting">public interface MyComponent {
    public void myMethod(...);
    ...
}</pre><p>We have the plain java implementation object:</p><pre class="programlisting">public class MyComponentImpl implements MyComponent {
    public String myMethod(...) {
        ...
    }
    ...
}</pre><p>And finally the Stateless Session Bean itself:</p><pre class="programlisting">public class MyComponentEJB extends AbstractStatelessSessionBean
        implements MyComponent {

    MyComponent _myComp;

    /**
     * Obtain our POJO service object from the BeanFactory/ApplicationContext
     * @see org.springframework.ejb.support.AbstractStatelessSessionBean#onEjbCreate()
     */
    protected void onEjbCreate() throws CreateException {
        _myComp = (MyComponent) getBeanFactory().getBean(
            ServicesConstants.CONTEXT_MYCOMP_ID);
    }

    // for business method, delegate to POJO service impl.
    public String myMethod(...) {
        return _myComp.myMethod(...);
    }
    ...
}</pre><p>The Spring EJB support base classes will by default create and load
    a BeanFactory (or in this case, its ApplicationContext subclass) as part
    of their lifecycle, which is then available to the EJB (for example, as
    used in the code above to obtain the POJO service object). The loading is
    done via a strategy object which is a subclass of
    <code class="literal">BeanFactoryLocator</code>. The actual implementation of
    <code class="literal">BeanFactoryLocator</code> used by default is
    <code class="literal">ContextJndiBeanFactoryLocator</code>, which creates the
    ApplicationContext from a resource locations specified as a JNDI
    environment variable (in the case of the EJB classes, at
    <code class="literal">java:comp/env/ejb/BeanFactoryPath</code>). If there is a need
    to change the BeanFactory/ApplicationContext loading strategy, the default
    <code class="literal">BeanFactoryLocator</code> implementation used may be overridden
    by calling the <code class="literal">setBeanFactoryLocator()</code> method, either
    in <code class="literal">setSessionContext()</code>, or in the actual constructor of
    the EJB. Please see the JavaDocs for more details.</p><p>As described in the JavaDocs, Stateful Session beans expecting to be
    passivated and reactivated as part of their lifecycle, and which use a
    non-serializable BeanFactory/ApplicationContext instance (which is the
    normal case) will have to manually call
    <code class="literal">unloadBeanFactory()</code> and
    <code class="literal">loadBeanFactory</code> from <code class="literal">ejbPassivate</code>
    and <code class="literal">ejbActivate</code>, respectively, to unload and reload the
    BeanFactory on passivation and activation, since it can not be saved by
    the EJB container.</p><p>The default usage of
    <code class="literal">ContextJndiBeanFactoryLocator</code> to load an
    ApplicationContext for the use of the EJB is adequate for some situations.
    However, it is problematic when the ApplicationContext is loading a number
    of beans, or the initialization of those beans is time consuming or memory
    intensive (such as a Hibernate SessionFactory initialization, for
    example), since every EJB will have their own copy. In this case, the user
    may want to override the default
    <code class="literal">ContextJndiBeanFactoryLocator</code> usage and use another
    <code class="literal">BeanFactoryLocator </code>variant, such as
    <code class="literal">ContextSingleton<code class="literal">BeanFactoryLocator</code>e</code>,
    which can load and use a shared BeanFactory or ApplicationContext to be
    used by multiple EJBs or other clients. Doing this is relatively simple,
    by adding code similar to this to the EJB:</p><pre class="programlisting">   /**
    * Override default BeanFactoryLocator implementation
    * 
    * @see javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)
    */
   public void setSessionContext(SessionContext sessionContext) {
       super.setSessionContext(sessionContext);
       setBeanFactoryLocator(ContextSingletonBeanFactoryLocator.getInstance());
       setBeanFactoryLocatorKey(ServicesConstants.PRIMARY_CONTEXT_ID);
   }</pre><p>Please see the respective JavaDocs for
    <code class="literal">BeanFactoryLocator</code> and
    <code class="literal">ContextSingleton<code class="literal">BeanFactoryLocator</code>e</code>
    for more information on their usage.</p><p></p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jms"></a>Chapter&nbsp;18.&nbsp;JMS</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e12980"></a>18.1.&nbsp;Introduction</h2></div></div></div><p>Spring provides a JMS abstraction framework that simplifies
    the use of the JMS API and shields the user from differences between
    the JMS 1.0.2 and 1.1 APIs.
    </p><p>JMS can be roughly divided into two areas of
    functionality, production and consumption of messages.  In a
    J2EE environment, the ability to consume messages 
    asynchronously is provided for by message-driven beans while in a
    standalone application this is provided for by the creation 
    of MessageListeners or ConnectionConsumers.  The functionality 
    in JmsTemplate is focused on producing messages.  Future releases
    of Spring will address asynchronous message consumption in a standalone 
    environment.
    </p><p>The package <code class="literal">org.springframework.jms.core</code> provides 
    the core functionality for using JMS.  
    It contains JMS template classes 
    that simplifies the use of the JMS by handling the creation and release 
    of resources, much like the <code class="literal">JdbcTemplate</code> does for JDBC.  

    The design principle common to Spring template classes is to
    provide helper methods to perform common operations and for more
    sophisticated usage, delegate the essence of the processing 
    task to user implemented callback interfaces.  The JMS template
    follows the same design.  The classes offer various convenience methods 
    for the sending of messages, consuming a message synchronously, and 
    exposing the JMS session and message producer to the user.
    </p><p>
    The package <code class="literal">org.springframework.jms.support</code>
    provides JMSException translation functionality.  The translation
    converts the checked JMSException hierarchy to a mirrored hierarchy 
    of unchecked exceptions.  If there are any provider specific subclasses 
    of the checked javax.jms.JMSException, this exception is wrapped in the 
    unchecked UncategorizedJmsException.
    The package <code class="literal">org.springframework.jms.support.converter</code>
    provides a MessageConverter abstraction to convert between
    Java objects and JMS messages.  The package 
    <code class="literal">org.springframework.jms.support.destination</code> provides
    various strategies for managing JMS destinations, such as providing
    a service locator for destinations stored in JNDI.
    </p><p>Finally, the package
    <code class="literal">org.springframework.jms.connection</code>
    provides an implementation of the ConnectionFactory suitable for use
    in standalone applications.  It also contains an implementation
    of Spring's <code class="literal">PlatformTransactionManager</code>
    for JMS.  This allows for integration of JMS as a transactional
    resource into Spring's transaction management mechanisms.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13014"></a>18.2.&nbsp;Domain unification</h2></div></div></div><p>There are two major releases of the JMS specification, 1.0.2 
    and 1.1.  JMS 1.0.2 defined two types of messaging domains, 
    point-to-point (Queues) and publish/subscribe (Topics).
    The 1.0.2 API reflected these two
    messaging domains by providing a parallel class hierarchy for each domain.
    Consequentially, a client application was domain specific in the use of
    the JMS API.  JMS 1.1 introduced the concept of domain unification 
    that minimized both the functional differences and client API 
    differences between the two domains.  As an example of a functional 
    difference that was removed, if you use a JMS 1.1 provider you can 
    transactionally consume a message from one domain and produce a message
    on the other using the same <code class="literal">Session</code>.
    </p><p>The JMS 1.1 specification was released in April 2002 and
    incorporated as part of J2EE 1.4 in November 2003.
    As a result, most application servers that are currently in use 
    are only required to support JMS 1.0.2.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13024"></a>18.3.&nbsp;JmsTemplate</h2></div></div></div>
    Two implementations of the JmsTemplate are provided.  The class
    <code class="literal">JmsTemplate</code> uses the JMS 1.1 API and the
    subclass <code class="literal">JmsTemplate102</code> uses the JMS 1.0.2 API.
    <p>Code that uses the JmsTemplate only needs to implement callback
    interfaces giving them a clearly defined contract.  The 
    <code class="literal">MessageCreator</code> callback interface creates a message
    given a Session provided by the calling code in JmsTemplate.
    In order to allow
    for more complex usage of the JMS API, the callback  
    <code class="literal">SessionCallback</code> provides the user with the JMS
    session and the callback <code class="literal">ProducerCallback</code> exposes
    a Session and MessageProducer pair.
    </p><p>
    The JMS API exposes two types of send methods, one that takes 
    delivery mode, priority, and time-to-live as quality of service 
    (QOS) parameters and one that takes no QOS parameters which uses
    default values.  Since there are many send methods in JmsTemplate, 
    the setting of the QOS parameters have been exposed as bean
    properties to avoid duplication in the number 
    of send methods.  Similarly, the timeout value for
    synchronous receive calls is set using the property
    <code class="literal">setReceiveTimeout</code>.
    </p><p>
    Some JMS providers allow the setting of default QOS
    values administratively through the configuration of the 
    ConnectionFactory.
    This has the effect that a call to MessageProducer's send method
    <code class="literal">send(Destination destination, Message message)</code>
    will use QOS different default values than those specified in the
    JMS specification.   Therefore, in order to provide consistent
    management of QOS values, the JmsTemplate must be specifically
    enabled to use its own QOS values by setting the boolean property
    <code class="literal">isExplicitQosEnabled</code> to true.  
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13058"></a>18.3.1.&nbsp;ConnectionFactory</h3></div></div></div><p>The JmsTemplate requires a reference to 
      a <code class="literal">ConnectionFactory</code>.  
      The <code class="literal">ConnectionFactory</code> is part of the JMS
      specification and serves as the entry point for working with JMS.
      It is used by the client application as a factory to 
      create connections with the JMS provider and encapsulates various 
      configuration parameters, many of which are vendor specific such 
      as SSL configuration options.
      </p><p>
      When using JMS inside an EJB the vendor provides implementations
      the JMS interfaces so that they can participate in declarative
      transaction management and perform pooling of connections
      and session.  In order to use this implementation, 
      J2EE containers typically require that you declare a 
      JMS connection factory as a <code class="literal">resource-ref</code>
      inside the EJB or servlet deployment descriptors.  To ensure
      the use of these features with the JmsTemplate inside an EJB,
      the client application should ensure that it references the managed 
      implementation of the ConnectionFactory. 
      </p><p>Spring provides an implementation of the ConnectionFactory
      interface, <code class="literal">SingleConnectionFactory</code>, that 
      will return the same Connection on all
      <code class="literal">createConnection</code> calls and ignore calls
      to <code class="literal">close.</code>  This is useful for testing and
      standalone environments so that the same connection can be
      used for multiple JmsTemplate calls that may span any number of
      transactions.  SingleConnectionFactory takes a reference to
      a standard ConnectionFactory that would typically comes from JNDI.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13085"></a>18.3.2.&nbsp;Transaction Management</h3></div></div></div><p>Spring provides a <code class="literal">JmsTransactionManager</code> 
      that manages transactions for a single JMS ConnectionFactory.  
      This allows JMS applications to leverage the managed transaction 
      features of Spring as described in <code class="literal">Chapter 7</code>.
      The <code class="literal">JmsTransactionManager</code> binds a Connection/Session
      pair from the specified ConnectionFactory to the thread.  However,
      in a J2EE environment the ConnectionFactory will pool connections 
      and sessions, so the instances that are bound to the thread depend
      on the pooling behavior.  In a standalone environment, using Spring's
      <code class="literal">SingleConnectionFactory</code> will result in a 
      using a single JMS Connection and each transaction having its own
      Session.  The <code class="literal">JmsTemplate</code> can also be used with 
      the <code class="literal">JtaTransactionManager</code> and an XA-capable
      JMS ConnectionFactory for performing distributed transactions.
      </p><p>Reusing code across a managed and unmanaged transactional 
      environment can be confusing when using JMS API to create
      a <code class="literal">Session</code> from a Connection.
      This is because the JMS API only has only one 
      factory method to create a Session and it requires values for 
      the transaction and acknowledgement modes.  In a managed environment, 
      setting these values in the responsibility of the environments
      transactional infrastructure, so these values are ignored by the 
      vendor's wrapper to the JMS Connection.
      When using the <code class="literal">JmsTemplate</code> in an unmanaged
      environment you can specify these values
      though the use of the properties <code class="literal">SessionTransacted</code>
      and <code class="literal">SessionAcknowledgeMode</code>.
      When using a <code class="literal">PlatformTransactionManager</code> with 
      <code class="literal">JmsTemplate</code>, the template will always be
      given a transactional JMS Session.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13128"></a>18.3.3.&nbsp;Destination Management</h3></div></div></div><p>Destinations, like ConnectionFactories, are JMS administered
      objects that can be stored and retrieved in JNDI.  When
      configuring a Spring application context one can use the
      JNDI factory class <code class="literal">JndiObjectFactoryBean</code> to
      perform dependency injection on your object's references to
      JMS destinations.  However, often this strategy is cumbersome if
      there are a large number of destinations in the application or if there
      are advanced destination management features unique to the JMS provider.
      Examples of such advanced destination management would be the
      creation of dynamic destinations or support for a hierarchical 
      namespace of destinations.
      The JmsTemplate delegates the resolution of a destination name
      to a JMS destination object to an implementation of the 
      interface <code class="literal">DestinationResolver</code>.
      <code class="literal">DynamicDestinationResolver</code> is the
      default implementation used by <code class="literal">JmsTemplate</code> and
      accommodates resolving dynamic destinations.  
      A <code class="literal">JndiDestinationResolver</code> is also provided that
      acts as a service locator for destinations contained in JNDI and 
      optionally falls back to the behavior contained in 
      <code class="literal">DynamicDestinationResolver</code>. 
      </p><p>Quite often the destinations used in a JMS application are only 
      known at runtime and therefore can not be administratively created 
      when the application is deployed.  This is often because there is 
      shared application logic between interacting system components that 
      create destinations at runtime according to a well known naming 
      convention.  Even though the creation of dynamic destinations
      are not part of the JMS specification, 
      most vendors have provided this functionality.
      Dynamic destinations are created with
      a name defined by the user which differentiates them from temporary
      destinations and are often not registered in JNDI.  
      The API used to create dynamic destinations varies from provider to
      provider since the properties associated with the destination are
      vendor specific.  However, a simple implementation choice that is
      sometimes made by vendors is to disregard the warnings in the JMS
      specification and to use the <code class="literal">TopicSession</code> method 
      <code class="literal">createTopic(String topicName)</code> or the 
      <code class="literal">QueueSession</code> method 
      <code class="literal">createQueue(String queueName)</code>
      to create a new destination with default destination properties.
      Depending on the vendor implementation, 
      <code class="literal">DynamicDestinationResolver</code> may then also 
      create a physical destination instead of only resolving one.
      </p><p>The boolean property <code class="literal">PubSubDomain</code> is used 
      to configure the <code class="literal">JmsTemplate</code>
      with knowledge of what JMS domain is being used.  By default the
      value of this property is false, indicating that the point-to-point
      domain, Queues, will be used.  In the 1.0.2 implementation the value
      of this property determines if the JmsTemplate's send operations will
      send a message to a Queue or to a Topic.  This flag has no effect on send
      operations for the 1.1 implementation.  However, in both implementations,
      this property determines the behavior of resolving dynamic 
      destination via implementations of 
      <code class="literal">DestinationResolver</code>.
      </p><p>You can also configure the JmsTemplate with a default destination
      via the property <code class="literal">DefaultDestination</code>.  The default
      destination will be used with send and receive operations that do not 
      refer to a specific destination.
      </p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13184"></a>18.4.&nbsp;Using the JmsTemplate</h2></div></div></div><p>To get started using the JmsTemplate you need to select either the
    JMS 1.0.2 implementation <code class="literal">JmsTemplate102</code> or the
    JMS 1.1 implementation <code class="literal">JmsTemplate</code>. Check your
    JMS provider to determine what version is supported.  
    </p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13195"></a>18.4.1.&nbsp;Sending a message</h3></div></div></div><p>The JmsTemplate contains many convenience methods to send a message.
      There are send methods that specify the destination using a 
      <code class="literal">javax.jms.Destination</code> object and those that
      specify the destination using a string for use in a JNDI lookup.
      The send method that takes no destination argument uses the
      default destination. Here is an example that sends a message to
      a queue using the 1.0.2 implementation.
      </p><pre class="programlisting">import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.core.MessageCreator;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;

public class JmsQueueSender {

  private JmsTemplate jmsTemplate;

  private Queue queue;

  public void setConnectionFactory(ConnectionFactory cf) {
    jt = new JmsTemplate102(cf, false);
  }

  public void setQueue(Queue q) {
    queue = q;
  }

  public void simpleSend() {
    this.jmsTemplate.send(this.queue, new MessageCreator() {
      public Message createMessage(Session session) throws JMSException {
        return session.createTextMessage("hello queue world");
      }
    });
  }
}
      </pre><p>This example uses the <code class="literal">MessageCreator</code> callback 
      to create a text message from the supplied Session object and the
      JmsTemplate is constructed by passing a reference to a ConnectionFactory
      and a boolean specifying the messaging domain.
      A zero argument constructor and <code class="literal">connectionFactory</code> /
      <code class="literal">queue</code> bean properties are provided and can be used
      for constructing the instance (using a BeanFactory or plain Java code).
      Alternatively, consider deriving from Spring's
      <code class="literal">JmsGatewaySupport</code> convenience base class, which
      provides pre-built bean properties for JMS configuration.
 </p><p>When configuring the JMS 1.0.2 support in an application context,
      it is important to remember setting the value of the 
      boolean property <code class="literal">pubSubDomain</code> property in order
      to indicate if you want to send to Queues or Topics.</p><p>The method 
      <code class="literal">send(String destinationName, MessageCreator creator)</code>
      lets you send to a message using the string name of the destination.
      If these names are registered in JNDI, you should set
      the <code class="literal">DestinationResolver</code> property of the template
      to an instance of <code class="literal">JndiDestinationResolver</code>.
      </p><p>If you created the JmsTemplate and specified a default 
      destination, the <code class="literal">send(MessageCreator c)</code>
      sends a message to that destination.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13240"></a>18.4.2.&nbsp;Synchronous Receiving</h3></div></div></div><p>While JMS is typically associated with asynchronous processing, it
      is possible to consume messages synchronously.  The overloaded
      <code class="literal">receive</code> methods provide this functionality.
      During a synchronous receive the calling thread blocks until a 
      message becomes available.  This can be a dangerous operation since
      the calling thread can potentially be blocked indefinitely.  The
      property <code class="literal">receiveTimeout</code> specifies how long
      the receiver should wait before giving up waiting for a message.
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13251"></a>18.4.3.&nbsp;Using Message Converters</h3></div></div></div><p>In order to facilitate the sending 
      of domain model objects the <code class="literal">JmsTemplate</code> 
      has various send methods that take a Java object as an argument 
      for a message's  data content.  
      The overloaded methods 
      <code class="literal">convertAndSend</code> and 
      <code class="literal">receiveAndConvert</code> in
      <code class="literal">JmsTemplate</code> delegate the conversion process to
      an instance of the <code class="literal">MessageConverter</code> interface.
      This interface defines a simple contract to convert between
      Java objects and JMS messages. The default
      implementation, <code class="literal">SimpleMessageConverter</code> 
      supports conversion between <code class="literal">String</code> and 
      <code class="literal">TextMessage</code>, <code class="literal">byte[]</code> and
      <code class="literal">BytesMesssage</code>, and <code class="literal">java.util.Map</code>
      and <code class="literal">MapMessage</code>.
      By using the converter, you
      your application code can focus on the business object that is 
      being sent or received via JMS and not bother with the details of 
      how it is represented as a JMS  message.  
      </p><p>
      The sandbox currently includes a 
      <code class="literal">MapMessageConverter</code> which uses reflection
      to convert between a JavaBean and a MapMessage.  
      Other popular implementations choices you might implement yourself
      are Converters that bust an existing XML marshalling packages, such as 
      JAXB, Castor, XMLBeans, or XStream, to create a TextMessage 
      representing the object.  
      </p><p>To accommodate the setting of a message's properties, 
      headers, and body that can not be generically encapsulated inside 
      a converter class, the interface <code class="literal">MessagePostProcessor</code>
      gives you access to the message after it has been converted, but before
      it is sent.  The example below shows how to modify a message header and 
      a property after a <code class="literal">java.util.Map</code> is
      converted to a message.
      </p><pre class="programlisting">
public void sendWithConversion() {
  Map m = new HashMap();
  m.put("Name", "Mark");
  m.put("Age", new Integer(35));
  jt.convertAndSend("testQueue", m, new MessagePostProcessor() {
    public Message postProcessMessage(Message message) throws JMSException {
      message.setIntProperty("AccountID", 1234);
      message.setJMSCorrelationID("123-00001");
      return message;
    }
  });
}
      </pre><p>This results in a message of the form
      </p><pre class="programlisting">
MapMessage={ 
  Header={ 
    ... standard headers ...
    CorrelationID={123-00001} 
  } 
  Properties={ 
    AccountID={Integer:1234}
  } 
  Fields={ 
    Name={String:Mark} 
    Age={Integer:35} 
  } 
}
      </pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13311"></a>18.4.4.&nbsp;SessionCallback and ProducerCallback</h3></div></div></div><p>
        While the send operations cover many common usage scenarios, there
        are cases when you want to perform multiple operations on a
        JMS Session or MessageProducer.  The <code class="literal">SessionCallback</code>
        and <code class="literal">ProducerCallback</code> expose the JMS Session
        and Session/MessageProducer pair respectfully.  The 
        <code class="literal">execute()</code> methods on JmsTemplate execute these
        callback methods.
        </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jmx"></a>Chapter&nbsp;19.&nbsp;JMX Support</h2></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-introduction"></a>19.1.&nbsp;Introduction</h2></div></div></div><p>The JMX support in Spring provides you with the features to easily
and transparently integrate your Spring application into a JMX
infrastructure. Specifically, Spring JMX provides 4 core features:</p><div class="itemizedlist"><ul type="disc"><li><p>Automatic Registration of any Spring bean as a JMX MBean</p></li><li><p>Flexible mechanism for controlling the management interface of
your beans</p></li><li><p>Declarative exposure of MBeans over remote, JSR-160
connectors</p></li><li><p>Simple proxying of both local and remote MBean resources</p></li></ul></div><p>These features are designed to work without coupling your
application components to either Spring or JMX interfaces and classes. Indeed, for the most part your application classes need not be aware of
either Spring or JMX in order to take advantage of the Spring JMX
features.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-exporting"></a>19.2.&nbsp;Exporting your Beans to JMX</h2></div></div></div><p>The core class in the Spring JMX framework is the <code class="literal">MBeanExporter</code>. This class is responsible for taking
your Spring beans and registering them with the JMX <code class="literal">MBeanServer</code>. For example, consider the simple bean class shown below:</p><pre class="programlisting">package org.springframework.jmx;

public class JmxTestBean implements IJmxTestBean {

    private String name;

    private int age;

    private boolean isSuperman;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }

}</pre><p>To expose the properties and methods of this bean as attributes and
operations of a JMX MBean you simply configure an instance of the
    <code class="literal">MBeanExporter</code> class in your configuration file and pass
in the bean as shown below:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Here, the important definition is the <code class="literal">exporter</code>
bean. The <code class="literal">beans</code> property is used to tell the
<code class="literal">MBeanExporter</code> which of your beans should be exported to
the JMX <code class="literal">MBeanServer</code>. The <code class="literal">beans</code>
property is of type <code class="literal">Map</code>, and thus you use the
<code class="literal">&lt;map&gt;</code> and <code class="literal">&lt;entry&gt;</code> tags
to configure the beans to be exported. In the default configuration, the
key of an entry in of the <code class="literal">Map</code> is used as the
<code class="literal">ObjectName</code> for the bean that is the value of that
entry. This behaviour can be changed as described in section <a href="#jmx-naming" title="19.4.&nbsp;Controlling the ObjectNames for your&#xA;    Beans">Section&nbsp;19.4, &#8220;Controlling the <code class="literal">ObjectName</code>s for your
    Beans&#8221;</a>.</p><p>With this configuration the <code class="literal">testBean</code> bean is
exposed as a JMX MBean under the <code class="literal">ObjectName</code>
			<code class="literal">bean:name=testBean1</code>. All public properties of the bean
are exposed as attributes and all public methods (expect those defined in
<code class="literal">Object</code>) are exposed as operations.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-mbeanserver"></a>19.2.1.&nbsp;Creating an MBeanServer</h3></div></div></div><p>The configuration shown above assumes that the application is
running in an environment that has one and only one
<code class="literal">MBeanServer</code> already running. In this case, Spring
will locate the running <code class="literal">MBeanServer</code> and register your
beans with that. This is useful when your application is running inside a container such as Tomcat or IBM WebSphere that has its own
<code class="literal">MBeanServer</code>.</p><p>However, this approach is of no use in a standalone environment, or when running inside a container that does not provide an
<code class="literal">MBeanServer</code>. To overcome this you can create an
<code class="literal">MBeanServer</code> instance declaratively by adding an
instance of
      <code class="literal">org.springframework.jmx.support.MBeanServerFactoryBean</code> to your configuration. You can also ensure that this
<code class="literal">MBeanServer</code> is used by using
<code class="literal">MBeanServerFactoryBean</code> to set the server property of
 the <code class="literal">MBeanExporter</code>. This is shown below:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"/&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="server" ref="mbeanServer"/&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Here an instance of <code class="literal">MBeanServer</code> is created by the <code class="literal">MBeanServerFactoryBean</code> and is supplied to the
<code class="literal">MBeanExporter</code> via the server property. When you
supply your own <code class="literal">MBeanServer</code>,
<code class="literal">MBeanExporter</code> will not attempt to locate a running <code class="literal">MBeanServer</code>. For this to work correctly, you must have a JMX implementation on your classpath.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-lazy"></a>19.2.2.&nbsp;Lazy-Initialized MBeans</h3></div></div></div><p>If you configure a bean with the <code class="literal">MBeanExporter</code>
that is also configured for lazy initialization, then the
<code class="literal">MBeanExporter</code> will NOT break this contract and will
avoid instantiating the bean. Instead, it will register a proxy with the
<code class="literal">MBeanServer</code> and will defer obtaining the bean from the <code class="literal">BeanFactory</code> until the first invocation on the
proxy occurs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-auto"></a>19.2.3.&nbsp;Automatic Registration of MBeans</h3></div></div></div><p>Any beans that are exported through the
<code class="literal">MBeanExporter</code> and are already valid MBeans are registered as is with the <code class="literal">MBeanServer</code> without further
      intervention from Spring. MBeans can be automatically detected by the
<code class="literal">MBeanExporter</code> by setting the
<code class="literal">autodetect</code> property to true:</p><pre class="programlisting">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
  &lt;property name="autodetect" value="true"/&gt;
&lt;/bean&gt;

&lt;bean name="spring:mbean=true" class="org.springframework.jmx.export.TestDynamicMBean"/&gt;</pre><p>Here, the bean called <code class="literal">spring:mbean=true</code> is
already a valid JMX MBean and will be automatically registered by
Spring. By default, beans that are autodetected for JMX registration have their bean name used as the <code class="literal">ObjectName</code>. This behavior can be overridden as detailed in section <a href="#jmx-naming" title="19.4.&nbsp;Controlling the ObjectNames for your&#xA;    Beans">Section&nbsp;19.4, &#8220;Controlling the <code class="literal">ObjectName</code>s for your
    Beans&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-interface"></a>19.3.&nbsp;Controlling the Management Interface of Your Beans</h2></div></div></div><p>In the previous example, you had little control over the management
interface of your bean with all the public properties and methods being
exposed. To solve this problem, Spring JMX provides a comprehensive and
extensible mechanism for controlling the management interfaces of your beans.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-assembler"></a>19.3.1.&nbsp;The <code class="literal">MBeanInfoAssembler</code> Interface</h3></div></div></div><p>Behind the scenes, the <code class="literal">MBeanExporter</code> delegates to an implementation of the <code class="literal">org.springframework.jmx.export.assembler.MBeanInfoAssembler</code> interface which is responsible for defining the management interface of each bean that is being exposed. The default implementation, <code class="literal">org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler</code>, simply defines an interface that exposes all public properties and
methods as you saw in the previous example. Spring provides two
additional implementations of the <code class="literal">MBeanInfoAssembler</code>
      interface that allow you to control the management interface using
source level metadata or any arbitrary interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-metadata"></a>19.3.2.&nbsp;Using Source-Level Metadata</h3></div></div></div><p>Using the <code class="literal">MetadataMBeanInfoAssembler</code> you can
      define the management interfaces for your beans using source level
      metadata. The reading of metadata is encapsulated by the
      <code class="literal">org.springframework.jmx.export.metadata.JmxAttributeSource
      </code>interface. Out of the box, Spring JMX provides support for two
      implementations of this interface:
      <code class="literal">org.springframework.jmx.export.metadata.AttributesJmxAttributeSource</code>
      for Commons Attributes and
      <code class="literal">org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource</code>
      for JDK 5.0 annotations. The <code class="literal">MetadataMBeanInfoAssembler</code>
      MUST be configured with an implementation of <code class="literal">JmxAttributeSource</code>
      for it to function correctly. For this example, we will use the Commons
      Attributes metadata approach.</p><p>To mark a bean for export to JMX, you should annotate the bean
      class with the <code class="literal">ManagedResource</code> attribute. In the case
      of the Commons Attributes metadata approach this class can be found in
      the org.springframework.jmx.metadata package. Each method you wish to
      expose as an operation should be marked with a
      <code class="literal">ManagedOperation</code> attribute and each property you wish
      to expose should be marked with a <code class="literal">ManagedAttribute</code>
      attribute. When marking properties you can omit either the getter or the
      setter to create a write-only or read-only attribute
      respectively.</p><p>The example below shows the <code class="literal">JmxTestBean</code> class
      that you saw earlier marked with Commons Attributes metadata:</p><pre class="programlisting">package org.springframework.jmx;

/**
 * @@org.springframework.jmx.export.metadata.ManagedResource
 *  (description="My Managed Bean", objectName="spring:bean=test",
 *  log=true, logFile="jmx.log", currencyTimeLimit=15, persistPolicy="OnUpdate",
 *  persistPeriod=200, persistLocation="foo", persistName="bar")
 *
 */
public class JmxTestBean implements IJmxTestBean {

  private String name;

  private int age;

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *   (description="The Age Attribute", currencyTimeLimit=15)
   */
  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *  (description="The Name Attribute",  currencyTimeLimit=20,
   *   defaultValue="bar", persistPolicy="OnUpdate")
   */
  public void setName(String name) {
    this.name = name;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *   (defaultValue="foo", persistPeriod=300)
   */
  public String getName() {
    return name;
  }


  /**
   * @@org.springframework.jmx.export.metadata.ManagedOperation
   *  (description="Add Two Numbers Together")
   */
  public int add(int x, int y) {
    return x + y;
  }

  public void dontExposeMe() {
    throw new RuntimeException();
  }
}</pre><p>Here you can see that the <code class="literal">JmxTestBean</code> class is
      marked with the <code class="literal">ManagedResource</code> attribute and that
      this <code class="literal">ManagedResoure</code> attribute is configured with a
      set of properties. These properties can be used to configure various
      aspects of the MBean that is generated by the
      <code class="literal">MBeanExporter</code> and are explained in greater detail
      later in section <a href="#jmx-interface-metadata-types" title="19.3.4.&nbsp;Source-Level Metadata Types">Section&nbsp;19.3.4, &#8220;Source-Level Metadata Types&#8221;</a>.</p><p>You will also notice that both the age and name properties are
      marked with the <code class="literal">ManagedAttribute</code> attribute but in the
      case of the <code class="literal">age</code> property, only the getter is marked.
      This will cause both of these properties to be included in the
      management interface as attributes, and for the <code class="literal">age</code>
      attribute to be read-only.</p><p>Finally, you will notice that the <code class="literal">add(int, int)</code>
      method is marked with the <code class="literal">ManagedOperation</code> attribute
      whereas the <code class="literal">dontExposeMe() </code>method is not. This will
      casue the management interface to contain only one operation,
      <code class="literal">add(int, int)</code>, when using the
      <code class="literal">MetadataMBeanInfoAssembler</code>.</p><p>The code below shows how you configure the
      <code class="literal">MBeanExporter</code> to use the
      <code class="literal">MetadataMBeanInfoAssembler</code>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
      &lt;ref local="assembler"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name"&gt;
      &lt;value&gt;TEST&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="age"&gt;
      &lt;value&gt;100&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="attributeSource"
        class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"&gt;
    &lt;property name="attributes"&gt;
      &lt;bean class="org.springframework.metadata.commons.CommonsAttributes"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
    &lt;property name="attributeSource"&gt;
      &lt;ref local="attributeSource"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Here you can see that a
      <code class="literal">MetadataMBeanInfoAssembler</code> bean has been configured
      with an instance of <code class="literal">AttributesJmxAttributeSource</code> and
      passed to the <code class="literal">MBeanExporter</code> through the assembler
      property. This is all that is required to take advantage of
      metadata-driven management interfaces for your Spring-exposed
      MBeans.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-annotations"></a>19.3.3.&nbsp;Using JDK 5.0 Annotations</h3></div></div></div><p>To enable the use of JDK 5.0 annotations for management interface
      definition, Spring provides a set of annotations that mirror the Commons
      Attribute attribute classes and an implementation of
      <code class="literal">JmxAttributeSource</code>,
      <code class="literal">AnnotationsJmxAttributeSource</code>, that allows the
      <code class="literal">MBeanInfoAssembler</code> to read them.</p><p>The example below shows a bean with a JDK 5.0 annotation defined
      management interface:</p><pre class="programlisting">package org.springframework.jmx;

import org.springframework.jmx.export.annotation.ManagedResource;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedAttribute;

@ManagedResource(objectName="bean:name=testBean4", description="My Managed Bean", log=true,
    logFile="jmx.log", currencyTimeLimit=15, persistPolicy="OnUpdate", persistPeriod=200,
    persistLocation="foo", persistName="bar")
public class AnnotationTestBean implements IJmxTestBean {

   private String name;

  private int age;

  @ManagedAttribute(description="The Age Attribute", currencyTimeLimit=15)
  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  @ManagedAttribute(description="The Name Attribute",
      currencyTimeLimit=20,
      defaultValue="bar",
      persistPolicy="OnUpdate")
  public void setName(String name) {
    this.name = name;
  }

  @ManagedAttribute(defaultValue="foo", persistPeriod=300)
  public String getName() {
    return name;
  }

  @ManagedOperation(description="Add Two Numbers Together")
  public int add(int x, int y) {
    return x + y;
  }

  public void dontExposeMe() {
    throw new RuntimeException();
  }
}</pre><p>As you can see little has changed, other than the basic syntax of
      the metadata definitions. Behind the scenes this approach is a little
      slower at startup because the JDK 5.0 annotations are converted into the
      classes used by Commons Attributes. However, this is only a one-off cost
      and JDK 5.0 annotations give you the benefit of compile-time
      checking.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-metadata-types"></a>19.3.4.&nbsp;Source-Level Metadata Types</h3></div></div></div><p>The following source level metadata types are available for use in
      Spring JMX:</p><p>
				</p><div class="table"><a name="d0e13676"></a><p class="title"><b>Table&nbsp;19.1.&nbsp;Source-Level Metadata Types</b></p><div class="table-contents"><table summary="Source-Level Metadata Types" border="1"><colgroup><col align="left"><col><col><col></colgroup><thead><tr><th align="center">Purpose</th><th align="center">Commons Attributes Attribute</th><th align="center">JDK 5.0 Annotation</th><th align="center">Attribute / Annotation Type</th></tr></thead><tbody><tr><td align="left">Mark all instances of a Class as JMX managed
                resources</td><td>
									<code class="literal">ManagedResource</code>
								</td><td>
									<code class="literal">@ManagedResource</code>
								</td><td>Class</td></tr><tr><td align="left">Mark a method as a JMX operation</td><td>
									<code class="literal">ManagedOperation</code>
								</td><td>
									<code class="literal">@ManagedOperation</code>
								</td><td>Method</td></tr><tr><td align="left">Mark a getter or setter as one half of a JMX
                attribute</td><td>
									<code class="literal">ManagedAttribute</code>
								</td><td>
									<code class="literal">@ManagedAttribute</code>
								</td><td>Method (only getters and setters)</td></tr><tr><td align="left">Define descriptions for operation parameters</td><td>
									<code class="literal">ManagedOperationParameter</code>
								</td><td>
									<code class="literal">@ManagedOperationParameter</code> and
                <code class="literal">@ManagedOperationParameters</code>
								</td><td>Method</td></tr></tbody></table></div></div><p><br class="table-break">
			</p><p>The following configuration parameters are available for use on
      these source-level metadata types:</p><p>
				</p><div class="table"><a name="d0e13763"></a><p class="title"><b>Table&nbsp;19.2.&nbsp;Source-Level Metadata Parameters</b></p><div class="table-contents"><table summary="Source-Level Metadata Parameters" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="center">Parameter</th><th align="center">Description</th><th align="center">Applies to</th></tr></thead><tbody><tr><td align="left">
									<code class="literal">objectName</code>
								</td><td>Used by <code class="literal">MetadataNamingStrategy</code> to
                determine the <code class="literal">ObjectName</code> of a managed
                resource</td><td>
									<code class="literal">ManagedResource</code>
								</td></tr><tr><td align="left">
									<code class="literal">description</code>
								</td><td>Sets the friendly description of the resource,
                attribute or operation</td><td>
									<code class="literal">ManagedResource</code>,
                <code class="literal">ManagedAttribute</code>,
                <code class="literal">ManagedOperation</code>,
                <code class="literal">ManagedOperationParameter</code>
								</td></tr><tr><td align="left">
									<code class="literal">currencyTimeLimit</code>
								</td><td>Sets the value of the
                <code class="literal">currencyTimeLimit</code> descriptor field</td><td>
									<code class="literal">ManagedResource</code>,
                <code class="literal">ManagedAttribute</code>
								</td></tr><tr><td align="left">
									<code class="literal">defaultValue</code>
								</td><td>Sets the value of the <code class="literal">defaultValue</code>
                descriptor field</td><td>
									<code class="literal">ManagedAttribute</code>
								</td></tr><tr><td align="left">
									<code class="literal">log</code>
								</td><td>Sets the value of the <code class="literal">log</code> descriptor
                field</td><td>
									<code class="literal">ManagedResource</code>
								</td></tr><tr><td align="left">
									<code class="literal">logFile</code>
								</td><td>Sets the value of the <code class="literal">logFile</code>
                descriptor field</td><td>
									<code class="literal">ManagedResource</code>
								</td></tr><tr><td align="left">
									<code class="literal">persistPolicy</code>
								</td><td>Sets the value of the <code class="literal">persistPolicy</code>
                descriptor field</td><td>
									<code class="literal">ManagedResource</code>
								</td></tr><tr><td align="left">
									<code class="literal">persistPeriod</code>
								</td><td>Sets the value of the <code class="literal">persistPeriod</code>
                descriptor field</td><td>
									<code class="literal">ManagedResource</code>
								</td></tr><tr><td align="left">
									<code class="literal">persistLocation</code>
								</td><td>Sets the value of the
                <code class="literal">persistLocation</code> descriptor field</td><td>
									<code class="literal">ManagedResource</code>
								</td></tr><tr><td align="left">
									<code class="literal">persistName</code>
								</td><td>Sets the value of the <code class="literal">persistName</code>
                descriptor field</td><td>
									<code class="literal">ManagedResource</code>
								</td></tr><tr><td align="left">
									<code class="literal">name</code>
								</td><td>Sets the display name of an operation parameter</td><td>
									<code class="literal">ManagedOperationParameter</code>
								</td></tr><tr><td align="left">
									<code class="literal">index</code>
								</td><td>Sets the index of an operation parameter</td><td>
									<code class="literal">ManagedOperationParameter</code>
								</td></tr></tbody></table></div></div><p><br class="table-break">
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-autodetect"></a>19.3.5.&nbsp;The <code class="literal">AutodetectCapableMBeanInfoAssembler</code>
      Interface</h3></div></div></div><p>To simply configuration even further, Spring introduces the
      <code class="literal">AutodetectCapableMBeanInfoAssembler</code> interface which
      extends the <code class="literal">MBeanInfoAssembler</code> interface to add
      support for autodetection of MBean resources. If you configure the
      <code class="literal">MBeanExporter</code> with an instance of
      <code class="literal">AutodetectCapableMBeanInfoAssembler</code> then it is
      allowed to "vote" on the inclusion of beans for exposure to JMX.</p><p>Out of the box, the only implementation of
      <code class="literal">AutodetectCapableMBeanInfo</code> is the
      <code class="literal">MetadataMBeanInfoAssembler</code> which will vote to include
      any bean which is marked with the <code class="literal">ManagedResource</code>
      attribute. The default approach in this case is to use the bean name as
      the <code class="literal">ObjectName</code> which results in a configuration like
      this:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="assembler" ref="assembler"/&gt;
	  &lt;property name="autodetect" value="true"/&gt;
  &lt;/bean&gt;

  &lt;bean id="bean:name=testBean1" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

  &lt;bean id="attributeSource"
      class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"/&gt;

  &lt;bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
    &lt;property name="attributeSource" ref="attributeSource"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Notice that in this configuration no beans are passed to the
      <code class="literal">MBeanExporter</code>, however the
      <code class="literal">JmxTestBean</code> will still be registered since it is
      marked with the <code class="literal">ManagedResource</code> attribute and the
      <code class="literal">MetadataMBeanInfoAssembler</code> detects this and votes to
      include it. The only problem with this approach is that the name of the
      <code class="literal">JmxTestBean</code> now has business meaning. You can solve
      this problem by changing the default behavior for
      <code class="literal">ObjectName</code> creation as defined in section <a href="#jmx-naming" title="19.4.&nbsp;Controlling the ObjectNames for your&#xA;    Beans">Section&nbsp;19.4, &#8220;Controlling the <code class="literal">ObjectName</code>s for your
    Beans&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-java"></a>19.3.6.&nbsp;Defining Management Interfaces using Java Interfaces</h3></div></div></div><p>In addition to the <code class="literal">MetadataMBeanInfoAssembler</code>,
      Spring also includes the
      <code class="literal">InterfaceBasedMBeanInfoAssembler</code> which allows you to
      constrain the methods and properties that are exposed based on the set
      of methods defined in a collection of interfaces.</p><p>Although the standard mechanism for exposing MBeans is to use
      interfaces and a simple naming scheme, the
      <code class="literal">InterfaceBasedMBeanInfoAssembler</code> extends this
      functionality by removing the need for naming conventions, allowing you
      to use more than one interface and removing the need for your beans to
      implement the MBean interfaces.</p><p>Consider this interface that is used to define a management
      interface for the <code class="literal">JmxTestBean</code> class that you saw
      earlier:</p><pre class="programlisting">public interface IJmxTestBean {

  public int add(int x, int y);

  public long myOperation();

  public int getAge();

  public void setAge(int age);

  public void setName(String name);

  public String getName();
}</pre><p>This interface defines the methods and properties that will be
      exposed as operations and attributes on the JMX MBean. The code below
      shows how to configure Spring JMX to use this interface as the
      definition for the management interface:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean5"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
      &lt;bean class="org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"&gt;
        &lt;property name="managedInterfaces"&gt;
          &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;/value&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name"&gt;
      &lt;value&gt;TEST&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="age"&gt;
      &lt;value&gt;100&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Here you can see that the
      <code class="literal">InterfaceBasedMBeanInfoAssembler</code> is configured to use
      the <code class="literal">IJmxTestBean</code> interface when constructing the
      management interface for any bean. It is important to understand that
      beans processed by the
      <code class="literal">InterfaceBasedMBeanInfoAssembler</code> are NOT required to
      implement the interface used to generate the JMX management
      interface.</p><p>In the case above, the <code class="literal">IJmxTestBean</code> interface
      is used to construct all management interfaces for all beans. In many
      cases this is not the desired behavior and you may want to use different
      interfaces for different beans. In this case, you can pass
      <code class="literal">InterfaceBasedMBeanInfoAssembler</code> a
      <code class="literal">Properties</code> via the
      <code class="literal">interfaceMappings</code> property, where the key of each
      entry is the bean name and the value of each entry is a comma-seperated
      list of interface names to use for that bean.</p><p>If no management interface is specified through either the
      <code class="literal">managedInterfaces</code> or
      <code class="literal">interfaceMappings</code> properties, then
      <code class="literal">InterfaceBasedMBeanInfoAssembler</code> will reflect on the
      bean and use all interfaces implemented by that bean to create the
      management interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-methodnames"></a>19.3.7.&nbsp;Using
      <code class="literal">MethodNameBasedMBeanInfoAssembler</code>
			</h3></div></div></div><p>The <code class="literal">MethodNameBasedMBeanInfoAssembler</code> allows
      you to specify a list of method names that will be exposed to JMX as
      attributes and operations. The code below shows a sample configuration
      for this:</p><pre class="programlisting">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean5"&gt;
          &lt;ref local="testBean"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
      &lt;bean class="org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler"&gt;
        &lt;property name="managedMethods"&gt;
          &lt;value&gt;add,myOperation,getName,setName,getAge&lt;/value&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Here you can see that the methods <code class="literal">add</code> and
      <code class="literal">myOperation</code> will be exposed as JMX operations and
      <code class="literal">getName</code>, <code class="literal">setName</code> and
      <code class="literal">getAge</code> will be exposed as the appropriate half of a
      JMX attribute. In the code above, the method mappings apply to beans
      that are exposed to JMX. To control method exposure on a bean by bean
      basis, use the <code class="literal">methodMappings</code> property of
      <code class="literal">MethodNameMBeanInfoAssembler</code> to map bean names to
      lists of method names.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-naming"></a>19.4.&nbsp;Controlling the <code class="literal">ObjectName</code>s for your
    Beans</h2></div></div></div><p>Behind the scenes, the <code class="literal">MBeanExporter</code> delegates to
    an implementation of the <code class="literal">ObjectNamingStrategy</code> to obtain
    <code class="literal">ObjectName</code>s for each of the beans it is registering.
    The default implementation, <code class="literal">KeyNamingStrategy</code>, will, by
    default, use the key of the <code class="literal">beans</code>
			<code class="literal">Map</code> as the <code class="literal">ObjectName</code>. In addition,
    the <code class="literal">KeyNamingStrategy</code> can map the key of the
    <code class="literal">beans</code>
			<code class="literal">Map</code> to an entry in a
    <code class="literal">Properties</code> file (or files) to resolve the
    <code class="literal">ObjectName</code>. In addition to the
    <code class="literal">KeyNamingStrategy</code>, Spring provides two additional
    <code class="literal">ObjectNamingStrategy</code> implementations:
    <code class="literal">IdentityNamingStrategy</code> that builds an
    <code class="literal">ObjectName</code> based on the identity of the bean and
    <code class="literal">MetadataNamingStrategy</code> that uses the source level
    metadata to obtain the <code class="literal">ObjectName</code>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-naming-properties"></a>19.4.1.&nbsp;Reading <code class="literal">ObjectName</code>s from
      <code class="literal">Properties</code>
			</h3></div></div></div><p>You can configure your own <code class="literal">KeyNamingStrategy</code>
      instance and configure it to read <code class="literal">ObjectName</code>s from a
      <code class="literal">Properties</code> instance rather than use bean key. The
      <code class="literal">KeyNamingStrategy</code> will attempt to locate an entry in
      the <code class="literal">Properties</code> with a key corresponding to the bean
      key. If no entry is found or if the <code class="literal">Properties</code>
      instance is null then the bean key itself is used.</p><p>The code below shows a sample configuration for the
      <code class="literal">KeyNamingStrategy</code>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="testBean" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

  &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.KeyNamingStrategy"&gt;
    &lt;property name="mappings"&gt;
      &lt;props&gt;
        &lt;prop key="testBean"&gt;bean:name=testBean1&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name="mappingLocations"&gt;
      &lt;value&gt;names1.properties,names2.properties&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean

&lt;/beans&gt;</pre><p>Here an instance of <code class="literal">KeyNamingStrategy</code> is
      configured with a <code class="literal">Properties</code> instance that is merged
      from the <code class="literal">Properties</code> instance defined by the mapping
      property and the properties files located in the paths defined by the
      mappings property. In this configuration, the
      <code class="literal">testBean</code> bean will be given the
      <code class="literal">ObjectName</code>
				<code class="literal">bean:name=testBean1
      </code>since this is the entry in the <code class="literal">Properties</code>
      instance that has a key corresponding to the bean key.</p><p>If no entry in the <code class="literal">Properties</code> instance can be
      found then the bean key is used as the
      <code class="literal">ObjectName</code>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-naiming-metadata"></a>19.4.2.&nbsp;Using the <code class="literal">MetadataNamingStrategy</code>
			</h3></div></div></div><p>The <code class="literal">MetadataNamingStrategy</code> uses
      <code class="literal">objectName</code> property of the
      <code class="literal">ManagedResource</code> attribute on each bean to create the
      <code class="literal">ObjectName</code>. The code below shows the configuration
      for the <code class="literal">MetadataNamingStrategy</code>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="testBean" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

  &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
    &lt;property name="attributeSource" ref="attributeSource"/&gt;
  &lt;/bean&gt;

  &lt;bean id="attributeSource"
      class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"/&gt;

&lt;/beans&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-jsr160"></a>19.5.&nbsp;Exporting your Beans with JSR-160 Connectors</h2></div></div></div><p>For remote access, Spring JMX module offers two
<code class="literal">FactoryBean</code> implementations inside the
<code class="literal">org.springframework.jmx.support</code> package for creating
server-side and client-side connectors.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-jsr160-server"></a>19.5.1.&nbsp;Server-side Connectors</h3></div></div></div><p>To have Spring JMX create,start and expose a JSR-160
<code class="literal">JMXConnectorServer</code> use the following
configuration:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"/&gt;</pre><p>By default <code class="literal">ConnectorServerFactoryBean</code> creates a
 <code class="literal">JMXConnectorServer</code> bound to
"service:jmx:jmxmp://localhost:9875". The <code class="literal">serverConnector</code> bean thus
exposes the local <code class="literal">MBeanServer</code> to clients through the JMXMP
protocol on localhost, port 9875. Note that the JMXMP protocol is marked as
optional by the JSR 160: Currently, the main open-source JMX implementation,
MX4J, and the one provided with J2SE 5.0 do not support JMXMP.</p><p>To specify another URL and register the
<code class="literal">JMXConnectorServer</code> itself with the <code class="literal">MBeanServer</code> use the <code class="literal">serviceUrl</code> and
 <code class="literal">objectName</code> properties respectively:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
  &lt;property name="objectName" value="connector:name=rmi"/&gt;
  &lt;property name="serviceUrl" 
               value"service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector"/&gt;
&lt;/bean&gt;</pre><p>If the <code class="literal">objectName</code> property is set Spring will
 automatically register your connector with the
<code class="literal">MBeanServer</code> under that <code class="literal">ObjectName</code>.
The example below shows the full set of parameters which you can pass to
the <code class="literal">ConnectorServerFactoryBean</code> when creating the
JMXConnector:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
  &lt;property name="objectName" value="connector:name=iiop"/&gt;
  &lt;property name="serviceUrl" 
               value="service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector"/&gt;
  &lt;property name="threaded" value="true"/&gt;
  &lt;property name="daemon" value="true"/&gt;
  &lt;property name="environment"&gt;
    &lt;map&gt;
      &lt;entry key="someKey" value="someValue"/&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>For more information on these properties consult the JavaDoc. For information of meaning of the environment variables, consult the JavaDoc for </p><p>Note that when using a RMI-based connector you need the lookup service (tnameserv or rmiregistry) to be started in order for the name registration to complete. If you are using Spring to export remote services for you via RMI, then Spring will already have constructed an RMI registry. If not, you can easily start a registry using the following snippet of configuration:</p><p>
			</p><pre class="programlisting">&lt;bean id="registry" class="org.springframework.remoting.rmi.RmiRegistryFactoryBean"&gt;
  &lt;property name="port" value="1099"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-jsr160-client"></a>19.5.2.&nbsp;Client-side Connectors</h3></div></div></div><p>To create an <code class="literal">MBeanServerConnection</code> to a remote
JSR-160 enabled <code class="literal">MBeanServer</code> use the
 <code class="literal">MBeanServerConnectionFactoryBean</code> as shown below:</p><pre class="programlisting">&lt;bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
  &lt;property name="serviceUrl" value="service:jmx:rmi://localhost:9875"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-jsr160-protocols"></a>19.5.3.&nbsp;JMX over Burlap/Hessian/SOAP</h3></div></div></div><p>JSR-160 permits extensions to the way in which communication is done between the client and the server. The examples above are using the
      mandatory RMI-based implementation required by the JSR-160(IIOP and
      JRMP) and the optional JMXMP. By using other providers or
      implementations like <a href="http://mx4j.sourceforge.net" target="_top">MX4J</a> you can take advantage of
      protocols like SOAP, Hessian, Burlap over simple HTTP or SSL and
      other:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
  &lt;property name="objectName" value="connector:name=burlap"/&gt;
  &lt;property name="serviceUrl" value="service:jmx:burlap://localhost:9874"/&gt;
&lt;/bean&gt;</pre><p>For this example, MX4J 3.0.0 was used. See the official MX4J
      documentation for more information.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-proxy"></a>19.6.&nbsp;Accessing MBeans via Proxies</h2></div></div></div><p>Spring JMX allows you to create proxies that re-route calls to
    MBeans registered in a local or remote <code class="literal">MBeanServer</code>.
    These proxies provide you with a standard Java interface through which you
    can interact with your MBeans. The code below shows how to to configure a
    proxy for an MBean running in the local
    <code class="literal">MBeanServer</code>:</p><pre class="programlisting">&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
    &lt;property name="objectName"&gt;
      &lt;value&gt;bean:name=testBean&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="proxyInterface"&gt;
      &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Here you can see that a proxy is created for the MBean registered
    under the <code class="literal">ObjectName</code>:
    <code class="literal">bean:name=testBean</code>. The set of interfaces that the
    proxy will implement is controlled by the
    <code class="literal">proxyInterfaces</code> property and the rules for mapping
    methods and properties on these interfaces to operations and attributes on
    the MBean are the same rules used by the
    <code class="literal">InterfaceBasedMBeanInfoAssembler</code>.</p><p>The <code class="literal">MBeanProxyFactoryBean</code> can create a proxy to
    any MBean that is accessible via an
    <code class="literal">MBeanServerConnection</code>. By default, the local
    <code class="literal">MBeanServer</code> is located and used, but you can override
    this and provide an <code class="literal">MBeanServerConnection</code> pointing to a
    remote <code class="literal">MBeanServer</code> allowing for proxies pointing to
    remote MBeans:</p><pre class="programlisting">&lt;bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
  &lt;property name="serviceUrl" value="service:jmx:rmi://remotehost:9875"/&gt;
&lt;/bean&gt;

&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
  &lt;property name="objectName" value="bean:name=testBean"/&gt;
  &lt;property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/&gt;
&lt;/bean&gt;</pre><p>Here you can see that we create an
    <code class="literal">MBeanServerConnection</code> pointing to a remote machine
    using the <code class="literal">MBeanServerConnectionFactoryBean</code>. This
    <code class="literal">MBeanServerConnection</code> is then passed to the
    <code class="literal">MBeanProxyFactoryBean</code> via the <code class="literal">server</code>
    property. The proxy that is created will pass on all invocations to the
    <code class="literal">MBeanServer</code> via this
    <code class="literal">MBeanServerConnection</code>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="cci"></a>Chapter&nbsp;20.&nbsp;JCA CCI</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14464"></a>20.1.&nbsp;Introduction</h2></div></div></div><p>J2EE provides a specification to standardize access to EIS: JCA
    (Java Connector Architecture). This specification is divided into several
    different parts:</p><div class="itemizedlist"><ul type="disc"><li><p>SPI (Service provider interfaces) that the connector provider
        must implement. These interfaces constitute a resource adapter which
        can be deployed on a J2EE application server. In such a scenario, the
        server manages connection pooling, transaction and security (managed
        mode). The application server is also responsible for managing the
        configuration, which is held outside the client application. A connector
        can be used without an application server as well; in thid case, the
        application must configure it directly (non-managed mode).</p></li><li><p>CCI (Common Client Interface) that an application can use to
        interact with the connector and thus communicate with an EIS. An API
        for local transaction demarcation is provided as well.</p></li></ul></div><p>The aim of the Spring CCI support is to provide classes to access
    a CCI connector in typical Spring style, leveraging's Spring general
    resource and transaction management facilities.</p><p><span class="emphasis"><em>Important note</em></span>: The client side of connectors
    doesn't alway use CCI. Some connectors expose their own APIs, only
    providing JCA resource adapter to use the system contracts of a J2EE
    container (connection pooling, global transactions, security). Spring
    does not offer special support for such connector-specific APIs.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14482"></a>20.2.&nbsp;Configuring CCI</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14485"></a>20.2.1.&nbsp;Connector configuration</h3></div></div></div><p>The base resource to use JCA CCI is the
      <code class="literal">ConnectionFactory</code> interface. The connector used
      must provide an implementation of this interface.</p><p>To use your connector, you can deploy it on your application
      server and fetch the <code class="literal">ConnectionFactory</code> from the
      server's JNDI environment (managed mode). The connector must be
      packaged as a RAR file (resource adapter archive) and contain a
      <code class="filename">ra.xml</code> file to describe its deployment
			characteristics. The actual name of the resource is specified when
      you deploy it. To access it within Spring, simply use Spring's
      <code class="literal">JndiObjectFactoryBean</code> to fetch the factory
      by its JNDI name.</p><p>Another way to use a connector is to embed it in your application
      (non-managed mode), not using an application server to deploy and
      configure it. Spring offers the possibility to configure a connector
      as a bean, through a provided <code class="literal">FactoryBean</code>
      (<code class="literal">LocalConnectionFactoryBean</code>). In this manner,
      you only need the connector library in the classpath (no RAR file and
      no <code class="filename">ra.xml</code> descriptor needed). The library must
      be extracted from the connector's RAR file, if necessary.</p><p>Once you got access to your <code class="literal">ConnectionFactory</code>
      instance, you can inject it into your components. These components can
      either be coded against the plain CCI API or leverage Spring's support
      classes for CCI access (e.g. CciTemplate).</p><p><span class="emphasis"><em>Important note</em></span>: When you use a connector in
      non-managed mode, you can't use global transactions because the resource
      is never enlisted / delisted in the current global transaction of the
      current thread. The resource is simply not aware of any global J2EE
			transactions that might be running.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14524"></a>20.2.2.&nbsp;ConnectionFactory configuration in Spring</h3></div></div></div><p>In order to make connections to the EIS, you need to obtain a
      <code class="literal">ConnectionFactory</code> from the application server if
      you are in a managed mode, or directly from Spring if you are in a
      non-managed mode.</p><p>In a managed mode, you access it from JNDI; its properties will
      be configured in the application server.</p><pre class="programlisting">&lt;bean id="eciConnectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName"&gt;
    &lt;value&gt;eis/cicseci&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>In non-managed mode, you must configure the ConnectionFactory
      you want to use in the configuration of Spring as a JavaBean. The
      <code class="literal">LocalConnectionFactoryBean</code> class offers this
      setup style, passing in the <code class="literal">ManagedConnectionFactory</code>
      implementation of your connector, exposing the application-level
			CCI <code class="literal">ConnectionFactory</code>.</p><pre class="programlisting">&lt;bean id="eciManagedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName"&gt;&lt;value&gt;TXSERIES&lt;/value&gt;&lt;/property&gt;
  &lt;property name="connectionURL"&gt;&lt;value&gt;tcp://localhost/&lt;/value&gt;&lt;/property&gt;
  &lt;property name="portNumber"&gt;&lt;value&gt;2006&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="eciConnectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory"&gt;
    &lt;ref local="eciManagedConnectionFactory"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>Important note</em></span>: You can't directly instantiate
			a specific <code class="literal">ConnectionFactory</code>. You need to go through
      the corresponding implementation of the
		 <code class="literal">ManagedConnectionFactory</code> interface for your
      connector. This interface is part of the JCA SPI specification.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14559"></a>20.2.3.&nbsp;Configuring CCI connections</h3></div></div></div><p>JCA CCI allow the developer to configure the connections to the
      EIS using the <code class="literal">ConnectionSpec</code> implementation of your
      connector. In order to configure its properties, you need to wrap the
      target connection factory with a dedicated adapter,
      <code class="literal">ConnectionSpecConnectionFactoryAdapter</code>. So, the
      dedicated <code class="literal">ConnectionSpec</code> can be configured with the
      property <code class="literal">connectionSpec</code> (as an inner bean).</p><p>This property is not mandatory because the CCI
      <code class="literal">ConnectionFactory</code> interface defines two different
      methods to obtain a CCI connection. Some of the
		  <code class="literal">ConnectionSpec</code> properties can often be configured
			in the application server (in managed mode) or on the corresponding local
		  <code class="literal">ManagedConnectionFactory</code> implementation.</p><pre class="programlisting">public interface ConnectionFactory implements Serializable, Referenceable {
  ...
  Connection getConnection() throws ResourceException;
  Connection getConnection(ConnectionSpec connectionSpec) throws ResourceException;
  ...
}</pre><p>Spring provided a <code class="literal">ConnectionSpecConnectionFactoryAdapter</code>
      that allows for specifying a <code class="literal">ConnectionSpec</code> instance
      to use for all operations on a given factory. If the adapter's
			<code class="literal">connectionSpec</code> property is specified, the adapter
      uses the <code class="literal">getConnection</code> variant without argument,
      else the one with the <code class="literal">ConnectionSpec</code> argument.</p><pre class="programlisting">&lt;bean id="managedConnectionFactory"
    class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"&gt;
  &lt;property name="connectionURL"&gt;
    &lt;value&gt;jdbc:hsqldb:hsql://localhost:9001&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="driverName"&gt;&lt;value&gt;org.hsqldb.jdbcDriver&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="targetConnectionFactory"
    class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory"&gt;
    &lt;ref local="managedConnectionFactory"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
    class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
  &lt;property name="targetConnectionFactory"&gt;
    &lt;ref bean="targetConnectionFactory"/&gt;
  &lt;/property&gt;
  &lt;property name="connectionSpec"&gt;
    &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
      &lt;property name="user"&gt;&lt;value&gt;sa&lt;/value&gt;&lt;/property&gt;
      &lt;property name="password"&gt;&lt;value/&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14608"></a>20.2.4.&nbsp;Using a single CCI connection</h3></div></div></div><p>If you want to use a single CCI connection, Spring provides a further
      <code class="literal">ConnectionFactory</code> adapter to manage this. The
      <code class="literal">SingleConnectionFactory</code> adapter will open a single
      connection lazily and close it when this bean is destroyed at application
      shutdown. This class will expose special <code class="literal">Connection</code>
      proxies that behave accordingly, all sharing the same underlying physical
			connection.</p><pre class="programlisting">&lt;bean id="eciManagedConnectionFactory"
    class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName"&gt;&lt;value&gt;TEST&lt;/value&gt;&lt;/property&gt;
  &lt;property name="connectionURL"&gt;&lt;value&gt;tcp://localhost/&lt;/value&gt;&lt;/property&gt;
  &lt;property name="portNumber"&gt;&lt;value&gt;2006&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="targetEciConnectionFactory"
    class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory"&gt;
    &lt;ref local="eciManagedConnectionFactory"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="eciConnectionFactory"
    class="org.springframework.jca.cci.connection.SingleConnectionFactory"&gt;
  &lt;property name="targetConnectionFactory"&gt;
    &lt;ref local="targetEciConnectionFactory"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>Important note</em></span>: This
      <code class="literal">ConnectionFactory</code> adapter cannot directly be
      configured with a <code class="literal">ConnectionSpec</code>. Use an
      intermediary <code class="literal">ConnectionSpecConnectionFactoryAdapter</code>
      that the <code class="literal">SingleConnectionFactory</code> talks to
      if you require a single connection for a specific
      <code class="literal">ConnectionSpec</code>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e14643"></a>20.3.&nbsp;Using Spring's CCI access support</h2></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14646"></a>20.3.1.&nbsp;Record conversion</h3></div></div></div><p>One of the aims of the JCA CCI support is to provide convenient
			facilities for manipulating CCI records. The developer can specify the
      strategy to create records and extract datas from records, for use
      with Spring's CciTemplate. The following interfaces will configure the
      strategy to use input and output records if you don't want to work
      with records directly in your application.</p><p>In order to create an input <code class="literal">Record</code>, the
      developer can use a dedicated implementation of the
      <code class="literal">RecordCreator</code> interface.</p><pre class="programlisting">public interface RecordCreator {

  Record createRecord(RecordFactory recordFactory) throws ResourceException, DataAccessException;
}</pre><p>As you can see, the <code class="literal">createRecord</code> method
      receives a <code class="literal">RecordFactory</code> instance as parameter,
			which corresponds to the RecordFactory of the
		  <code class="literal">ConnectionFactory</code> used. This reference can be
			used to create <code class="literal">IndexedRecord</code> or
      <code class="literal">MappedRecord</code> instances. The following sample
      shows how to use the <code class="literal">RecordCreator</code> interface
      and indexed/mapped records.</p><pre class="programlisting">public class MyRecordCreator implements RecordCreator {

  public Record createRecord(RecordFactory recordFactory) throws ResourceException {
    IndexedRecord input = recordFactory.createIndexedRecord("input");
    input.add(new Integer(id));
    return input;
  }
};</pre><p>An output <code class="literal">Record</code> can be used to receive
      data back from the EIS. Hence, a specific implementation of the
      <code class="literal">RecordExtractor</code> interface can be passed to
      Spring's CciTemplate for extracting data from the output
      <code class="literal">Record</code>.</p><pre class="programlisting">public interface RecordExtractor {

  Object extractData(Record record) throws ResourceException, SQLException, DataAccessException;
}</pre><p>The following sample shows how to use the RecordExtractor.</p><pre class="programlisting">public class MyRecordExtractor implements RecordExtractor {

  public Object extractData(Record record) throws ResourceException {
    CommAreaRecord commAreaRecord = (CommAreaRecord) record;
    String str = new String(commAreaRecord.toByteArray());
    String field1 = string.substring(0,6);
    String field2 = string.substring(6,1);
    return new OutputObject(Long.parseLong(field1), field2);
  }
};</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14700"></a>20.3.2.&nbsp;CciTemplate</h3></div></div></div><p>This is the central class of the core CCI support package
      (<code class="literal">org.springframework.jca.cci.core</code>). It simplifies
      the use of CCI since it handles the creation and release of resources.
      This helps to avoid common errors like forgetting to always close the
      connection. It cares for the lifecycle of connection and interaction
			objects, letting application code focus on generating input records
      from application data and extracting application data from output
      records.</p><p>The JCA CCI specification defines two distinct methods to call
      operations on an EIS. The CCI <code class="literal">Interaction</code>
      interface provides two execute method signatures:</p><pre class="programlisting">public interface javax.resource.cci.Interaction {
  ...
  boolean execute(InteractionSpec spec, Record input, Record output) throws ResourceException;

  Record execute(InteractionSpec spec, Record input) throws ResourceException;
  ...
}</pre><p>Depending on the template method called, <code class="literal">CciTemplate</code>
      will know which <code class="literal">execute</code> method to call on the interaction.
      In any case, a correctly initialized <code class="literal">InteractionSpec</code>
      instance is mandatory.</p><p><code class="literal">CciTemplate.execute</code> can be used in two ways:</p><div class="itemizedlist"><ul type="disc"><li><p>With direct <code class="literal">Record</code> arguments. In this case,
          you simply need to pass the CCI input record in, and the returned object
          be the corresponding CCI output record.</p></li><li><p>With application objects, using record mapping. In this case,
          you need to provide corresponding <code class="literal">RecordCreator</code>
				  and <code class="literal">RecordExtractor</code> instances.
          </p></li></ul></div><p>With the first approach, the following methods of the template
      will be used. These methods directly correspond to those on the
      <code class="literal">Interaction</code> interface.</p><pre class="programlisting">public class CciTemplate implements CciOperations {
  ...
  public Record execute(InteractionSpec spec, Record inputRecord)
      throws DataAccessException { ... }

  public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord)
      throws DataAccessException { ... }
  ...
}</pre><p>With the second approach, we need to specify the record creation
      and record extraction strategies as arguments. The interfaces used
      are those describe in the previous section on record conversion.
      The corresponding <code class="literal">CciTemplate</code> methods are the
      following:</p><pre class="programlisting">public class CciTemplate implements CciOperations {
  ...
  public Record execute(InteractionSpec spec, RecordCreator inputCreator)
      throws DataAccessException { ... }

  public Object execute(InteractionSpec spec, Record inputRecord, RecordExtractor outputExtractor)
      throws DataAccessException { ... }

  public Object execute(InteractionSpec spec, RecordCreator creator, RecordExtractor extractor)
      throws DataAccessException { ... }
  ...
}</pre><p>Unless the <code class="literal">outputRecordCreator</code> property is
      set on the template (see the following section), every method will call
      the corresponding <code class="literal">execute</code> method of the CCI
      <code class="literal">Interaction</code> with two parameters:
      <code class="literal">InteractionSpec</code> and input <code class="literal">Record</code>,
			receiving an output <code class="literal">Record</code> as return value.
			</p><p><code class="literal">CciTemplate</code> also provides methods to create
			<code class="literal">IndexRecord</code> and <code class="literal">MappedRecord</code>
      outside a <code class="literal">RecordCreator</code> implementation, through
      its <code class="literal">createIndexRecord</code> and
      <code class="literal">createMappedRecord</code> methods. This can be used
			within DAO implementations to create <code class="literal">Record</code>
			instances to pass into corresponding
      <code class="literal">CciTemplate.execute</code> methods.</p><pre class="programlisting">public class CciTemplate implements CciOperations {
  ...
  public IndexedRecord createIndexedRecord(String name) throws DataAccessException { ... }

  public MappedRecord createMappedRecord(String name) throws DataAccessException { ... }
  ...
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14807"></a>20.3.3.&nbsp;DAO support</h3></div></div></div><p>Spring's CCI support provides a abstract class for DAOs,
      supporting injection of a <code class="literal">ConnectionFactory</code>
      or a <code class="literal">CciTemplate</code> instances. The name of the
      class is <code class="literal">CciDaoSupport</code>: It provides simple
      <code class="literal">setConnectionFactory</code> and
      <code class="literal">setCciTemplate</code> methods. Internally, this
      class will create a <code class="literal">CciTemplate</code> instance
      for a passed-in <code class="literal">ConnectionFactory</code>, exposing
      it to concrete data access implementations in subclasses.</p><pre class="programlisting">public abstract class CciDaoSupport {
  ...
  public void setConnectionFactory(ConnectionFactory connectionFactory) { ... }
  public ConnectionFactory getConnectionFactory() { ... }

  public void setCciTemplate(CciTemplate cciTemplate) { ... }
  public CciTemplate getCciTemplate() { ... }
  ...
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="automatic-output-generation"></a>20.3.4.&nbsp;Automatic output record generation</h3></div></div></div><p>If the connector used only supports the
			<code class="literal">Interaction.execute</code> method with input and output
      records as parameters (that is, it requires the desired output record
      to be passed in instead of returning an appropriate output record),
      you can set the <code class="literal">outputRecordCreator</code> property of the
      <code class="literal">CciTemplate</code> to automatically generate an output
      record to be filled by the JCA connector when the response is received.
      This record will be then returned to the caller of the template.</p><p>This property simply holds an implementation of the
      <code class="literal">RecordCreator</code> interface, used for that purpose.
      The <code class="literal">RecordCreator</code> interface has already been
      discussed in a previous section. The <code class="literal">outputRecordCreator</code>
      property must be directly specified on the <code class="literal">CciTemplate</code>.
      This could be done in the application code:</p><pre class="programlisting">cciTemplate.setOutputRecordCreator(new EciOutputRecordCreator());
</pre><p>or in the Spring configuration, if the <code class="literal">CciTemplate</code>
      is configured as a dedicated bean instance:</p><pre class="programlisting">&lt;bean id="eciOutputRecordCreator" class="eci.EciOutputRecordCreator"/&gt;

&lt;bean id="cciTemplate" class="org.springframework.jca.cci.core.CciTemplate"&gt;
  &lt;property name="connectionFactory"&gt;
    &lt;ref local="eciConnectionFactory"/&gt;
  &lt;/property&gt;
  &lt;property name="outputRecordCreator"&gt;
    &lt;ref local="eciOutputRecordCreator"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p><code class="literal">Note</code>: As the <code class="literal">CciTemplate</code>
      class is thread-safe, it will usually be configured as a shared instance.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="template-summary"></a>20.3.5.&nbsp;Summary</h3></div></div></div><p>The following table summarizes the mechanism of the
      <code class="literal">CciTemplate</code> class and the corresponding methods
      called on the CCI <code class="literal">Interaction</code> interface:</p><div class="table"><a name="d0e14890"></a><p class="title"><b>Table&nbsp;20.1.&nbsp;Usage of Interaction execute methods</b></p><div class="table-contents"><table summary="Usage of Interaction execute methods" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">CciTemplate method signature</th><th align="center">CciTemplate outputRecordCreator
                property</th><th align="center">execute method called on the CCI
                Interaction</th></tr></thead><tbody><tr><td align="center">Record execute(InteractionSpec,
                Record)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                Record)</td><td align="center">set</td><td align="center">boolean execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">void execute(InteractionSpec, Record,
                Record)</td><td align="center">not set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">void execute(InteractionSpec, Record,
                Record)</td><td align="center">set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                RecordCreator)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                RecordCreator)</td><td align="center">set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec, Record,
                RecordExtractor)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec, Record,
                RecordExtractor)</td><td align="center">set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                RecordCreator, RecordExtractor)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                RecordCreator, RecordExtractor)</td><td align="center">set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr></tbody></table></div></div><p><br class="table-break"></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e14973"></a>20.3.6.&nbsp;Using a CCI Connection and Interaction directly</h3></div></div></div><p><code class="literal">CciTemplate</code> also offers the possibility to
      work directly with CCI connections and interactions, in the same manner
      as <code class="literal">JdbcTemplate</code> and <code class="literal">JmsTemplate</code>.
      This is useful when you want to perform multiple operations on a CCI
      connection or interaction, for example.</p><p>The interface <code class="literal">ConnectionCallback</code> provides a
      CCI <code class="literal">Connection</code> as argument, in order to perform
      custom operations on it, plus the CCI <code class="literal">ConnectionFactory</code>
      which the <code class="literal">Connection</code> was created with. The latter
      can be useful for example to get an associated <code class="literal">RecordFactory</code>
      instance and create indexed/mapped records, for example.</p><pre class="programlisting">public interface ConnectionCallback {

  Object doInConnection(Connection connection, ConnectionFactory connectionFactory)
      throws ResourceException, SQLException, DataAccessException;
}</pre><p>The interface <code class="literal">InteractionCallback</code> provides
      the CCI <code class="literal">Interaction</code>, in order to perform custom
      operations on it, plus the corresponding CCI <code class="literal">ConnectionFactory</code>.
			</p><pre class="programlisting">public interface InteractionCallback {

  Object doInInteraction(Interaction interaction, ConnectionFactory connectionFactory)
      throws ResourceException, SQLException, DataAccessException;
}</pre><p><code class="literal">Note</code>: <code class="literal">InteractionSpec</code> objects
      can either be shared across multiple template calls and newly created
      inside every callback method. This is completely up to the DAO implementation.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15025"></a>20.3.7.&nbsp;Example for CciTemplate usage</h3></div></div></div><p>In this section, the usage of the <code class="literal">CciTemplate</code>
      will be shown to acces to a CICS with ECI mode, with the IBM CICS ECI
      connector.</p><p>Firstly, some initializations on the CCI
      <code class="literal">InteractionSpec</code> must be done to specify which CICS
      program to access and how to interact with it.</p><pre class="programlisting">ECIInteractionSpec interactionSpec = new ECIInteractionSpec();
interactionSpec.setFunctionName("MYPROG");
interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);</pre><p>Then the program can use CCI via Spring's template and specify
      mappings between custom objects and CCI <code class="literal">Records</code>.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public OutputObject getData(InputObject input) {
    ECIInteractionSpec interactionSpec = ...;

    OutputObject output = (ObjectOutput) getCciTemplate().execute(interactionSpec,
        new RecordCreator() {
          public Record createRecord(RecordFactory recordFactory) throws ResourceException {
            return new CommAreaRecord(input.toString().getBytes());
          }
        },
        new RecordExtractor() {
          public Object extractData(Record record) throws ResourceException {
            CommAreaRecord commAreaRecord = (CommAreaRecord)record;
            String str = new String(commAreaRecord.toByteArray());
            String field1 = string.substring(0,6);
            String field2 = string.substring(6,1);
            return new OutputObject(Long.parseLong(field1), field2);
          }
        });

    return output;
  }
}</pre><p>As discussed previously, callbacks can be used to work
      directly on CCI connections or interactions.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public OutputObject getData(InputObject input) {
    ObjectOutput output = (ObjectOutput) getCciTemplate().execute(
        new ConnectionCallback() {
          public Object doInConnection(Connection connection, ConnectionFactory factory)
              throws ResourceException {
            ...
          }
        });
    }
    return output;
  }
}</pre><p><span class="emphasis"><em>Important note</em></span>: With a ConnectionCallback,
      the <code class="literal">Connection</code> used will be managed and closed by
			the <code class="literal">CciTemplate</code>, but any interactions created
      on the connection must be managed by the callback implementation.</p><p>For a more specific callback, you can implement an
			<code class="literal">InteractionCallback</code>. The passed-in
			<code class="literal">Interaction</code> will be managed and closed by the
			<code class="literal">CciTemplate</code> in this case.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public String getData(String input) {
    ECIInteractionSpec interactionSpec = ...;

    String output = (String) getCciTemplate().execute(interactionSpec,
        new InteractionCallback() {
          public Object doInInteraction(Interaction interaction, ConnectionFactory factory)
              throws ResourceException {
            Record input = new CommAreaRecord(inputString.getBytes());
            Record output = new CommAreaRecord();
            interaction.execute(holder.getInteractionSpec(), input, output);
            return new String(output.toByteArray());
          }
        });

    return output;
  }
}</pre><p>For the examples above, the corresponding configuration of the
      involved Spring beans could look like this in non-managed mode:</p><pre class="programlisting">&lt;bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName"&gt;&lt;value&gt;TXSERIES&lt;/value&gt;&lt;/property&gt;
  &lt;property name="connectionURL"&gt;&lt;value&gt;local:&lt;/value&gt;&lt;/property&gt;
  &lt;property name="userName"&gt;&lt;value&gt;CICSUSER&lt;/value&gt;&lt;/property&gt;
  &lt;property name="password"&gt;&lt;value&gt;CICS&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory"&gt;
    &lt;ref local="managedConnectionFactory"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="mypackage.MyDaoImpl"&gt;
  &lt;property name="connectionFactory"&gt;&lt;ref local="connectionFactory"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>In managed mode (that is, in a J2EE environment), the configuration
			could look as follows:</p><pre class="programlisting">&lt;bean id="connectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName"&gt;&lt;value&gt;eis/cicseci&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory"&gt;&lt;ref local="connectionFactory"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15082"></a>20.4.&nbsp;Modeling CCI access as operation objects</h2></div></div></div><p>The <code class="literal">org.springframework.jca.cci.object</code> package
    contains support classes that allow you to access the EIS in a different
    style: through reusable operation objects, analogous to Spring's JDBC
    operation objects (see JDBC chapter). This will usually encapsulate the
    CCI API: an application-level input object will be passed to the operation
    object, so it can construct the input record and then convert the received
    record data to an application-level output object and return it.</p><p><span class="emphasis"><em>Note</em></span>: This approach is internally based on the
		<code class="literal">CciTemplate</code> class and the <code class="literal">RecordCreator</code>
     / <code class="literal">RecordExtractor</code> interfaces, reusing the machinery of
     Spring's core CCI support.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15103"></a>20.4.1.&nbsp;MappingRecordOperation</h3></div></div></div><p><code class="literal">MappingRecordOperation</code> essentially performs the
      same work as <code class="literal">CciTemplate</code>, but represents a specific,
      pre-configured operation as an object. It provides two template methods
      to specify how to convert an input object to a input record, and how to
      convert an output record to an output object (record mapping):</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">createInputRecord</code> to specify how to
          convert an input object to an input <code class="literal">Record</code></p></li><li><p><code class="literal">extractOutputData</code> to specify how to
          extract an output object from an output <code class="literal">Record</code></p></li></ul></div><p>Here are the signatures of these methods:</p><pre class="programlisting">public abstract class MappingRecordOperation extends EisOperation {
  ...
  protected abstract Record createInputRecord(RecordFactory recordFactory, Object inputObject)
      throws ResourceException, DataAccessException { ... }

  protected abstract Object extractOutputData(Record outputRecord)
      throws ResourceException, SQLException, DataAccessException { ... }
  ...
}</pre><p>Thereafter, in order to execute an EIS operation, you need to use
      a single execute method, passing in an application-level input object
			and receiving an application-level output object as result:</p><pre class="programlisting">public abstract class MappingRecordOperation extends EisOperation {
  ...
  public Object execute(Object inputObject) throws DataAccessException {
  ...
}</pre><p>As you can see, contrary to the <code class="literal">CciTemplate</code> class,
			this <code class="literal">execute</code> method does not have an
			<code class="literal">InteractionSpec</code> as argument. Instead, the
			<code class="literal">InteractionSpec</code> is global to the operation.
			The following constructor must be used to instantiate an operation
      object with a specific <code class="literal">InteractionSpec</code>:</p><pre class="programlisting">InteractionSpec spec = ...;
MyMappingRecordOperation eisOperation = new MyMappingRecordOperation(getConnectionFactory(), spec);
...
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15155"></a>20.4.2.&nbsp;MappingCommAreaOperation</h3></div></div></div><p>Some connectors use records based on a COMMAREA which represents
      an array of bytes containing parameters to send to the EIS and data
      returned by it. Spring provides a special operation class for working
      directly on COMMAREA rather than on records. The
      <code class="literal">MappingCommAreaOperation</code> class extends the
      <code class="literal">MappingRecordOperation</code> class to provide such special
      COMMAREA support. It implicitly uses the <code class="literal">CommAreaRecord</code>
      class as input and output record type, and provides two new methods to
      convert an input object into an input COMMAREA and the output COMMAREA
      into an output object.</p><pre class="programlisting">public abstract class MappingCommAreaOperation extends MappingRecordOperation {
  ...
  protected abstract byte[] objectToBytes(Object inObject)
      throws IOException, DataAccessException;

  protected abstract Object bytesToObject(byte[] bytes)
      throws IOException, DataAccessException;
  ...
}</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15171"></a>20.4.3.&nbsp;Automatic output record generation</h3></div></div></div><p>As every <code class="literal">MappingRecordOperation</code> subclass is
      based on CciTemplate internally, the same way to automatically generate
      output records as with <code class="literal">CciTemplate</code> is available.
			Every operation object provides a corresponding
      <code class="literal">setOutputRecordCreator</code> method. For further information,
			see <a href="#automatic-output-generation" title="20.3.4.&nbsp;Automatic output record generation">the previous
      "automatic output record generation" section</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15188"></a>20.4.4.&nbsp;Summary</h3></div></div></div><p>The operation object approach uses records in the same manner
      as the <code class="literal">CciTemplate</code> class.</p><div class="table"><a name="d0e15196"></a><p class="title"><b>Table&nbsp;20.2.&nbsp;Usage of Interaction execute methods</b></p><div class="table-contents"><table summary="Usage of Interaction execute methods" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">MappingRecordOperation method
                signature</th><th align="center">MappingRecordOperarion
                outputRecordCreator property</th><th align="center">execute method called on the CCI
                Interaction</th></tr></thead><tbody><tr><td align="center">Object execute(Object)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Object execute(Object)</td><td align="center">set</td><td align="center">boolean execute(InteractionSpec, Record,
                Record)</td></tr></tbody></table></div></div><p><br class="table-break"></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15223"></a>20.4.5.&nbsp;Example for MappingRecordOperation usage</h3></div></div></div><p>In this section, the usage of the
      <code class="literal">MappingRecordOperation</code> will be shown to access a
      database with the Blackbox CCI connector.</p><p><code class="literal">Note</code>: The original version of this connector
      is provided by the J2EE SDK (version 1.3), available from Sun.</p><p>Firstly, some initializations on the CCI
      <code class="literal">InteractionSpec</code> must be done to specify which SQL
      request to execute. In this sample, we directly define the way to
      convert the parameters of the request to a CCI record and the way to
      convert the CCI result record to an instance of the
      <code class="literal">Person</code> class.</p><pre class="programlisting">public class PersonMappingOperation extends MappingRecordOperation {

  public PersonMappingOperation(ConnectionFactory connectionFactory) {
    setConnectionFactory(connectionFactory);
    CciInteractionSpec interactionSpec = new CciConnectionSpec();
    interactionSpec.setSql("select * from person where person_id=?");
    setInteractionSpec(interactionSpec);
  }

  protected Record createInputRecord(RecordFactory recordFactory, Object inputObject)
      throws ResourceException {
    Integer id = (Integer) inputObject;
    IndexedRecord input = recordFactory.createIndexedRecord("input");
    input.add(new Integer(id));
    return input;
  }

  protected Object extractOutputData(Record outputRecord)
      throws ResourceException, SQLException {
    ResultSet rs = (ResultSet) outputRecord;
    Person person = null;
    if (rs.next()) {
      Person person = new Person();
      person.setId(rs.getInt("person_id"));
      person.setLastName(rs.getString("person_last_name"));
      person.setFirstName(rs.getString("person_first_name"));
    }
    return person;
  }
}</pre><p>Then the application can execute the operation object, with the
      person identifier as argument. Note that operation object could be
			set up as shared instance, as it is thread-safe.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public Person getPerson(int id) {
    PersonMappingOperation query = new PersonMappingOperation(getConnectionFactory());
    Person person = (Person) query.execute(new Integer(id));
    return person;
  }
}</pre><p>The corresponding configuration of Spring beans could look
      as follows in non-managed mode:</p><pre class="programlisting">&lt;bean id="managedConnectionFactory"
    class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"&gt;
  &lt;property name="connectionURL"&gt;
    &lt;value&gt;jdbc:hsqldb:hsql://localhost:9001&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="driverName"&gt;&lt;value&gt;org.hsqldb.jdbcDriver&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="targetConnectionFactory"
    class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory"&gt;
    &lt;ref local="managedConnectionFactory"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
    class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
  &lt;property name="targetConnectionFactory"&gt;
    &lt;ref bean="targetConnectionFactory"/&gt;
  &lt;/property&gt;
  &lt;property name="connectionSpec"&gt;
    &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
      &lt;property name="user"&gt;&lt;value&gt;sa&lt;/value&gt;&lt;/property&gt;
      &lt;property name="password"&gt;&lt;value/&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory"&gt;&lt;ref local="connectionFactory"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>In managed mode (that is, in a J2EE environment), the configuration
			could look as follows:</p><pre class="programlisting">&lt;bean id="targetConnectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName"&gt;&lt;value&gt;eis/blackbox&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
    class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
  &lt;property name="targetConnectionFactory"&gt;
    &lt;ref bean="targetConnectionFactory"/&gt;
  &lt;/property&gt;
  &lt;property name="connectionSpec"&gt;
    &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
      &lt;property name="user"&gt;&lt;value&gt;sa&lt;/value&gt;&lt;/property&gt;
      &lt;property name="password"&gt;&lt;value/&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory"&gt;&lt;ref local="connectionFactory"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15257"></a>20.4.6.&nbsp;Example for MappingCommAreaOperation usage</h3></div></div></div><p>In this section, the usage of the
      <code class="literal">MappingCommAreaOperation</code> will be shown: accessing
      a CICS with ECI mode with the IBM CICS ECI connector.</p><p>Firstly, the CCI <code class="literal">InteractionSpec</code> needs to be
      initialized to specify which CICS program to access and how to interact
      with it.</p><pre class="programlisting">public abstract class EciMappingOperation extends MappingCommAreaOperation {

  public EciMappingOperation(ConnectionFactory connectionFactory, String programName) {
    setConnectionFactory(connectionFactory);
    ECIInteractionSpec interactionSpec = new ECIInteractionSpec(),
    interactionSpec.setFunctionName(programName);
    interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);
    interactionSpec.setCommareaLength(30);
    setInteractionSpec(interactionSpec);
    setOutputRecordCreator(new EciOutputRecordCreator());
  }

  private static class EciOutputRecordCreator implements RecordCreator {
    public Record createRecord(RecordFactory recordFactory) throws ResourceException {
      return new CommAreaRecord();
    }
  }
}</pre><p>The abstract <code class="literal">EciMappingOperation</code> class can
      then be subclassed to specify mappings between custom objects and
			<code class="literal">Records</code>.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public OutputObject getData(Integer id) {
    EciMappingOperation query = new EciMappingOperation(getConnectionFactory(), "MYPROG") {
      protected abstract byte[] objectToBytes(Object inObject) throws IOException {
        Integer id = (Integer) inObject;
        return String.valueOf(id);
      }
      protected abstract Object bytesToObject(byte[] bytes) throws IOException;
        String str = new String(bytes);
        String field1 = str.substring(0,6);
        String field2 = str.substring(6,1);
        String field3 = str.substring(7,1);
        return new OutputObject(field1, field2, field3);
      }
    });

    return (OutputObject) query.execute(new Integer(id));
  }
}</pre><p>The corresponding configuration of Spring beans could look
			as follows in non-managed mode:</p><pre class="programlisting">&lt;bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName"&gt;&lt;value&gt;TXSERIES&lt;/value&gt;&lt;/property&gt;
  &lt;property name="connectionURL"&gt;&lt;value&gt;local:&lt;/value&gt;&lt;/property&gt;
  &lt;property name="userName"&gt;&lt;value&gt;CICSUSER&lt;/value&gt;&lt;/property&gt;
  &lt;property name="password"&gt;&lt;value&gt;CICS&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory"&gt;
    &lt;ref local="managedConnectionFactory"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory"&gt;&lt;ref local="connectionFactory"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>In managed mode (that is, in a J2EE environment), the configuration
			could look as follows:</p><pre class="programlisting">&lt;bean id="connectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName"&gt;&lt;value&gt;eis/cicseci&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory"&gt;&lt;ref local="connectionFactory"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15290"></a>20.5.&nbsp;Transactions</h2></div></div></div><p>JCA specifies several levels of transaction suppot for resource adapters.
    The kind of transactions that your resource adapter supports is specified
    in its <code class="filename">ra.xml</code> file. There are essentially three options:
    none (for example with CICS EPI connector), local transactions (for
    example with CICS ECI connector), global transactions (for example with
    IMS connector).</p><pre class="programlisting">&lt;connector&gt;
  ...
  &lt;resourceadapter&gt;
    ...
    &lt;!-- transaction-support&gt;NoTransaction&lt;/transaction-support --&gt;
    &lt;!-- transaction-support&gt;LocalTransaction&lt;/transaction-support --&gt;
    &lt;transaction-support&gt;XATransaction&lt;/transaction-support&gt;
    ...
  &lt;resourceadapter&gt;
  ...
&lt;connector&gt;</pre><p>For global transactions, you can use Spring's generic transaction
		infrastructure to demarcate transactions, with JtaTransactionManager as
		backend (delegating to the J2EE server's distributed transaction coordinator
		underneath).</p><p>For local transactions on a single CCI <code class="literal">ConnectionFactory</code>,
    Spring provides a specific transaction management strategy for CCI, analogous
    to the <code class="literal">DataSourceTransactionManager</code> for JDBC. The CCI API
    defines a local transaction object and corresponding local transaction
		demarcation methods. Spring's <code class="literal">CciLocalTransactionManager</code>
    executes such local CCI transactions, fully compliant with Spring's generic
    <code class="literal">PlatformTransactionManager</code> abstraction.</p><pre class="programlisting">&lt;bean id="eciConnectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName"&gt;
    &lt;value&gt;eis/cicseci&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="eciTransactionManager"
    class="org.springframework.jca.cci.connection.CciLocalTransactionManager"&gt;
  &lt;property name="connectionFactory"&gt;
    &lt;ref local="eciConnectionFactory" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Both transaction strategies can be used with any of Spring's
    transaction demarcation facilities, be it declarative or programmatic.
    This is a consequence of Spring's generic
    <code class="literal">PlatformTransactionManager</code> abstraction, which
		decouples transaction demarcation from the actual execution strategy.
		Simply switch between <code class="literal">JtaTransactionManager</code> and
		<code class="literal">CciLocalTransactionManager</code> as needed, keeping
		your transaction demarcation as-is.</p><p>For more information on Spring's transaction facilities, see the
		<a href="#transaction" title="Chapter&nbsp;8.&nbsp;Transaction management">transaction management chapter</a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mail"></a>Chapter&nbsp;21.&nbsp;Sending Email with Spring mail abstraction layer</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-introduction"></a>21.1.&nbsp;Introduction</h2></div></div></div><p>Spring provides a higher level of abstraction for sending electronic
    mail which shields the user from the specifics of underlying mailing
    system and is responsible for a low level resource handling on behalf of
    the client.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-structure"></a>21.2.&nbsp;Spring mail abstraction structure</h2></div></div></div><p>The main package of Spring mail abstraction layer is
    <code class="literal">org.springframework.mail</code> package. It contains central
    interface for sending emails called <code class="literal">MailSender</code> and the
    <span class="emphasis"><em>value object</em></span> which encapsulates properties of a
    simple mail such as <span class="emphasis"><em>from</em></span>, <span class="emphasis"><em>to</em></span>,
    <span class="emphasis"><em>cc</em></span>, <span class="emphasis"><em>subject</em></span>,
    <span class="emphasis"><em>text</em></span> called <code class="literal">SimpleMailMessage</code>.
    This package also contains a hierarchy of checked exceptions which provide
    a higher level of abstraction over the lower level mail system exceptions
    with the root exception being <code class="literal">MailException.</code>Please
    refer to JavaDocs for more information on mail exception hierarchy.</p><p>Spring also provides a sub-interface of <code class="literal">MailSender</code>
    for specialized <span class="emphasis"><em>JavaMail</em></span> features such as MIME
    messages, namely
    <code class="literal">org.springframework.mail.javamail.JavaMailSender</code> It
    also provides a callback interface for preparation of JavaMail MIME
    messages, namely
    <code class="literal">org.springframework.mail.javamail.MimeMessagePreparator</code></p><p>MailSender: </p><pre class="programlisting">public interface MailSender {

    /**
     * Send the given simple mail message.
     * @param simpleMessage message to send
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(SimpleMailMessage simpleMessage) throws MailException;

    /**
     * Send the given array of simple mail messages in batch.
     * @param simpleMessages messages to send
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(SimpleMailMessage[] simpleMessages) throws MailException;

}</pre><p> JavaMailSender: </p><pre class="programlisting">public interface JavaMailSender extends MailSender {

    /**
     * Create a new JavaMail MimeMessage for the underlying JavaMail Session
     * of this sender. Needs to be called to create MimeMessage instances
     * that can be prepared by the client and passed to send(MimeMessage).
     * @return the new MimeMessage instance
     * @see #send(MimeMessage)
     * @see #send(MimeMessage[])
     */
    public MimeMessage createMimeMessage();

    /**
     * Send the given JavaMail MIME message.
     * The message needs to have been created with createMimeMessage.
     * @param mimeMessage message to send
     * @throws MailException in case of message, authentication, or send errors
     * @see #createMimeMessage
     */
    public void send(MimeMessage mimeMessage) throws MailException;

    /**
     * Send the given array of JavaMail MIME messages in batch.
     * The messages need to have been created with createMimeMessage.
     * @param mimeMessages messages to send
     * @throws MailException in case of message, authentication, or send errors
     * @see #createMimeMessage
     */
    public void send(MimeMessage[] mimeMessages) throws MailException;

    /**
     * Send the JavaMail MIME message prepared by the given MimeMessagePreparator.
     * Alternative way to prepare MimeMessage instances, instead of createMimeMessage
     * and send(MimeMessage) calls. Takes care of proper exception conversion.
     * @param mimeMessagePreparator the preparator to use
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(MimeMessagePreparator mimeMessagePreparator) throws MailException;

    /**
     * Send the JavaMail MIME messages prepared by the given MimeMessagePreparators.
     * Alternative way to prepare MimeMessage instances, instead of createMimeMessage
     * and send(MimeMessage[]) calls. Takes care of proper exception conversion.
     * @param mimeMessagePreparators the preparator to use
     * @throws MailException in case of message, authentication, or send errors
     */
    public void send(MimeMessagePreparator[] mimeMessagePreparators) throws MailException;

}</pre><p> MimeMessagePreparator: </p><pre class="programlisting">public interface MimeMessagePreparator {

    /**
     * Prepare the given new MimeMessage instance.
     * @param mimeMessage the message to prepare
     * @throws MessagingException passing any exceptions thrown by MimeMessage
     * methods through for automatic conversion to the MailException hierarchy
     */
    void prepare(MimeMessage mimeMessage) throws MessagingException;

}</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-usage"></a>21.3.&nbsp;Using Spring mail abstraction</h2></div></div></div><p>Let's assume there is a business interface called
    <code class="literal">OrderManager</code></p><pre class="programlisting">public interface OrderManager {

    void placeOrder(Order order);
}</pre><p> and there is a use case that says that an email message
    with order number would need to be generated and sent to a customer
    placing that order. So for this purpose we want to use
    <code class="literal">MailSender</code> and
    <code class="literal">SimpleMailMessage</code></p><p><span class="emphasis"><em>Please note that as usual, we work with interfaces in the
    business code and let Spring IoC container take care of wiring of all the
    collaborators for us.</em></span></p><p>Here is the implementation of <code class="literal">OrderManager</code>
    </p><pre class="programlisting">import org.springframework.mail.MailException;
import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;

public class OrderManagerImpl implements OrderManager {

    private MailSender mailSender;
    private SimpleMailMessage message;

    public void setMailSender(MailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void setMessage(SimpleMailMessage message) {
        this.message = message;
    }

    public void placeOrder(Order order) {

        //... * Do the business calculations....
        //... * Call the collaborators to persist the order

        //Create a thread safe "sandbox" of the message
        SimpleMailMessage msg = new SimpleMailMessage(this.message);
        msg.setTo(order.getCustomer().getEmailAddress());
        msg.setText(
            "Dear "
                + order.getCustomer().getFirstName()
                + order.getCustomer().getLastName()
                + ", thank you for placing order. Your order number is "
                + order.getOrderNumber());
        try{
            mailSender.send(msg);
        }
        catch(MailException ex) {
            //log it and go on
            System.err.println(ex.getMessage());            
        }
    }
}</pre><p>Here is what the bean definitions for the code above would
    look like:</p><pre class="programlisting">&lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
  &lt;property name="host"&gt;&lt;value&gt;mail.mycompany.com&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="mailMessage" class="org.springframework.mail.SimpleMailMessage"&gt;
  &lt;property name="from"&gt;&lt;value&gt;customerservice@mycompany.com&lt;/value&gt;&lt;/property&gt;
  &lt;property name="subject"&gt;&lt;value&gt;Your order&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="orderManager" class="com.mycompany.businessapp.support.OrderManagerImpl"&gt;
  &lt;property name="mailSender"&gt;&lt;ref bean="mailSender"/&gt;&lt;/property&gt;
  &lt;property name="message"&gt;&lt;ref bean="mailMessage"/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>Here is the implementation of <code class="literal">OrderManager</code> using
    <code class="literal">MimeMessagePreparator</code> callback interface. Please note
    that the mailSender property is of type <code class="literal">JavaMailSender</code>
    in this case in order to be able to use JavaMail MimeMessage:
    </p><pre class="programlisting">import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import javax.mail.internet.MimeMessage;
import org.springframework.mail.MailException;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;

public class OrderManagerImpl implements OrderManager {

    private JavaMailSender mailSender;
    
    public void setMailSender(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void placeOrder(final Order order) {

        //... * Do the business calculations....
        //... * Call the collaborators to persist the order
        
        MimeMessagePreparator preparator = new MimeMessagePreparator() {
            public void prepare(MimeMessage mimeMessage) throws MessagingException {
                mimeMessage.setRecipient(Message.RecipientType.TO, 
                        new InternetAddress(order.getCustomer().getEmailAddress()));
                mimeMessage.setFrom(new InternetAddress("mail@mycompany.com"));
                mimeMessage.setText(
                    "Dear "
                        + order.getCustomer().getFirstName()
                        + order.getCustomer().getLastName()
                        + ", thank you for placing order. Your order number is "
                        + order.getOrderNumber());
            }
        };
        try{
            mailSender.send(preparator);
        }
        catch (MailException ex) {
            //log it and go on
            System.err.println(ex.getMessage());            
        }
    }
}</pre><p>If you want to use JavaMail MimeMessage to the full power, the
    <code class="literal">MimeMessagePreparator</code> is available at your
    fingertips.</p><p><span class="emphasis"><em>Please note that the mail code is a crosscutting concern
    and is a perfect candidate for refactoring into a custom Spring AOP advice,
    which then could easily be applied to OrderManager target. Please see the
    AOP chapter.</em></span></p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15449"></a>21.3.1.&nbsp;Pluggable MailSender implementations</h3></div></div></div><p>Spring comes with two MailSender implementations out of the box -
      the JavaMail implementation and the implementation on top of Jason
      Hunter's <span class="emphasis"><em>MailMessage</em></span> class that's included in
      <a href="http://servlets.com/cos" target="_top">http://servlets.com/cos</a>
      (com.oreilly.servlet). Please refer to JavaDocs for more
      information.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15460"></a>21.4.&nbsp;Using the JavaMail MimeMessageHelper</h2></div></div></div><p>
  		One of the components that comes in pretty handy when dealing with
  		JavaMail messages is the <code class="literal">org.springframework.mail.javamail.MimeMessageHelper</code>.
  		It prevents you from having to use the nasty APIs the the <code class="literal">javax.mail.internet</code> classes.
  		A couple of possible scenarios:
  	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15471"></a>21.4.1.&nbsp;Creating a simple MimeMessage and sending it</h3></div></div></div><p>
  			Using the MimeMessageHelper it's pretty easy to setup and send a MimeMessage:
  			</p><pre class="programlisting">
// of course you would setup the mail sender using 
// DI in any real-world cases
JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMesage();
MimeMessageHelper helper = new MimeMessageHelper(message);
helper.setTo("test@host.com");
helper.setText("Thank you for ordering!");

sender.send(message);
			</pre><p>
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15479"></a>21.4.2.&nbsp;Sending attachments and inline resources</h3></div></div></div><p>
			Email allow for attachments, but also for inline resources in multipart
			messages. Inline resources could for example be images or stylesheet you
			want to use in your message, but don't want displayed as attachment.
			The following shows you how to use the MimeMessageHelper to send an
			email along with an inline image.
			</p><pre class="programlisting">
JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMesage();

// use the true flag to indicate you need a multipart message
MimeMessageHelper helper = new MimeMessageHelper(message, true);
helper.setTo("test@host.com");

// use the true flag to indicate the text included is HTML
helper.setText(
  "&lt;html&gt;&lt;body&gt;&lt;img src='cid:identifier1234'&gt;&lt;/body&gt;&lt;/html&gt;"
  true);

// let's include the infamous windows Sample file (this time copied to c:/)
FileSystemResource res = new FileSystemResource(new File("c:/Sample.jpg"));
helper.addInline("identifier1234", res);

// if you would need to include the file as an attachment, use
// addAttachment() methods on the MimeMessageHelper

sender.send(message);
			</pre><p>
			<span class="emphasis"><em>Inline resources are added to the mime message using the Content-ID specified
			as you've seen just now (<code class="literal">identifier1234</code> in this case). The order in 
			which you're adding the text and the resource are VERY important. First add the text
			and after that the resources. If you're doing it the other way around, it won't work!</em></span>
		</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="scheduling"></a>Chapter&nbsp;22.&nbsp;Scheduling jobs using Quartz or Timer</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15496"></a>22.1.&nbsp;Introduction</h2></div></div></div><p>
  		Spring features integration classes for scheduling support. Currently, Spring
  		supports the Timer, part of the JDK since 1.3, and the Quartz Scheduler
  		(<a href="http://www.quartzscheduler.org" target="_top">http://www.quartzscheduler.org</a>). Both schedulers are set up
  		using a FactoryBean with optional references to Timers or Triggers, respectively.
  		Furthermore, a convenience class for both the Quartz Scheduler and the Timer is
  		available that allows you to invoke a method of an existing target object
			(analogous to normal <code class="literal">MethodInvokingFactoryBeans</code>).
  	</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15506"></a>22.2.&nbsp;Using the OpenSymphony Quartz Scheduler</h2></div></div></div><p>
  		Quartz uses <code class="literal">Triggers</code>, <code class="literal">Jobs</code> and 
  		<code class="literal">JobDetail</code> ro realize scheduling of all kinds of jobs.
  		For the basic concepts behind Quartz, have a look at 
  		<a href="http://www.opensymphony.com/quartz" target="_top">http://www.opensymphony.com/quartz</a>. For convenience purposes,
  		Spring offers a couple of classes that simplify usage of Quartz within
  		Spring-based applications.
  	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15522"></a>22.2.1.&nbsp;Using the JobDetailBean</h3></div></div></div><p>
  			<code class="literal">JobDetail</code> objects contain all information needed to
  			run a job. Spring provides a so-called <code class="literal">JobDetailBean</code>
  			that makes the JobDetail more of an actual JavaBean with sensible defaults.
  			Let's have a look at an example:
  			</p><pre class="programlisting">
&lt;bean name="exampleJob" class="org.springframework.scheduling.quartz.JobDetailBean"&gt;
  &lt;property name="jobClass" value="example.ExampleJob"/&gt;
  &lt;property name="jobDataAsMap"&gt;
    &lt;map&gt;
      &lt;entry key="timeout" value="5"/&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;
			</pre><p>
			
			The job detail bean has all information it needs to run the job (ExampleJob).
			The timeout is specified as the job data map. The job data map is
			available through the JobExecutionContext (passed to you at execution time),
			but the <code class="literal">JobDetailBean</code> also maps the properties from the
			job data map to properties of the actual job. So in this case, if the ExampleJob contains
			a property named <code class="literal">timeout</code>, the JobDetailBean will automatically apply it:
			</p><pre class="programlisting">
package example;

public class ExampleJob extends QuartzJobBean {

  private int timeout;
  
  /**
   * Setter called after the ExampleJob is instantiated
   * with the value from the JobDetailBean (5)
   */ 
  public void setTimeout(int timeout) {
    this.timeout = timeout;
  }
  
  protected void executeInternal(JobExecutionContext ctx)
  throws JobExecutionException {
      // do the actual work
  }
}
			</pre><p>
			
			All additional settings from the job detail bean are of course available to you as well.
		</p><p>
			<span class="emphasis"><em>Note: Using the <code class="literal">name</code> and <code class="literal">group</code> properties,
			you can modify the name and the group of the job, respectively. By default the name of
			the job equals the bean name of the job detail bean (in the example above, this is
			<code class="literal">exampleJob</code>).</em></span>
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15559"></a>22.2.2.&nbsp;Using the MethodInvokingJobDetailFactoryBean</h3></div></div></div><p>
			Often you just need to invoke a method on a specific object. Using the
			<code class="literal">MethodInvokingJobDetailFactoryBean</code> you can do exactly this:
			</p><pre class="programlisting">
&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
  &lt;property name="targetObject" ref="exampleBusinessObject"/&gt;
  &lt;property name="targetMethod" value="doIt"/&gt;
&lt;/bean&gt;
</pre><p>
			The above example will result in the <code class="literal">doIt</code> being called on the exampleBusinessObject
			(see below):
			</p><pre class="programlisting">
public class BusinessObject {
  
  // properties and collaborators
  
  public void doIt() {
    // do the actual work
  }
}
			</pre><p>

			</p><pre class="programlisting">
&lt;bean id="exampleBusinessObject" class="examples.ExampleBusinessObject"/&gt;
			</pre><p>	
			Using the <code class="literal">MethodInvokingJobDetailFactoryBean</code> you don't need to
			create one-line jobs that just invoke a method, and you only need to create the actual
			business object and wire up the detail object.
		</p><p>
			By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering
			with each other. If you specify two triggers for the same JobDetail, it might be possible
			that before the first job has finished, the second one will start. If JobDetail objects
			implement the Stateful interface, this won't happen. The second job will not start before
			the first one has finished. To make jobs resulting from the MethodInvokingJobDetailFactoryBean
			non-concurrent, set the <code class="literal">concurrent</code> flag to <code class="literal">false</code>.
			</p><pre class="programlisting">
&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
  &lt;property name="targetObject" ref="exampleBusinessObject"/&gt;
  &lt;property name="targetMethod" value="doIt"/&gt;
  &lt;property name="concurrent" value="false"/&gt;
&lt;/bean&gt;
			</pre><p>
			<span class="emphasis"><em>Note: By default, jobs will run in a concurrent fashion.</em></span>
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15596"></a>22.2.3.&nbsp;Wiring up jobs using triggers and the SchedulerFactoryBean</h3></div></div></div><p>
			We've created job details, jobs and we've reviewed the convenience bean
			that allows to you invoke a method on a specific object. Of course, we still need
			to schedule the jobs themselves. This is done using triggers and a 
			<code class="literal">SchedulerFactoryBean</code>. Several triggers are available
			within Quartz. Spring offers two subclassed triggers with convenient defaults:
			<code class="literal">CronTriggerBean</code> and <code class="literal">SimpleTriggerBean</code>.
		</p><p>
			Triggers need to be scheduled. Spring offers a SchedulerFactoryBean exposing properties
			to set the triggers. SchedulerFactoryBean schedules the actual jobs with those triggers.
		</p><p>
			A couple of examples:
			</p><pre class="programlisting">
&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean"&gt;
  &lt;!-- see the example of method invoking job above --&gt;
  &lt;property name="jobDetail" ref="jobDetail"/&gt;
	&lt;!-- 10 seconds --&gt;
  &lt;property name="startDelay" value="10000"/&gt;
	&lt;!-- repeat every 50 seconds --&gt;
  &lt;property name="repeatInterval" value="50000"/&gt;
&lt;/bean&gt;

&lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt;
  &lt;property name="jobDetail" ref="exampleJob"/&gt;
	&lt;!-- run every morning at 6 AM --&gt;
  &lt;property name="cronExpression" value="0 0 6 * * ?"/&gt;
&lt;/bean&gt;
			</pre><p>
			OK, now we've set up two triggers, one running every 50 seconds with a starting delay of
			10 seconds and one every morning at 6 AM. To finalize everything, we need to set up the
			SchedulerFactoryBean:
			</p><pre class="programlisting">
&lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
  &lt;property name="triggers"&gt;
    &lt;list&gt;
      &lt;ref bean="cronTrigger"/&gt;
      &lt;ref bean="simpleTrigger"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
			</pre><p>
			More properties are available for the SchedulerFactoryBean for you to set, such as the
			calendars used by the job details, properties to customize Quartz with, etc. Have a look
			at the JavaDoc (<a href="http://www.springframework.org/docs/api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html" target="_top">http://www.springframework.org/docs/api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html</a>)
			for more information.
		</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e15622"></a>22.3.&nbsp;Using JDK Timer support</h2></div></div></div><p>
  		The other way to schedule jobs in Spring is using JDK Timer objects.
  		More information about Timers themselves can be found at
  		<a href="http://java.sun.com/docs/books/tutorial/essential/threads/timer.html" target="_top">http://java.sun.com/docs/books/tutorial/essential/threads/timer.html</a>.
  		The concepts discussed above also apply to the Timer support. You can create
  		custom timers or use the timer that invokes methods. Wiring timers has to be done
  		using the TimerFactoryBean.
  	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15629"></a>22.3.1.&nbsp;Creating custom timers</h3></div></div></div><p>
  			Using the <code class="literal">TimerTask</code> you can create customer timer tasks, similar to Quartz jobs:
  			</p><pre class="programlisting">
public class CheckEmailAddresses extends TimerTask {

  private List emailAddresses;
  
  public void setEmailAddresses(List emailAddresses) {
    this.emailAddresses = emailAddresses;
  }
  
  public void run() {
    // iterate over all email addresses and archive them
  }
}
			</pre><p>
			
			Wiring it up is simple:
			
			</p><pre class="programlisting">
&lt;bean id="checkEmail" class="examples.CheckEmailAddress"&gt;
  &lt;property name="emailAddresses"&gt;
    &lt;list&gt;
      &lt;value&gt;test@springframework.org&lt;/value&gt;
      &lt;value&gt;foo@bar.com&lt;/value&gt;
      &lt;value&gt;john@doe.net&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="scheduledTask" class="org.springframework.scheduling.timer.ScheduledTimerTask"&gt;
  &lt;!-- wait 10 seconds before starting repeated execution --&gt;
  &lt;property name="delay" value="10000"/&gt;
  &lt;!-- run every 50 seconds --&gt;
  &lt;property name="period" value="50000"/&gt;
  &lt;property name="timerTask" ref="checkEmail"/&gt;
&lt;/bean&gt;
			</pre><p>			
		</p><p>
			<span class="emphasis"><em>Letting the task only run once can be done by changing the <code class="literal">period</code> property to -1 (or some other
				negative value)</em></span>				
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15651"></a>22.3.2.&nbsp;Using the MethodInvokingTimerTaskFactoryBean</h3></div></div></div><p>
			Similar to the Quartz support, the Timer support also features a component that
			allows you to periodically invoke a method:
			</p><pre class="programlisting">
&lt;bean id="doIt" class="org.springframework.scheduling.timer.MethodInvokingTimerTaskFactoryBean"&gt;
  &lt;property name="targetObject" ref="exampleBusinessObject"/&gt;
  &lt;property name="targetMethod" value="doIt"/&gt;
&lt;/bean&gt;
</pre><p>
			The above example will result in the <code class="literal">doIt</code> being called on the
      <code class="literal">exampleBusinessObject</code> (see below):
			</p><pre class="programlisting">
public class BusinessObject {
  
  // properties and collaborators
  
  public void doIt() {
    // do the actual work
  }
}
			</pre><p>
			
			Changing the reference of the above example (in which the ScheduledTimerTask is mentioned)
			to the <code class="literal">doIt</code> will result in this task being executed.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15671"></a>22.3.3.&nbsp;Wrapping up: setting up the tasks using the TimerFactoryBean</h3></div></div></div><p>
			The TimerFactoryBean is similar to the Quartz SchedulerFactoryBean in that it serves the same
			purpose: setting up the actual scheduling. The TimerFactoryBean sets up an actual Timer and
			schedules the tasks it has references to. You can specify whether or not daemon threads should
			be used.
			</p><pre class="programlisting">
&lt;bean id="timerFactory" class="org.springframework.scheduling.timer.TimerFactoryBean"&gt;
  &lt;property name="scheduledTimerTasks"&gt;
    &lt;list&gt;
      &lt;!-- see the example above --&gt;
      &lt;ref bean="scheduledTask"/&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;
			</pre><p>	
			That's all!
		</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="testing"></a>Chapter&nbsp;23.&nbsp;Testing</h2></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="unit-testing"></a>23.1.&nbsp;Unit testing</h2></div></div></div><p>You don't need this manual to help you write effective unit
    tests for Spring-based applications.</p><p>One of the main benefits of Dependency Injection is that your code
    should depend far less on the container than in traditional J2EE
    development.</p><p>The POJOs that comprise your application should be testable in JUnit
    tests, with objects simply instantiated using the new operator,
    <span class="emphasis"><em>without Spring or any other container</em></span>. You can use
    mock objects or many other valuable testing techniques, to test your code
    in isolation. If you follow the architecture recommendations around
    Spring--for example, those in <span class="emphasis"><em>J2EE without EJB</em></span>--you
    will find that the resulting clean layering will also greatly facilitate
    testing. For example, you will be able to test service layer objects by
    stubbing or mocking DAO interfaces, without any need to access persistent
    data while running unit tests.</p><p>True unit tests will run extremely quickly, as there is no runtime
    infrastructure to set up, whether application server, database, ORM tool
    etc. Thus emphasizing true unit tests will boost your productivity.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-testing"></a>23.2.&nbsp;Integration testing</h2></div></div></div><p>However, it's also important to be able to perform some
    integration testing without deployment to your application server. This
    will test things such as:</p><div class="itemizedlist"><ul type="disc"><li><p>Correct wiring of your Spring contexts.</p></li><li><p>Data access using JDBC or ORM tool--correctness of SQL
        statements. For example, you can test your DAO implementation classes.</p></li></ul></div><p>Thus Spring provides valuable support for integration testing, in
    the <code class="literal">spring-mock.jar.</code> This can be thought of as a
    significantly superior alternative to in-container testing using tools
    such as Cactus. </p><p>The <code class="literal">org.springframework.test </code>package provides
    valuable superclasses for integration tests using a Spring container, but
    not dependent on an application server or other deployed environment. Such
    tests can run in JUnit--even in an IDE--without any special deployment
    step. They will be slower to run than unit tests, but much faster to run
    than Cactus tests or remote tests relying on deployment to an application
    server.</p><p>The superclasses in this package provide the following
    functionality:</p><div class="itemizedlist"><ul type="disc"><li><p>Context caching.</p></li><li><p>Dependency Injection for test classes.</p></li><li><p>Transaction management appropriate to tests.</p></li><li><p>Inherited instance variables useful for testing.</p></li></ul></div><p>Numerous Interface21 and other projects since late 2004 have
    demonstrated the power and utility of this approach. Let's look at
    some of the important areas of functionality in detail.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15738"></a>23.2.1.&nbsp;Context management and caching</h3></div></div></div><p>The <code class="literal">org.springframework.test</code> package provides
      support for consistent loading of Spring contexts, and caching of loaded
      contexts. The latter is important, because if you are working on a large
      project startup time may become an issue--not because of the overhead of
      Spring itself, but because the objects instantiated by the Spring
      container will themselves take time to instantiate. For example, a
      project with 50-100 Hibernate mapping files might take 10-20 seconds to
      load them, and incurring that cost before running every test case will
      greatly reduce productivity.</p><p>Thus, <code class="literal">AbstractDependencyInjectionSpringContextTests</code>
      has an abstract protected method that subclasses must implement, to
      provide the location of contexts:</p><pre class="programlisting">protected abstract String[] getConfigLocations();</pre><p>This should provide a list of the context locations--typically on
      the classpath--used to configure the application. This will be the same,
      or nearly the same, as the list of config locations specified in web.xml
      or other deployment configuration.</p><p>By default, once loaded, the set of configs will be reused for
      each test case. Thus the setup cost will be incurred only once, and
      subsequent test execution will be much faster.</p><p>In the unlikely case that a test may "dirty" the config
      location, requiring reloading--for example, by changing a bean
      definition or the state of an application object--you can call the
      <code class="literal">setDirty()</code> method on <code class="literal">AbstractDependencyInjectionSpringContextTests</code>
      to cause it to reload the configurations and rebuild the application
      context before executing the next test case.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15766"></a>23.2.2.&nbsp;Dependency Injection of test class instances</h3></div></div></div><p>When <code class="literal">AbstractDependencyInjectionSpringContextTests</code>
      (and subclasses) load your application context, they can optionally
      configure instances of your test classes by Setter Injection. All you
      need to do is to define instance variables and the corresponding
      setters. <code class="literal">AbstractDependencyInjectionSpringContextTests</code>
      will automatically locate the corresponding object in the set of
      configuration files specified in the<code class="literal"> getConfigLocations()
      </code>method. </p><p>The superclasses use <span class="emphasis"><em>autowire by type</em></span>. Thus
      if you have multiple bean definitions of the same type, you cannot rely
      on this approach for those particular beans. In that case, you can use
      the inherited <code class="literal">applicationContext</code> instance variable,
      and explicit lookup using <code class="literal">getBean()</code>.</p><p>If you don't want Setter Injection applied to your test cases,
      don't declare any setters. Or extend <code class="literal">AbstractSpringContextTests</code>--the
      root of the class hierarchy in the <code class="literal">org.springframework.test</code>
      package. It merely contains convenience methods to load Spring contexts,
      and performs no Dependency Injection.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15799"></a>23.2.3.&nbsp;Transaction management</h3></div></div></div><p>One common problem in tests that access a real database is their
      effect on the state of the persistence store. Even when you're using
      a development database, changes to the state may affect future tests.</p><p>Also, many operations--such as inserting to or modifying
      persistence data--can't be done (or verified) outside a transaction.</p><p>The <code class="literal">org.springframework.test.AbstractTransactionalDataSourceSpringContextTests</code>
      superclass (and subclasses) exist to meet this need. By default, they
      create and roll back a transaction for each test case. You simply write
      code that can assume the existence of a transaction. If you call
      transactionally proxied objects in your tests, they will behave
      correctly, according to their transactional semantics.</p><p><code class="literal">AbstractTransactionalSpringContextTests</code> depends
      on a <code class="literal">PlatformTransactionManager</code> bean being defined in
      the application context. The name doesn't matter, due to the use of
      autowire by type.</p><p>Typically you will extend the subclass, <code class="literal">AbstractTransactionalDataSourceSpringContextTests</code>.
      This also requires a <code class="literal">DataSource</code> bean
      definition--again, with any name--is present in the configurations. It
      creates a <code class="literal">JdbcTemplate</code> instance variable that is
      useful for convenient querying, and provides handy methods to delete the
      contents of selected tables. (Remember that the transaction will roll
      back by default, so this is safe.)</p><p>If you want a transaction to commit--unusual, but useful if you
      want a particular test to populate the database, for example--you can
      call the <code class="literal">setComplete()</code> method inherited from
      <code class="literal">AbstractTransactionalSpringContextTests</code>. This will
      cause the transaction to commit instead of roll back.</p><p>There is also convenient ability to end a transaction before the
      test case ends, through calling the <code class="literal">endTransaction() </code>method.
      This will roll back the transaction by default, and commit it only if
      <code class="literal">setComplete() </code>had previously been called. This
      functionality is useful if you want to test the behaviour of
      "disconnected" data objects, such as Hibernate-mapped objects
      that will be used in a web or remoting tier outside a transaction.
      Often, lazy loading errors are discovered only through UI testing; if
      you call <code class="literal">endTransaction()</code> you can ensure correct
      operation of the UI through your JUnit test suite.</p><p><em><span class="remark">Note that these test support classes are designed to work
      with a single database.</span></em></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15851"></a>23.2.4.&nbsp;Convenience variables</h3></div></div></div><p>When you extend org.springframework.test package you will have
      access to the following protected instance variables:</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">applicationContext</code> (<code class="literal">ConfigurableApplicationContext</code>):
          inherited from AbstractDependencyInjectionSpringContextTests. Use
          this to perfom explicit bean lookup, or test the state of the
          context as a whole.</p></li><li><p><code class="literal">jdbcTemplate</code>: inherited from
          <code class="literal">AbstractTransactionalDataSourceSpringContextTests</code>.
          Useful for querying to confirm state. For example, you might query
          before and after testing application code that creates an object and
          persists it using an ORM tool, to verify that the data appears in
          the database. (Spring will ensure that the query runs in the scope
          of the same transaction.) You will need to tell your ORM tool to
          "flush" its changes for this to work correctly, for example
          using the <code class="literal">flush() </code>method on Hibernate's
          <code class="literal">Session</code> interface.</p></li></ul></div><p>Often you will provide an application-wide superclass for
      integration tests that provides further useful instance variables used
      in many tests.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15881"></a>23.2.5.&nbsp;Example</h3></div></div></div><p>The PetClinic sample application included with the Spring
      distribution illustrates the use of these test superclasses (Spring
      1.1.5 and above).</p><p>Most test functionality is included in <code class="literal">AbstractClinicTests</code>,
      for which a partial listing is shown belong:</p><pre class="programlisting">public abstract class AbstractClinicTests extends AbstractTransactionalDataSourceSpringContextTests {

   protected Clinic clinic;

   public void setClinic(Clinic clinic) {
      this.clinic = clinic;
   }

   public void testGetVets() {
      Collection vets = this.clinic.getVets();
      assertEquals("JDBC query must show the same number of vets",
         jdbcTemplate.queryForInt("SELECT COUNT(0) FROM VETS"), 
         vets.size());
      Vet v1 = (Vet) EntityUtils.getById(vets, Vet.class, 2);
      assertEquals("Leary", v1.getLastName());
      assertEquals(1, v1.getNrOfSpecialties());
      assertEquals("radiology", ((Specialty) v1.getSpecialties().get(0)).getName());
      Vet v2 = (Vet) EntityUtils.getById(vets, Vet.class, 3);
      assertEquals("Douglas", v2.getLastName());
      assertEquals(2, v2.getNrOfSpecialties());
      assertEquals("dentistry", ((Specialty) v2.getSpecialties().get(0)).getName());
      assertEquals("surgery", ((Specialty) v2.getSpecialties().get(1)).getName());
}</pre><p>Notes:</p><div class="itemizedlist"><ul type="disc"><li><p>This test case extends <code class="literal">org.springframework.AbstractTransactionalDataSourceSpringContextTests</code>,
          from which it inherits Dependency Injection and transactional
          behaviour.</p></li><li><p>The <code class="literal">clinic</code> instance variable--the
          application object being tested--is set by Dependency Injection
          through the setClinic() method.</p></li><li><p>The testGetVets() method illustrates how the inherited
          <code class="literal">JdbcTemplate</code> variable can be used to verify
          correct behaviour of the application code being tested. This allows
          for stronger tests, and lessens dependency on the exact test data.
          For example, you can add additional rows in the database without
          breaking tests.</p></li><li><p>Like many integration tests using a database, most of the
          tests in <code class="literal">AbstractClinicTests</code> depend on a minimum
          amount of data already in the database before the test cases run.
          You might, however, choose to populate the database in your test
          cases also--again, within the one transaction.</p></li></ul></div><p>The PetClinic application supports three data access
      technologies--JDBC, Hibernate and Apache OJB. Thus <code class="literal">AbstractClinicTests</code>
      does not specify the context locations--this is deferred to subclasses,
      that implement the necessary protected abstract method from
      <code class="literal">AbstractDependencyInjectionSpringContextTests</code>.</p><p>For example, the JDBC implementation of the PetClinic tests
      contains the following method:</p><pre class="programlisting">public class HibernateClinicTests extends AbstractClinicTests {

   protected String[] getConfigLocations() {
      return new String[] { 
         "/org/springframework/samples/petclinic/hibernate/applicationContext-hibernate.xml" 
      };
   }
}</pre><p>As the PetClinic is a very simple application, there is only one
      Spring configuration file. Of course, more complex applications will
      typically break their Spring configuration across multiple files.</p><p>Instead of being defined in a leaf class, config locations will
      often be specified in a common base class for all application-specific
      integration tests. This may also add useful instance
      variables--populated by Dependency Injection, naturally--such as a
      <code class="literal">HibernateTemplate</code>, in the case of an application
      using Hibernate.</p><p>As far as possible, you should have exactly the same Spring
      configuration files in your integration tests as in the deployed
      environment. One likely point of difference concerns database connection
      pooling and transaction infrastructure. If you are deploying to a
      full-blown application server, you will probably use its connection pool
      (available through JNDI) and JTA implementation. Thus in production you
      will use a <code class="literal">JndiObjectFactoryBean</code> for the
      <code class="literal">DataSource</code>, and <code class="literal">JtaTransactionManager</code>.
      JNDI and JTA will not be available in out-of-container integration
      tests, so you should use a combination like the Commons DBCP
      <code class="literal">BasicDataSource</code> and <code class="literal">DataSourceTransactionManager</code>
      or <code class="literal">HibernateTransactionManager</code> for them. You can
      factor out this variant behaviour into a single XML file, having the
      choice between application server and "local" configuration
      separated from all other configuration, which will not vary between the
      test and production environments.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e15960"></a>23.2.6.&nbsp;Running integration tests</h3></div></div></div><p>Integration tests naturally have more environmental dependencies
      than plain unit tests. Such integration testing is an additional form of
      testing, not a substitute for unit testing.</p><p>The main dependency will typically be on a development database
      containing a complete schema used by the application. This may also
      contain test data, set up by a a tool such as a DBUnit, or an import
      using your database's tool set.</p></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="springbeansdtd"></a>Appendix&nbsp;A.&nbsp;<code class="literal">spring-beans.dtd</code></h2></div></div></div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!--
	Spring XML Beans DTD
	Authors: Rod Johnson, Juergen Hoeller, Alef Arendsen, Colin Sampaleanu

	This defines a simple and consistent way of creating a namespace
	of JavaBeans objects, managed by a Spring BeanFactory, read by
	XmlBeanDefinitionReader (with DefaultXmlBeanDefinitionParser).

	This document type is used by most Spring functionality, including
	web application contexts, which are based on bean factories.

	Each "bean" element in this document defines a JavaBean.
	Typically the bean class is specified, along with JavaBean properties
	and/or constructor arguments.

	Bean instances can be "singletons" (shared instances) or "prototypes"
	(independent instances). Further scopes are supposed to be built on top
	of the core BeanFactory infrastructure and are therefore not part of it.

	References among beans are supported, i.e. setting a JavaBean property
	or a constructor argument to refer to another bean in the same factory
	(or an ancestor factory).

	As alternative to bean references, "inner bean definitions" can be used.
	Singleton flags of such inner bean definitions are effectively ignored:
	Inner beans are typically anonymous prototypes.

	There is also support for lists, sets, maps, and java.util.Properties
	as bean property types or constructor argument types.

	As the format is simple, a DTD is sufficient, and there's no need
	for a schema at this point.

	XML documents that conform to this DTD should declare the following doctype:

	&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN"
		"http://www.springframework.org/dtd/spring-beans.dtd"&gt;
--&gt;


&lt;!--
	The document root. A document can contain bean definitions only,
	imports only, or a mixture of both (typically with imports first).
--&gt;
&lt;!ELEMENT beans (
	description?,
	(import | alias | bean)*
)&gt;

&lt;!--
	Default values for all bean definitions. Can be overridden at
	the "bean" level. See those attribute definitions for details.
--&gt;
&lt;!ATTLIST beans default-lazy-init (true | false) "false"&gt;
&lt;!ATTLIST beans default-dependency-check (none | objects | simple | all) "none"&gt;
&lt;!ATTLIST beans default-autowire (no | byName | byType | constructor | autodetect) "no"&gt;

&lt;!--
	Element containing informative text describing the purpose of the enclosing
	element. Always optional.
	Used primarily for user documentation of XML bean definition documents.
--&gt;
&lt;!ELEMENT description (#PCDATA)&gt;


&lt;!--
	Specifies an XML bean definition resource to import.
--&gt;
&lt;!ELEMENT import EMPTY&gt;

&lt;!--
	The relative resource location of the XML bean definition file to import,
	for example "myImport.xml" or "includes/myImport.xml" or "../myImport.xml".
--&gt;
&lt;!ATTLIST import resource CDATA #REQUIRED&gt;


&lt;!--
	Defines an alias for a bean, which can reside in a different definition file.
--&gt;
&lt;!ELEMENT alias EMPTY&gt;

&lt;!--
	The name of the bean to define an alias for.
--&gt;
&lt;!ATTLIST alias name CDATA #REQUIRED&gt;

&lt;!--
	The alias name to define for the bean.
--&gt;
&lt;!ATTLIST alias alias CDATA #REQUIRED&gt;


&lt;!--
	Defines a single (usually named) bean.

	A bean definition may contain nested tags for constructor arguments,
	property values, lookup methods, and replaced methods. Mixing constructor
	injection and setter injection on the same bean is explicitly supported.
--&gt;
&lt;!ELEMENT bean (
	description?,
	(constructor-arg | property | lookup-method | replaced-method)*
)&gt;

&lt;!--
	Beans can be identified by an id, to enable reference checking.

	There are constraints on a valid XML id: if you want to reference your bean
	in Java code using a name that's illegal as an XML id, use the optional
	"name" attribute. If neither is given, the bean class name is used as id
	(with an appended counter like "#2" if there is already a bean with that name).
--&gt;
&lt;!ATTLIST bean id ID #IMPLIED&gt;

&lt;!--
	Optional. Can be used to create one or more aliases illegal in an id.
	Multiple aliases can be separated by any number of spaces or commas.
--&gt;
&lt;!ATTLIST bean name CDATA #IMPLIED&gt;

&lt;!--
	Each bean definition must specify the fully qualified name of the class,
	except if it pure serves as parent for child bean definitions.
--&gt;
&lt;!ATTLIST bean class CDATA #IMPLIED&gt;

&lt;!--
	Optionally specify a parent bean definition.

	Will use the bean class of the parent if none specified, but can
	also override it. In the latter case, the child bean class must be
	compatible with the parent, i.e. accept the parent's property values
	and constructor argument values, if any.

	A child bean definition will inherit constructor argument values,
	property values and method overrides from the parent, with the option
	to add new values. If init method, destroy method, factory bean and/or factory
	method are specified, they will override the corresponding parent settings.

	The remaining settings will always be taken from the child definition:
	depends on, autowire mode, dependency check, singleton, lazy init.
--&gt;
&lt;!ATTLIST bean parent CDATA #IMPLIED&gt;

&lt;!--
	Is this bean "abstract", i.e. not meant to be instantiated itself but
	rather just serving as parent for concrete child bean definitions.
	Default is false. Specify true to tell the bean factory to not try to
	instantiate that particular bean in any case.
--&gt;
&lt;!ATTLIST bean abstract (true | false) "false"&gt;

&lt;!--
	Is this bean a "singleton" (one shared instance, which will
	be returned by all calls to getBean() with the id),
	or a "prototype" (independent instance resulting from each call to
	getBean(). Default is singleton.

	Singletons are most commonly used, and are ideal for multi-threaded
	service objects.
--&gt;
&lt;!ATTLIST bean singleton (true | false) "true"&gt;

&lt;!--
	If this bean should be lazily initialized.
	If false, it will get instantiated on startup by bean factories
	that perform eager initialization of singletons.
--&gt;
&lt;!ATTLIST bean lazy-init (true | false | default) "default"&gt;

&lt;!--
	Optional attribute controlling whether to "autowire" bean properties.
	This is an automagical process in which bean references don't need to be coded
	explicitly in the XML bean definition file, but Spring works out dependencies.

	There are 5 modes:

	1. "no"
	The traditional Spring default. No automagical wiring. Bean references
	must be defined in the XML file via the &lt;ref&gt; element. We recommend this
	in most cases as it makes documentation more explicit.

	2. "byName"
	Autowiring by property name. If a bean of class Cat exposes a dog property,
	Spring will try to set this to the value of the bean "dog" in the current factory.
	If there is no matching bean by name, nothing special happens;
	use dependency-check="objects" to raise an error in that case.

	3. "byType"
	Autowiring if there is exactly one bean of the property type in the bean factory.
	If there is more than one, a fatal error is raised, and you can't use byType
	autowiring for that bean. If there is none, nothing special happens;
	use dependency-check="objects" to raise an error in that case.

	4. "constructor"
	Analogous to "byType" for constructor arguments. If there isn't exactly one bean
	of the constructor argument type in the bean factory, a fatal error is raised.

	5. "autodetect"
	Chooses "constructor" or "byType" through introspection of the bean class.
	If a default constructor is found, "byType" gets applied.

	The latter two are similar to PicoContainer and make bean factories simple to
	configure for small namespaces, but doesn't work as well as standard Spring
	behaviour for bigger applications.

	Note that explicit dependencies, i.e. "property" and "constructor-arg" elements,
	always override autowiring. Autowire behaviour can be combined with dependency
	checking, which will be performed after all autowiring has been completed.
--&gt;
&lt;!ATTLIST bean autowire (no | byName | byType | constructor | autodetect | default) "default"&gt;

&lt;!--
	Optional attribute controlling whether to check whether all this
	beans dependencies, expressed in its properties, are satisfied.
	Default is no dependency checking.

	"simple" type dependency checking includes primitives and String
	"object" includes collaborators (other beans in the factory)
	"all" includes both types of dependency checking
--&gt;
&lt;!ATTLIST bean dependency-check (none | objects | simple | all | default) "default"&gt;

&lt;!--
	The names of the beans that this bean depends on being initialized.
	The bean factory will guarantee that these beans get initialized before.

	Note that dependencies are normally expressed through bean properties or
	constructor arguments. This property should just be necessary for other kinds
	of dependencies like statics (*ugh*) or database preparation on startup.
--&gt;
&lt;!ATTLIST bean depends-on CDATA #IMPLIED&gt;

&lt;!--
	Optional attribute for the name of the custom initialization method
	to invoke after setting bean properties. The method must have no arguments,
	but may throw any exception.
--&gt;
&lt;!ATTLIST bean init-method CDATA #IMPLIED&gt;

&lt;!--
	Optional attribute for the name of the custom destroy method to invoke
	on bean factory shutdown. The method must have no arguments,
	but may throw any exception. Note: Only invoked on singleton beans!
--&gt;
&lt;!ATTLIST bean destroy-method CDATA #IMPLIED&gt;

&lt;!--
	Optional attribute specifying the name of a factory method to use to
	create this object. Use constructor-arg elements to specify arguments
	to the factory method, if it takes arguments. Autowiring does not apply
	to factory methods.

	If the "class" attribute is present, the factory method will be a static
	method on the class specified by the "class" attribute on this bean
	definition. Often this will be the same class as that of the constructed
	object - for example, when the factory method is used as an alternative
	to a constructor. However, it may be on a different class. In that case,
	the created object will *not* be of the class specified in the "class"
	attribute. This is analogous to FactoryBean behavior.

	If the "factory-bean" attribute is present, the "class" attribute is not
	used, and the factory method will be an instance method on the object
	returned from a getBean call with the specified bean name. The factory
	bean may be defined as a singleton or a prototype.

	The factory method can have any number of arguments. Autowiring is not
	supported. Use indexed constructor-arg elements in conjunction with the
	factory-method attribute.

	Setter Injection can be used in conjunction with a factory method.
	Method Injection cannot, as the factory method returns an instance,
	which will be used when the container creates the bean.
--&gt;
&lt;!ATTLIST bean factory-method CDATA #IMPLIED&gt;

&lt;!--
	Alternative to class attribute for factory-method usage.
	If this is specified, no class attribute should be used.
	This should be set to the name of a bean in the current or
	ancestor factories that contains the relevant factory method.
	This allows the factory itself to be configured using Dependency
	Injection, and an instance (rather than static) method to be used.
--&gt;
&lt;!ATTLIST bean factory-bean CDATA #IMPLIED&gt;


&lt;!--
	Bean definitions can specify zero or more constructor arguments.
	This is an alternative to "autowire constructor".
	Arguments correspond to either a specific index of the constructor argument
	list or are supposed to be matched generically by type.

	Note: A single generic argument value will just be used once, rather than
	potentially matched multiple times (as of Spring 1.1).

	constructor-arg elements are also used in conjunction with the factory-method
	element to construct beans using static or instance factory methods.
--&gt;
&lt;!ELEMENT constructor-arg (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)&gt;

&lt;!--
	The constructor-arg tag can have an optional index attribute,
	to specify the exact index in the constructor argument list. Only needed
	to avoid ambiguities, e.g. in case of 2 arguments of the same type.
--&gt;
&lt;!ATTLIST constructor-arg index CDATA #IMPLIED&gt;

&lt;!--
	The constructor-arg tag can have an optional type attribute,
	to specify the exact type of the constructor argument. Only needed
	to avoid ambiguities, e.g. in case of 2 single argument constructors
	that can both be converted from a String.
--&gt;
&lt;!ATTLIST constructor-arg type CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "ref bean=".
--&gt;
&lt;!ATTLIST constructor-arg ref CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "value".
--&gt;
&lt;!ATTLIST constructor-arg value CDATA #IMPLIED&gt;


&lt;!--
	Bean definitions can have zero or more properties.
	Property elements correspond to JavaBean setter methods exposed
	by the bean classes. Spring supports primitives, references to other
	beans in the same or related factories, lists, maps and properties.
--&gt;
&lt;!ELEMENT property (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)&gt;

&lt;!--
	The property name attribute is the name of the JavaBean property.
	This follows JavaBean conventions: a name of "age" would correspond
	to setAge()/optional getAge() methods.
--&gt;
&lt;!ATTLIST property name CDATA #REQUIRED&gt;

&lt;!--
  A short-cut alternative to a child element "ref bean=".
--&gt;
&lt;!ATTLIST property ref CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "value".
--&gt;
&lt;!ATTLIST property value CDATA #IMPLIED&gt;


&lt;!--
	A lookup method causes the IoC container to override the given method and return
	the bean with the name given in the bean attribute. This is a form of Method Injection.
	It's particularly useful as an alternative to implementing the BeanFactoryAware
	interface, in order to be able to make getBean() calls for non-singleton instances
	at runtime. In this case, Method Injection is a less invasive alternative.
--&gt;
&lt;!ELEMENT lookup-method EMPTY&gt;

&lt;!--
	Name of a lookup method. This method should take no arguments.
--&gt;
&lt;!ATTLIST lookup-method name CDATA #IMPLIED&gt;

&lt;!--
	Name of the bean in the current or ancestor factories that the lookup method
	should resolve to. Often this bean will be a prototype, in which case the
	lookup method will return a distinct instance on every invocation. This
	is useful for single-threaded objects.
--&gt;
&lt;!ATTLIST lookup-method bean CDATA #IMPLIED&gt;


&lt;!--
	Similar to the lookup method mechanism, the replaced-method element is used to control
	IoC container method overriding: Method Injection. This mechanism allows the overriding
	of a method with arbitrary code.
--&gt;
&lt;!ELEMENT replaced-method (
	(arg-type)*
)&gt;

&lt;!--
	Name of the method whose implementation should be replaced by the IoC container.
	If this method is not overloaded, there's no need to use arg-type subelements.
	If this method is overloaded, arg-type subelements must be used for all
	override definitions for the method.
--&gt;
&lt;!ATTLIST replaced-method name CDATA #IMPLIED&gt;

&lt;!--
	Bean name of an implementation of the MethodReplacer interface
	in the current or ancestor factories. This may be a singleton or prototype
	bean. If it's a prototype, a new instance will be used for each method replacement.
	Singleton usage is the norm.
--&gt;
&lt;!ATTLIST replaced-method replacer CDATA #IMPLIED&gt;

&lt;!--
	Subelement of replaced-method identifying an argument for a replaced method
	in the event of method overloading.
--&gt;
&lt;!ELEMENT arg-type (#PCDATA)&gt;

&lt;!--
	Specification of the type of an overloaded method argument as a String.
	For convenience, this may be a substring of the FQN. E.g. all the
	following would match "java.lang.String":
	- java.lang.String
	- String
	- Str

	As the number of arguments will be checked also, this convenience can often
	be used to save typing.
--&gt;
&lt;!ATTLIST arg-type match CDATA #IMPLIED&gt;


&lt;!--
	Defines a reference to another bean in this factory or an external
	factory (parent or included factory).
--&gt;
&lt;!ELEMENT ref EMPTY&gt;

&lt;!--
	References must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	to be checked at runtime.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
--&gt;
&lt;!ATTLIST ref bean CDATA #IMPLIED&gt;
&lt;!ATTLIST ref local IDREF #IMPLIED&gt;
&lt;!ATTLIST ref parent CDATA #IMPLIED&gt;


&lt;!--
	Defines a string property value, which must also be the id of another
	bean in this factory or an external factory (parent or included factory).
	While a regular 'value' element could instead be used for the same effect,
	using idref in this case allows validation of local bean ids by the xml
	parser, and name completion by helper tools.
--&gt;
&lt;!ELEMENT idref EMPTY&gt;

&lt;!--
	ID refs must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	potentially to be checked at runtime by bean factory implementations.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
--&gt;
&lt;!ATTLIST idref bean CDATA #IMPLIED&gt;
&lt;!ATTLIST idref local IDREF #IMPLIED&gt;


&lt;!--
	Contains a string representation of a property value.
	The property may be a string, or may be converted to the
	required type using the JavaBeans PropertyEditor
	machinery. This makes it possible for application developers
	to write custom PropertyEditor implementations that can
	convert strings to objects.

	Note that this is recommended for simple objects only.
	Configure more complex objects by populating JavaBean
	properties with references to other beans.
--&gt;
&lt;!ELEMENT value (#PCDATA)&gt;

&lt;!--
	The value tag can have an optional type attribute, to specify the
	exact type that the value should be converted to. Only needed
	if the type of the target property or constructor argument is
	too generic: for example, in case of a collection element.
--&gt;
&lt;!ATTLIST value type CDATA #IMPLIED&gt;

&lt;!--
	Denotes a Java null value. Necessary because an empty "value" tag
	will resolve to an empty String, which will not be resolved to a
	null value unless a special PropertyEditor does so.
--&gt;
&lt;!ELEMENT null (#PCDATA)&gt;


&lt;!--
	A list can contain multiple inner bean, ref, collection, or value elements.
	Java lists are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
	A list can also map to an array type. The necessary conversion
	is automatically performed by the BeanFactory.
--&gt;
&lt;!ELEMENT list (
	(bean | ref | idref | value | null | list | set | map | props)*
)&gt;

&lt;!--
	A set can contain multiple inner bean, ref, collection, or value elements.
	Java sets are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
--&gt;
&lt;!ELEMENT set (
	(bean | ref | idref | value | null | list | set | map | props)*
)&gt;


&lt;!--
	A Spring map is a mapping from a string key to object.
	Maps may be empty.
--&gt;
&lt;!ELEMENT map (
	(entry)*
)&gt;

&lt;!--
	A map entry can be an inner bean, ref, value, or collection.
	The key of the entry is given by the "key" attribute or child element.
--&gt;
&lt;!ELEMENT entry (
  key?,
	(bean | ref | idref | value | null | list | set | map | props)?
)&gt;

&lt;!--
	Each map element must specify its key as attribute or as child element.
	A key attribute is always a String value.
--&gt;
&lt;!ATTLIST entry key CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a "key" element with a "ref bean=" child element.
--&gt;
&lt;!ATTLIST entry key-ref CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "value".
--&gt;
&lt;!ATTLIST entry value CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "ref bean=".
--&gt;
&lt;!ATTLIST entry value-ref CDATA #IMPLIED&gt;

&lt;!--
	A key element can contain an inner bean, ref, value, or collection.
--&gt;
&lt;!ELEMENT key (
	(bean | ref | idref | value | null | list | set | map | props)
)&gt;


&lt;!--
	Props elements differ from map elements in that values must be strings.
	Props may be empty.
--&gt;
&lt;!ELEMENT props (
	(prop)*
)&gt;

&lt;!--
	Element content is the string value of the property.
	Note that whitespace is trimmed off to avoid unwanted whitespace
	caused by typical XML formatting.
--&gt;
&lt;!ELEMENT prop (#PCDATA)&gt;

&lt;!--
	Each property element must specify its key.
--&gt;
&lt;!ATTLIST prop key CDATA #REQUIRED&gt;
</pre></div></div></body></html>